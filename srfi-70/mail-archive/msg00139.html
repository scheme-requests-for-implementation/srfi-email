<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: inexactness vs. exactness -->
<!--X-From-R13: orne <orneNfbavp.arg> -->
<!--X-Date: Tue, 19 Jul 2005 04:31:47 +0200 (DFT) -->
<!--X-Message-Id: Pine.LNX.4.58.0507181844440.8883@bolt.sonic.net -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: y9lvf38ba3a.fsf@informatik.uni&#45;tuebingen.de -->
<!--X-Reference: Pine.LNX.4.58.0507180818240.7111@bolt.sonic.net -->
<!--X-Reference: 20050718235825.0D1381B77B4@voluntocracy.org -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: inexactness vs. exactness</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00138.html">Date Prev</a>][<a href="msg00140.html">Date Next</a>][<a href="msg00137.html">Thread Prev</a>][<a href="msg00146.html">Thread Next</a>][<a href="maillist.html#00139">Date Index</a>][<a href="threads.html#00139">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: inexactness vs. exactness</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-70">SRFI 70</a> from before July 7th, 2015.  The <a href="http://srfi-email.schemers.org/srfi-70">new archives</a> for SRFI 70 contain all messages, not just those from before July 7th, 2015.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: Aubrey Jaffer &lt;<a href="mailto:agj@DOMAIN.HIDDEN">agj@xxxxxxxxxxxx</a>&gt;</li>
<li><em>Subject</em>: Re: inexactness vs. exactness</li>
<li><em>From</em>: bear &lt;<a href="mailto:bear@DOMAIN.HIDDEN">bear@xxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Mon, 18 Jul 2005 19:31:25 -0700 (PDT)</li>
<li><em>Cc</em>: <a href="mailto:srfi-70@DOMAIN.HIDDEN">srfi-70@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-70@DOMAIN.HIDDEN">srfi-70@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:20050718235825.0D1381B77B4@DOMAIN.HIDDEN">20050718235825.0D1381B77B4@xxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>References</em>: &lt;<a href="mailto:y9lvf38ba3a.fsf@DOMAIN.HIDDEN">y9lvf38ba3a.fsf@xxxxxxxxxxxxxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:Pine.LNX.4.58.0507180818240.7111@DOMAIN.HIDDEN">Pine.LNX.4.58.0507180818240.7111@xxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20050718235825.0D1381B77B4@DOMAIN.HIDDEN">20050718235825.0D1381B77B4@xxxxxxxxxxxxxxxx</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>

On Mon, 18 Jul 2005, Aubrey Jaffer wrote:

&gt; | Date: Mon, 18 Jul 2005 08:50:50 -0700 (PDT)
&gt; | From: bear &lt;bear@xxxxxxxxx&gt;
&gt; |
&gt; | This draft effectively eliminates certain properties of
&gt; | inexactness vs. exactness,
&gt;
&gt;SRFI-70 sharpens the distinction between inexacts and exacts.

It requires inexact numbers in many situations where exact
numbers can be produced.

&gt;From
&gt;the R5RS notation of inexacts it deduces their nature as real
&gt;neighborhoods.

A point on which we disagree.  I don't think any such nature
was inherent in R5RS.

&gt; Because exact numbers in Scheme designate single
&gt; mathematical numbers, the idea of exactness as a superficial attribute
&gt; of numbers must be jettisoned.

A conclusion based on the point on which we disagree.  It is
not at all surprising that we disagree about this conclusion
also.  Inexactness denotes that we cannot be certain that the
specific, precise number is the correct specific precise number;
it does not transform the number into a numeric neighborhood.
Exact and inexact numbers, except for this sole quality, denote
exactly the same thing.

&gt;  Inexactness is as much a property of calculation as it is of data
&gt;  sources.  A language having latent types does not obviate the
&gt;  programmer's expectation that a calculation involving transcendental
&gt;  functions should return an inexact result.

But if error-free results happen to be available, we should
therefore disregard them?  What?!

&gt;      An operation may, however, return an exact result if it can
&gt;      prove that the value of the result is unaffected by the
&gt;      inexactness of its arguments.  For example, multiplication of
&gt;      any number by an exact zero may produce an exact zero result,
&gt;      even if the other argument is inexact.
&gt;
&gt;  By those sentences, inexactness is a contagious property of all
&gt;  numbers; except 0, the only number whose exactness is contagious!
&gt;  This conflicts with the statement earlier in 6.2.2:

No... by those sentences, inexactness in the sense of possible
error propagates forward from arguments into results wherever
we cannot prove that the inexactness doesn't introduce the
possibility of error in results.  A multiplication by an exact
zero is only one of many possibilities here.

&gt; | and in doing so it creates a type distinction where none was
&gt; | before.
&gt;
&gt; Is exactness this &quot;type distinction&quot;?

Yep.  What you're doing is declaring that in some circumstances
we have to pretend we are uncertain of our results even though
there is a mathematical certainty that they are correct.  The
sole purpose for this is to fulfill an expectation that inexact
results will be returned; you are valuing numeric type above
reporting correct answers.

&gt; | In the dialect spec'd by R5RS, there was never any situation
&gt; | where an inexact number was required and an exact one would
&gt; | not do; thus it was entirely correct for implementations to
&gt; | return exact numbers whenever the opportunity presented
&gt; | itself.
&gt;
&gt;Implementations like Elk, Gambit, and Mzscheme signal errors for
&gt;division by exact zero, but return infinities for division by inexact
&gt;zero.  This is a &quot;situation where an inexact number was required and
&gt;an exact one would not do&quot;.

That wasn't behavior specified by R5RS, was it?  That was the
decision of a few implementors, who created an inconsistency
and a type distinction.  This inconsistency was not created
by the standard, and does not need to be &quot;fixed&quot; in the standard.

&gt; This created the contradiction noted above.  With exact 0 being
&gt; stronger than inexact 0.0, it also leads to the opaque practice of
&gt; controlling the behavior of EXPT and `/' at 0 by coercing the
&gt; exactness of its arguments.

&quot;strength&quot; has nothing to do with it.  It is merely a mathematical
fact.  Any number may be multiplied by zero to get zero.  If there
is no uncertainty that the zero is the correct value (ie, if it's
an &quot;exact&quot; zero in R5RS parlance) it does not matter a bit whether
there is certainty about the other operand.  Differences in the
value of the other operand do not introduce any mathematical
uncertainty (inexactness) that the result of zero is correct.
Infinity in the sense of &quot;some number too large to represent&quot;
is no exception to this rule;  Infinity in the sense of a true
mathematical infinity is, but the result of such a
multiplication is neither exact nor inexact; it is a NaN.

&gt; I have authority to propose whatever I want.  And the R6RS editors
&gt; have the authority to accept it, modify it, or ignore it.

Yes, I suppose that's what it comes down to.  I hope to see
better treatment of numeric error objects than you propose.

&gt; I do a lot of numerical computing (near-field optics lately).
&gt; Division by zero happens.  If SIN of some complicated expression
&gt; returns an exact zero .001% of the time, then .001% of the time I will
&gt; get an exception from the division taking that expression as a divisor
&gt; rather than an infinity which lets the program continue.

This problem belongs to your implementation, not to R5RS.
It would be perfectly compliant with R5RS and consistent
treatment of numbers if your system raised an exception
in both cases or returned an error object (such as an
infinity or a NaN) in both cases.

&gt;That is broken behavior; but that is what R5RS-compliant Mzscheme 205
&gt;does; and probably other implementations also.

I don't argue with you that it is broken behavior; but I
don't see the point in predicating changes to the standard
based on a few implementations' inconsistent treatment of
exact and inexact numbers.

The situation is that you have a headache because you
don't know whether the results will be exact or inexact,
*and* the implementations you're using happen to treat
exact and inexact numbers inconsistently;

Inconsistency &amp;&amp; Uncertainty -&gt; Headache.

You want this headache to go away, so do the ordinary
boolean math, and you get...

!Headache -&gt; !Inconsistency || !Uncertainty

In other words, this headache goes away if you know whether
the results will be exact or inexact, *or* it goes away if
implementations treat exact and inexact numbers consistently.
Since the former involves pretending there is a possibility
of error even where there is none and we can prove it, and
thus discards useful information, why not ask for the latter
instead?

Isn't the inconsistent treatment (one continues and one
signals an error) your problem?  Why not call that incorrect
behavior instead of calling an occasional blessing of extra
information about the accuracy of the answer incorrect
behavior?

				Bear


</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00146" href="msg00146.html">Re: inexactness vs. exactness</a></strong>
<ul><li><em>From:</em> Aubrey Jaffer</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00129" href="msg00129.html">Revision of SRFI 70 available</a></strong>
<ul><li><em>From:</em> Michael Sperber</li></ul></li>
<li><strong><a name="00130" href="msg00130.html">Re: Revision of SRFI 70 available</a></strong>
<ul><li><em>From:</em> bear</li></ul></li>
<li><strong><a name="00137" href="msg00137.html">inexactness vs. exactness</a></strong>
<ul><li><em>From:</em> Aubrey Jaffer</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00138.html">Re: Nitpick with FLOOR etc.</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00140.html">Re: Nitpick with FLOOR etc.</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00137.html">inexactness vs. exactness</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00146.html">Re: inexactness vs. exactness</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00139"><strong>Date</strong></a></li>
<li><a href="threads.html#00139"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
