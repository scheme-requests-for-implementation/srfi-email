<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: inexactness vs. exactness -->
<!--X-From-R13: Ohoerl Xnssre <ntwNnyhz.zvg.rqh> -->
<!--X-Date: Thu, 21 Jul 2005 19:01:40 +0200 (DFT) -->
<!--X-Message-Id: 20050721170155.F3A021B77B4@voluntocracy.org -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: y9lvf38ba3a.fsf@informatik.uni&#45;tuebingen.de -->
<!--X-Reference: Pine.LNX.4.58.0507180818240.7111@bolt.sonic.net -->
<!--X-Reference: 20050718235825.0D1381B77B4@voluntocracy.org -->
<!--X-Reference: Pine.LNX.4.58.0507181844440.8883@bolt.sonic.net -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: inexactness vs. exactness</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00145.html">Date Prev</a>][<a href="msg00147.html">Date Next</a>][<a href="msg00139.html">Thread Prev</a>][<a href="msg00149.html">Thread Next</a>][<a href="maillist.html#00146">Date Index</a>][<a href="threads.html#00146">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: inexactness vs. exactness</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-70">SRFI 70</a> from before July 7th, 2015.  The new archives for SRFI 70 are <a href="http://srfi-email.schemers.org/srfi-70/">here</a>.  The new archives contain all messages, not just those from before July 7th, 2015.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: <a href="mailto:bear@DOMAIN.HIDDEN">bear@xxxxxxxxx</a></li>
<li><em>Subject</em>: Re: inexactness vs. exactness</li>
<li><em>From</em>: Aubrey Jaffer &lt;<a href="mailto:agj@DOMAIN.HIDDEN">agj@xxxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Thu, 21 Jul 2005 13:01:55 -0400 (EDT)</li>
<li><em>Cc</em>: <a href="mailto:srfi-70@DOMAIN.HIDDEN">srfi-70@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-70@DOMAIN.HIDDEN">srfi-70@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:Pine.LNX.4.58.0507181844440.8883@DOMAIN.HIDDEN">Pine.LNX.4.58.0507181844440.8883@xxxxxxxxxxxxxx</a>&gt; (message from	bear on Mon, 18 Jul 2005 19:31:25 -0700 (PDT))</li>
<li><em>References</em>: &lt;<a href="mailto:y9lvf38ba3a.fsf@DOMAIN.HIDDEN">y9lvf38ba3a.fsf@xxxxxxxxxxxxxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:Pine.LNX.4.58.0507180818240.7111@DOMAIN.HIDDEN">Pine.LNX.4.58.0507180818240.7111@xxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20050718235825.0D1381B77B4@DOMAIN.HIDDEN">20050718235825.0D1381B77B4@xxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:Pine.LNX.4.58.0507181844440.8883@DOMAIN.HIDDEN">Pine.LNX.4.58.0507181844440.8883@xxxxxxxxxxxxxx</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre> | Date: Mon, 18 Jul 2005 19:31:25 -0700 (PDT)
 | From: bear &lt;bear@xxxxxxxxx&gt;
 | 
 | On Mon, 18 Jul 2005, Aubrey Jaffer wrote:
 | 
 | &gt; | Date: Mon, 18 Jul 2005 08:50:50 -0700 (PDT)
 | &gt; | From: bear &lt;bear@xxxxxxxxx&gt;
 | &gt; |
 | &gt; | This draft effectively eliminates certain properties of
 | &gt; | inexactness vs. exactness,
 | &gt;
 | &gt;SRFI-70 sharpens the distinction between inexacts and exacts.
 | 
 | It requires inexact numbers in many situations where exact
 | numbers can be produced.
 | 
 | &gt;From
 | &gt;the R5RS notation of inexacts it deduces their nature as real
 | &gt;neighborhoods.
 | 
 | A point on which we disagree.  I don't think any such nature
 | was inherent in R5RS.

You are suggesting that an implementation in which inexact numbers are
not neighborhoods can conform to R5RS.  I will show that this is
impossible.

If real inexacts are not neighborhoods, then they correspond to single
mathematical numbers (points).

The number of inexact numbers possible in this hypothetical system is
either finite or not.

Finite number of inexacts:

  There are an infinite number of possible continuous formulas (Scheme
  procedures) yielding distinct values when applied to inexact
  arguments.  If the number of possible inexact numbers is finite,
  then an infinite number of the formula results must map to the
  finite inexacts; and (because of continuity) they must be
  neighborhoods.

Infinite number of inexacts:

  There are an infinite number of possible formulas (Scheme
  procedures) involving transcendental functions yielding distinct
  values when applied to inexact arguments.

    R5RS 6.2.2 Exactness states:

    If two implementations produce exact results for a computation
    that did not involve inexact intermediate results, the two
    ultimate results will be mathematically equivalent.  This is
    generally not true of computations involving inexact numbers since
    approximate methods such as floating point arithmetic may be used,
=&gt;  but it is the duty of each implementation to make the result as
=&gt;  close as practical to the mathematically ideal result.

  By R5RS 6.2.2, if a transcendental function returns an approximate
  result, then it must map to the nearest inexact number.  Thus
  inexacts designate their closest neighborhoods.

  Otherwise, the results of transcendental functions must not
  approximate; they must be mathematically correct.  But formulas
  yielding the same mathematical result must return inexact numbers
  which are `='.  Because those formulas include

    (log 2), (* 4 (atan 1)) [pi], exp, and sin,

  the equality between the results of two formulas is undecidable
  by a theorem of Richardson [Richardson1968].

So, not only is it proved that:

* Scheme inexact real numbers correspond to real neighborhoods;

applying the same logic to exact numbers proves that:

* it is not possible to create a real number representation with total
  order (comparisons) which is exact for all transcendental functions.

 | &gt; Because exact numbers in Scheme designate single mathematical
 | &gt; numbers, the idea of exactness as a superficial attribute of
 | &gt; numbers must be jettisoned.
 | 
 | A conclusion based on the point on which we disagree. ...

The proof above makes this no longer a matter of opinion.

 | &gt;  Inexactness is as much a property of calculation as it is of
 | &gt;  data sources.  A language having latent types does not obviate
 | &gt;  the programmer's expectation that a calculation involving
 | &gt;  transcendental functions should return an inexact result.
 | 
 | But if error-free results happen to be available, we should
 | therefore disregard them?  What?!

FreeSnell calculates optical properties from measured refractive-index
tables.  That lone exact 0 in the denominator becomes +/0. and is
discarded -- if the Scheme implementation doesn't signal an error!

 | &gt;      An operation may, however, return an exact result if it can
 | &gt;      prove that the value of the result is unaffected by the
 | &gt;      inexactness of its arguments.  For example, multiplication
 | &gt;      of any number by an exact zero may produce an exact zero
 | &gt;      result, even if the other argument is inexact.
 | &gt;
 | &gt;  By those sentences, inexactness is a contagious property of all
 | &gt;  numbers; except 0, the only number whose exactness is
 | &gt;  contagious!  This conflicts with the statement earlier in 6.2.2:
 | 
 | No... by those sentences, inexactness in the sense of possible
 | error propagates forward from arguments into results wherever we
 | cannot prove that the inexactness doesn't introduce the possibility
 | of error in results.  A multiplication by an exact zero is only one
 | of many possibilities here.

What other exact argument to multiplication gives an exact result
despite other arguments being inexact?

 | &gt; | and in doing so it creates a type distinction where none was
 | &gt; | before.
 | &gt;
 | &gt; Is exactness this &quot;type distinction&quot;?
 | 
 | Yep.  What you're doing is declaring that in some circumstances we
 | have to pretend we are uncertain of our results even though there
 | is a mathematical certainty that they are correct.  The sole
 | purpose for this is to fulfill an expectation that inexact results
 | will be returned; you are valuing numeric type above reporting
 | correct answers.

Having one &quot;error-free&quot; number among millions of approximations is of
no practical use; and it interferes with the calculation in more than
one R5RS-compliant implementation.

 | &gt; | In the dialect spec'd by R5RS, there was never any situation
 | &gt; | where an inexact number was required and an exact one would
 | &gt; | not do; thus it was entirely correct for implementations to
 | &gt; | return exact numbers whenever the opportunity presented
 | &gt; | itself.
 | &gt;
 | &gt;Implementations like Elk, Gambit, and Mzscheme signal errors for
 | &gt;division by exact zero, but return infinities for division by
 | &gt;inexact zero.  This is a &quot;situation where an inexact number was
 | &gt;required and an exact one would not do&quot;.
 | 
 | That wasn't behavior specified by R5RS, was it?

No, it was behavior allowed by R5RS.

 | That was the decision of a few implementors, who created an
 | inconsistency and a type distinction.  This inconsistency was not
 | created by the standard, and does not need to be &quot;fixed&quot; in the
 | standard.

If it doesn't say you can't; then you can.  Which text in R5RS
prohibits this inconsistency or type distinction?

 | &gt; This created the contradiction noted above.  With exact 0 being
 | &gt; stronger than inexact 0.0, it also leads to the opaque practice
 | &gt; of controlling the behavior of EXPT and `/' at 0 by coercing the
 | &gt; exactness of its arguments.
 | 
 | &quot;strength&quot; has nothing to do with it.  It is merely a mathematical
 | fact.  Any number may be multiplied by zero to get zero.  If there
 | is no uncertainty that the zero is the correct value (ie, if it's
 | an &quot;exact&quot; zero in R5RS parlance) it does not matter a bit whether
 | there is certainty about the other operand.  Differences in the
 | value of the other operand do not introduce any mathematical
 | uncertainty (inexactness) that the result of zero is correct.
 | Infinity in the sense of &quot;some number too large to represent&quot; is no
 | exception to this rule; Infinity in the sense of a true
 | mathematical infinity is, but the result of such a multiplication
 | is neither exact nor inexact; it is a NaN.

Already the case in SRFI-70:

  (* 0 +/0.)                             ==&gt;  0/0.

You may not like the word &quot;strength&quot;, but you are describing the same
thing: a 0 which is stronger than 0.0 under multiplication.

 | &gt; I do a lot of numerical computing (near-field optics lately).
 | &gt; Division by zero happens.  If SIN of some complicated expression
 | &gt; returns an exact zero .001% of the time, then .001% of the time I will
 | &gt; get an exception from the division taking that expression as a divisor
 | &gt; rather than an infinity which lets the program continue.
 | 
 | This problem belongs to your implementation, not to R5RS.
 | It would be perfectly compliant with R5RS and consistent
 | treatment of numbers if your system raised an exception
 | in both cases or returned an error object (such as an
 | infinity or a NaN) in both cases.

It sounds like you are you asserting that one can't write a portable
numerical application in Scheme relying on just R5RS.  SRFI-70 intends
to make numeric portability easier.

 | &gt;That is broken behavior; but that is what R5RS-compliant Mzscheme 205
 | &gt;does; and probably other implementations also.
 | 
 | I don't argue with you that it is broken behavior; but I
 | don't see the point in predicating changes to the standard
 | based on a few implementations' inconsistent treatment of
 | exact and inexact numbers.

The purpose of standards is to reduce inconsistency between
implementations.

			      -=-=-=-=-

[Richardson1968]

  D. Richardson,
  Some Undecidable Problems Involving Elementary Functions of a Real
  Variable,
  Journal of Symbolic Logic, Volume 33, Number 4, Dec. 1968, pp514--520.

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00149" href="msg00149.html">Re: inexactness vs. exactness</a></strong>
<ul><li><em>From:</em> bear</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00129" href="msg00129.html">Revision of SRFI 70 available</a></strong>
<ul><li><em>From:</em> Michael Sperber</li></ul></li>
<li><strong><a name="00130" href="msg00130.html">Re: Revision of SRFI 70 available</a></strong>
<ul><li><em>From:</em> bear</li></ul></li>
<li><strong><a name="00137" href="msg00137.html">inexactness vs. exactness</a></strong>
<ul><li><em>From:</em> Aubrey Jaffer</li></ul></li>
<li><strong><a name="00139" href="msg00139.html">Re: inexactness vs. exactness</a></strong>
<ul><li><em>From:</em> bear</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00145.html">Re: Nitpick with FLOOR etc.</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00147.html">Re: Nitpick with FLOOR etc.</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00139.html">Re: inexactness vs. exactness</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00149.html">Re: inexactness vs. exactness</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00146"><strong>Date</strong></a></li>
<li><a href="threads.html#00146"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
