<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: inexactness vs. exactness -->
<!--X-From-R13: Ivyyvnz R Qyvatre <jvyyNppf.arh.rqh> -->
<!--X-Date: Tue, 26 Jul 2005 19:57:59 +0200 (DFT) -->
<!--X-Message-Id: y9liryx5u1m.fsf@sams.informatik.uni&#45;tuebingen.de -->
<!--X-Content-Type: text/plain -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: inexactness vs. exactness</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00166.html">Date Prev</a>][<a href="msg00168.html">Date Next</a>][<a href="msg00173.html">Thread Prev</a>][<a href="msg00168.html">Thread Next</a>][<a href="maillist.html#00167">Date Index</a>][<a href="threads.html#00167">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: inexactness vs. exactness</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-70">SRFI 70</a> from before July 7th, 2015.  The <a href="http://srfi-email.schemers.org/srfi-70">new archives</a> for SRFI 70 contain all messages, not just those from before July 7th, 2015.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: <a href="mailto:srfi-70@DOMAIN.HIDDEN">srfi-70@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Subject</em>: Re: inexactness vs. exactness</li>
<li><em>From</em>: William D Clinger &lt;<a href="mailto:will@DOMAIN.HIDDEN">will@xxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Tue, 26 Jul 2005 19:57:57 +0200</li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-70@DOMAIN.HIDDEN">srfi-70@xxxxxxxxxxxxxxxxx</a></li>
<li><em>User-agent</em>: Gnus/5.110003 (No Gnus v0.3) XEmacs/21.5-b20 (berkeley-unix)</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>I doubt whether pseudo-mathematical arguments are really helpful,
but one way to discourage them is to enumerate the fallacies on
which they are based.

On 21 July 2005, Aubrey Jaffer wrote:

&gt; You are suggesting that an implementation in which inexact numbers are
&gt; not neighborhoods can conform to R5RS.  I will show that this is
&gt; impossible.

On 22 July (but delayed until 24 July in this archive), I paraphrased
Jaffer's statement above as

&gt; Aubrey Jaffer claims to have proved that the language of
&gt; the R5RS not only regards inexact numbers as neighborhoods,
&gt; but that no other interpretations of the R5RS are tenable.

On 24 July, Jaffer quoted the first part of my paraphrase and wrote:

&gt; No, it claims that inexact numbers are in one-to-one correspondence
&gt; with neighborhoods around their nominal values.

If that was all Jaffer was claiming, then he misspoke when he
denied that &quot;an implementation in which inexact numbers are not
neighborhoods can conform to R5RS&quot;.  Indeed, if that was all
Jaffer was claiming, then his alleged proofs are needlessly
complex, and he should not object to the simpler interpretation
that identifies all finite inexact complex values z with the
mathematical closed neighborhood consisting of z itself and
nothing else.

I offered to enumerate Jaffer's errors of logic if anyone remains
convinced by Jaffer's first alleged proof.  Responding to that,
Jaffer wrote:

&gt; Yes I would.  I have appended a detailed proof of the first part
&gt; (finite number of inexacts).

I take this to mean that he remains convinced by his first alleged
proof, and also wants me to identify the errors in it and also in
his new &quot;detailed proof&quot;.

Sensible people can stop reading now.  What follows is only for
those who remain convinced by Jaffer's alleged proofs.

                                * * *

&gt;From Jaffer's first alleged proof:

&gt; If real inexacts are not neighborhoods, then they correspond to single
&gt; mathematical numbers (points).

This has no basis in logic, mathematics, or the R5RS.  One might
as well say that if real inexacts are not neighborhoods, then they
correspond to real numbers, or to grains of sand.

&gt; The number of inexact numbers possible in this hypothetical system is
&gt; either finite or not.

The number of inexact numbers that are possible in the system
described by the R5RS is potentially infinite, but is finite
in most implementations.  In what follows, Jaffer goes back
and forth between speaking of the potential infinity described
by the R5RS, and the finite cardinality implemented in most
implementations.  That made it easier for him to appear to
deduce his invalid conclusions.

&gt; Finite number of inexacts:
&gt; 
&gt;   There are an infinite number of possible continuous formulas (Scheme
&gt;   procedures) yielding distinct values when applied to inexact
&gt;   arguments.

Here Jaffer appears to identify &quot;continuous formulas&quot; with Scheme
procedures, which is nonsense.  Perhaps he means only that there
are infinitely many Scheme procedures that, if interpreted over
the mathematical reals instead of the inexact reals (which have
a discrete topology in most implementations), would represent
continuous functions.

&gt; If the number of possible inexact numbers is finite,

Which is not true.  The number of possible inexact numbers is
potentially infinite.  We may therefore disregard the rest of
this paragraph in Jaffer's alleged proof.

&gt; Infinite number of inexacts:
&gt; 
&gt;   There are an infinite number of possible formulas (Scheme
&gt;   procedures) involving transcendental functions yielding distinct
&gt;   values when applied to inexact arguments.

The &quot;transcendental functions&quot; is a red herring.

It is true that there are an infinite number of possible formulas
(or Scheme procedures, for that matter).  If we are talking about
mathematical formulas, then there are infinitely many formulas
that represent infinitely many different functions over the real
or complex numbers.

If we are talking about Scheme procedures, however, then they
represent only a potential infinity of different functions over
Scheme's inexact numbers.  In most implementations of Scheme,
the Scheme procedures represent only finitely many different
functions.

Jaffer then quotes the R5RS's admonishment in Section 6.2.2 that,
for inexact arithmetic, &quot;it is the duty of each implementation to
make the result as close as practical to the mathematically ideal
result&quot;.  From that he pretends to infer:

&gt; By R5RS 6.2.2, if a transcendental function returns an approximate
&gt; result, then it must map to the nearest inexact number.

This is nonsense on several levels.  For starters, what does &quot;map
to&quot; mean?  If Jaffer thinks the R5RS requires transcendental
functions such as ASIN to return the inexact number that is nearest
to the mathematically ideal result, then he's just wrong.  The R5RS
contains no such requirement, nor do the relevant IEEE standards
for floating point arithmetic.  To me, &quot;as close as practical&quot; here
means that implementations have a duty to implement library functions
that are as accurate as the state of the art permits, consistent with
reasonable efficiency.  Jaffer may have a different interpretation,
but his interpretation is no more authoritative than mine.

On the basis of the hogwash already cited, Jaffer concludes that

&gt; So, not only is it proved that:
&gt; 
&gt; * Scheme inexact real numbers correspond to real neighborhoods;

He has proved no such thing.

He goes on to say:

&gt; applying the same logic to exact numbers proves that:
&gt; 
&gt; * it is not possible to create a real number representation with total
&gt;   order (comparisons) which is exact for all transcendental functions.

Someone should tell Dedekind and Cauchy.

I think what Jaffer is trying to say is that it is not possible to
create a representation for real numbers that is exact for all
transcendental functions (once again, the &quot;transcendental&quot; is a
red herring) for which the ordering predicate is decidable.  That
is a true fact, but it is independent of Jaffer's arguments.  He
would have done better just to state it up front, without bothering
to give his pseudo-proofs.

Yet Jaffer claims that

&gt; The proof above makes this no longer a matter of opinion.

Following this howler, Jaffer makes some legitimate criticisms
of the R5RS, pointing out several portability problems.

                                * * *

Jaffer's first proof actually stated the proposition that he was
allegedly proving, but (as quoted near the beginning of this long
post) he no longer claims to claim that proposition.

Jaffer's new &quot;detailed proof&quot; never states the proposition it is
alleged to prove, so it's a little hard to tell where Jaffer's
back-pedalling ends and his new &quot;detailed proof&quot; begins.  I will
therefore content myself with pointing out several errors in his
presentation.

&gt; Given:
&gt; 
&gt; {a} A R5RS-compliant implementation has a finite number greater
&gt;     than 1 of inexact number equivalence classes under the
&gt;     transitive R5RS predicate `='.

That is certainly true in most R5RS-compliant implementations,
but is not true of all conceivable R5RS-compliant implementations.

&gt; {b} That implementation contains an inexact number class #i1.0
&gt;     such that
&gt; 
&gt;     (eqv? #i1.0 (string-&gt;number &quot;1.0&quot;))

What does it mean for that implementation to contain an inexact
number class #i1.0 such that (eqv? #i1.0 (string-&gt;number &quot;1.0&quot;))?

Maybe he means that the implementation contains an inexact number,
namely #i1.0, that satisfies (eqv? #i1.0 (string-&gt;number &quot;1.0&quot;)),
and the &quot;inexact number class&quot; was just a way for Jaffer to assume
the conclusion he has yet to prove.

&gt;From what he writes later, however, I think he actually means
that Jaffer's mind can construct the mathematical class

    { x | x is an inexact number in the implementations and
          (eqv? x (string-&gt;number &quot;1.0&quot;)) }

That is a fact about Jaffer's mind and about mathematics, but
says nothing about the implementation.  Jaffer would have done
better to show that the inexact numbers are partitioned by the
classes defined in this way, substituting various strings for
&quot;1.0&quot;---that at least would have said something about the
implementation---but he did not do so.

&gt; {d} for any inexact number x:
&gt; 
&gt;     (= x #i1.0) if-and-only-if (zero? (- x #i1.0))

The R5RS does not actually require this, but I suspect it is true
of most inexact numbers in most implementations.

&gt; Because the implementation has a finite number (&gt; 1) of distinct
&gt; (under `=') inexact numbers classes {a},

Jaffer has not shown this, but I think he means that there are
only a finite number of distinct classes that can be formed by
substituting a string for s in

    { x | x is an inexact number and (= x (string-&gt;number s)) }

The R5RS does not require this, and implementations in which it
is not true are conceivable, but it is true in most systems.

We have to wade through a lot of definitions before we reach the
next non sequitur:

&gt; Consider the mathematical sequence indexed by positive integer k:
&gt; 
&gt;   E[k] = 1 + (-1/10)^k                                          {e}
&gt; 
&gt;   0.9, 1.01, 0.999, 1.0001, 0.99999, 1.000001, ...
&gt; 
&gt; E[k+2] is strictly between E[k] and E[k+1] {e}.                 {f}
&gt; 
&gt; The limit of E[k] as k tends to infinity is 1 {e}.              {g}
&gt; 
&gt; Let S[k] be the string containing a decimal representation of
&gt; E[k].  That sequence begins:                                    {h}
&gt; 
&gt;   &quot;0.9&quot;, &quot;1.01&quot;, &quot;0.999&quot;, &quot;1.0001&quot;, &quot;0.99999&quot;, &quot;1.000001&quot;, ...
&gt; 
&gt; Let I[k] be (STRING-&gt;NUMBER S[k]) {c,h}.                        {i}
&gt; 
&gt; Because the implementation has a finite number (&gt; 1) of distinct
&gt; (under `=') inexact numbers classes {a}, the lower bound, L[1],
&gt; of the distance between #i1.0 and members of any other inexact
&gt; number class must be a nonzero {a,d}.                           {j}
&gt; 
&gt; Thus there must exist an integer j such that (abs (- E[k] 1))
&gt; is less than L[1]/4 for all k &gt; j {f,g,i,j}.                    {k}
&gt; 
&gt; I[k] must be #i1.0 for k &gt; j, because no other inexact number
&gt; class can be closer {c,j}; and because STRING-&gt;NUMBER of the
&gt; string representation of the limiting value, &quot;1.0&quot;, is #i1.0
&gt; {b,g,k}.                                                        {l}

That last paragraph does not follow.  Nothing in the R5RS rules
out an implementation in which both of the following are true:

  *  for all odd k, (eqv? (string-&gt;number S[k]) .9)
  *  for all even k, (eqv? (string-&gt;number S[k]) 1.1)

&gt; Thus the projection of mathematical numbers between E[j] and
&gt; E[j+1] into inexact number classes is #i1.0.

Even if Jaffer's reasoning were not flawed, all he would have
proved is that he can use #i1.0 as a name for

  { x | x is an inexact number and (= x (string-&gt;number &quot;#i1.0&quot;)) }

Note, however, that Jaffer has not proved that this class is
an open neighborhood of 1.0 in any sense.  In particular, he
has not proved the following claim:

&gt; Note that the neighborhood between E[j] and E[j+1] is a subset
&gt; of the full neighborhood which STRING-&gt;NUMBER maps to inexact
&gt; number class #i1.0.

Finally, Jaffer writes:

&gt; There was nothing special about #i1.0 in this proof.

Indeed.  With any other inexact number, Jaffer's alleged proof
would have been just as invalid.

Will

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00166.html">Re: inexactness vs. exactness</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00168.html">Re: inexactness vs. exactness</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00173.html">Re: inexactness vs. exactness</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00168.html">Re: inexactness vs. exactness</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00167"><strong>Date</strong></a></li>
<li><a href="threads.html#00167"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
