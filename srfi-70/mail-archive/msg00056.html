<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: My suggestions to the R6RS committee about numerics -->
<!--X-From-R13: Penqyrl Zhpvre <yhpvreNzngu.cheqhr.rqh> -->
<!--X-Date: Thu,  2 Jun 2005 20:46:48 +0200 (DFT) -->
<!--X-Message-Id: 59e11ddd35df817415f5246b6cfd441d@math.purdue.edu -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: y9ly8acfewc.fsf@sams.informatik.uni&#45;tuebingen.de -->
<!--X-Reference: Pine.LNX.4.58.0506020833510.19932@bolt.sonic.net -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: My suggestions to the R6RS committee about numerics</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00055.html">Date Prev</a>][<a href="msg00057.html">Date Next</a>][<a href="msg00054.html">Thread Prev</a>][<a href="msg00059.html">Thread Next</a>][<a href="maillist.html#00056">Date Index</a>][<a href="threads.html#00056">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: My suggestions to the R6RS committee about numerics</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-70">SRFI 70</a> from before July 7th, 2015.  The new archives for SRFI 70 are <a href="http://srfi-email.schemers.org/srfi-70/">here</a>.  The new archives contain all messages, not just those from before July 7th, 2015.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: bear &lt;<a href="mailto:bear@DOMAIN.HIDDEN">bear@xxxxxxxxx</a>&gt;</li>
<li><em>Subject</em>: Re: My suggestions to the R6RS committee about numerics</li>
<li><em>From</em>: Bradley Lucier &lt;<a href="mailto:lucier@DOMAIN.HIDDEN">lucier@xxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Thu, 2 Jun 2005 14:46:26 -0400</li>
<li><em>Cc</em>: Bradley Lucier &lt;<a href="mailto:lucier@DOMAIN.HIDDEN">lucier@xxxxxxxxxxxxxxx</a>&gt;,	<a href="mailto:srfi-70@DOMAIN.HIDDEN">srfi-70@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-70@DOMAIN.HIDDEN">srfi-70@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:Pine.LNX.4.58.0506020833510.19932@DOMAIN.HIDDEN">Pine.LNX.4.58.0506020833510.19932@xxxxxxxxxxxxxx</a>&gt;</li>
<li><em>References</em>: &lt;<a href="mailto:y9ly8acfewc.fsf@DOMAIN.HIDDEN">y9ly8acfewc.fsf@xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:Pine.LNX.4.58.0506020833510.19932@DOMAIN.HIDDEN">Pine.LNX.4.58.0506020833510.19932@xxxxxxxxxxxxxx</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre style="margin: 0em;">

On Jun 2, 2005, at 12:25 PM, bear wrote:

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">


On Wed, 18 May 2005, Bradley Lucier wrote:

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
The first part deals with IEEE 754/854 arithmetic.
If you don't support this arithmetic, then things are still up in the
air.
</pre></blockquote><pre style="margin: 0em;">

I should not like to see conforming implementations restricted
to exactly this representation and no other; It's nice to be
able to use real numbers of specified precision for some tasks
where the 500th bit of the mantissa actually matters.
</pre></blockquote><pre style="margin: 0em;">

</pre><tt>I see I wrote this poorly.  I mean that I am not able to imagine all 
</tt><tt>possible inexact arithmetics, so I want to specify precisely how Scheme 
</tt><tt>behaves on what I do know, which is IEEE 754 (and I suppose 854, but I 
</tt><tt>don't know anyone who uses it).
</tt><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
6.1 Equivalence predicates
</pre></blockquote><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
The eqv? procedure returns #t if:

*  obj1 and obj2 are both IEEE 754/854 format numbers, and obj1 and
obj2 have
the same base, sign, number of exponent digits, exponent bias, biased
exponent,
number of significand digits, and significand.

*  obj1 and obj2 are both exact numbers and are numerically equal
(see =, section 6.2).

The eqv? procedure returns #f if:

*  one of obj1 and obj2 is an exact number but the other is an
inexact number.

*  obj1 and obj2 are both IEEE 754/854 format numbers, and the base,
sign,
number of exponent digits, exponent bias, biased exponent, number of
significand
digits, or significand of obj1 and obj2 differ.

</pre><tt>*  obj1 and obj2 are exact numbers for which the = procedure returns 
</tt><tt>#f.
</tt></blockquote><pre style="margin: 0em;">


I believe that it is also necessary to specify that if one or
more of the arguments is NaN, eqv? returns false.  It is not at
all uncommon for NaN to have a single bit pattern, and thus if
compared under the above definition, a call where two arguments
were both NaN would return #t, which is a mistake in arithmetic.
</pre></blockquote><pre style="margin: 0em;">

</pre><tt>I disagree that this is a mistake in arithmetic.  If two NaNs have the 
</tt><tt>same bit pattern then they may are &quot;substitutable&quot;, in that they should 
</tt><tt>give the same result when put into any function.  This is the case in 
</tt><tt>Common Lisp, for example, where two NaNs with the same bit pattern are 
</tt><tt>EQL.
</tt><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
It is not ideal IMO to declare it an error to pass NaN to eqv?,
since that limits the composition of expressions.

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
Note: This section does not state under which conditions eqv? returns
#t or #f
for inexact numbers that are not in IEEE 754/854 format.  We
recommend that
numbers not in IEEE 754/854 format for which a base, sign, number of
exponent
digits, exponent bias, biased exponent, number of significand digits,
and
significand can be defined follow the same rules as above.
</pre></blockquote><pre style="margin: 0em;">


I would require rather than recommend this property;
</pre></blockquote><pre style="margin: 0em;">

</pre><tt>Unfortunately, this statement contradicts your previous one about eqv? 
</tt><tt>returning #f if one of the arguments is a NaN.
</tt><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
 what I'd
*recommend* is for you, in the future, to practice line
wrapping at an earlier column.  :-)
</pre></blockquote><pre style="margin: 0em;">

</pre><tt>I'm not hard-wrapping lines at all; it appears that two different mail 
</tt><tt>processors between me and you have a difference of opinion on how lines 
</tt><tt>should be wrapped.
</tt><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
6.2.5. Numerical operations

(number? obj )                           procedure
(complex? obj )                          procedure
(real? obj )                             procedure
(rational? obj )                         procedure
(integer? obj )                          procedure

These numerical type predicates can be applied to any kind
of argument, including non-numbers. They return #t if the
object is of the named type, and otherwise they return #f.
In general, if a type predicate is true of a number then
all higher type predicates are also true of that number.
Consequently, if a type predicate is false of a number, then
all lower type predicates are also false of that number.
</pre></blockquote><pre style="margin: 0em;">


</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
&lt;delete this&gt;
If z is an inexact complex number, then (real? z) is true
if and only if (zero? (imag-part z)) is true. If x is an
inexact real number, then (integer? x) is true if and only
if (= x (round x)).
&lt;add this&gt;
</pre><tt>If an implementation uses IEEE 754/854 format for inexact numbers 
</tt><tt>then:
</tt><pre style="margin: 0em;">
*  If z is an inexact complex number, then (real? z) is true if and
</pre><tt>only if both (exact? (imag-part z)) and (zero? (imag-part z)) are 
</tt><tt>true.
</tt><pre style="margin: 0em;">
*  If z is an inexact real number, then (rational? z) is true if and
only
if z is not positive or negative infinity or a not-a-number.
</pre></blockquote><pre style="margin: 0em;">

Note:  IEEE 754/854 gives no way to represent complex numbers.

You will have to use more precise language to say what you mean,
</pre></blockquote><pre style="margin: 0em;">

</pre><tt>How can I be more precise?  I use &quot;if and only if&quot; and define real? in 
</tt><tt>terms of exact?, zero?, and imag-part.
</tt><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
which is, I suspect, uses 754/854 to represent the real and
imaginary parts of the (cartesian) complex number, or uses
IEEE 754/854 to represent the magnitude and angle of the (polar)
complex number.

But once again, I don't think we need to specify this particular
format, nor to relax all restrictions if a different format is
used; In my opinion, the field widths for the mantissa and
biased exponent are irrelevant to the requirement.
</pre></blockquote><pre style="margin: 0em;">

</pre><tt>I don't believe I'm specifying a format; exact?, zero? and imag-part 
</tt><tt>are defined no matter what the internal format of complex numbers.
</tt><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">

In particular, be careful not to assume that all complex numbers
are internally represented in the same way; several implementations,
I believe, use both polar and cartesian representations internally.

Finally, from a mathematical point of view, a number is either
inexact or exact; this includes complex numbers.  A few
implementations allow differing exactness in the real and
imaginary parts of a complex number.  This is a fact, but the
fact lies at some intermediate position between being a mere
artifact of the representation and a mathematical error.
Consult a number theorist to understand more fully the nature
of this error; it is beyond my feeble ability to explicate.

It is not sensible to speak of an inexact complex number whose
imaginary part is exact,
</pre></blockquote><pre style="margin: 0em;">

I believe that we should have

(exact? (imag-part 1.0)) =&gt; #t

</pre><tt>and (complex? 1.0) is obviously true, and (inexact? 1.0) is true, so 
</tt><tt>your statement makes no sense to me.
</tt><pre style="margin: 0em;">

Furthermore,

(* 1.0 +1i)

</pre><tt>exactly rotates 1.0 in the complex plane by 90 degrees, so one knows 
</tt><tt>that its real part is exact 0.
</tt><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
 and if you require an implementation
that allows it to be, there will be a certain amount of wailing
and gnashing of teeth from mathematicians and number theorists,
who are currently some of scheme's most dedicated and thankful
users.
</pre></blockquote><pre style="margin: 0em;">

</pre><tt>I disagree.  I'm a mathematician and I'm not wailing or gnashing my 
</tt><tt>teeth.
</tt><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
&lt;add this&gt;
(real? -2.5+0.0i) =) undetermined
(real? -2.5+0.0i) =) #f  if IEEE 754/854 arithmetic is used.
&lt;end of addition&gt;
</pre></blockquote><pre style="margin: 0em;">

Nope, sorry, this just doesn't work.
</pre></blockquote><pre style="margin: 0em;">

I think it does.  You'll need more here than proof by proclamation.

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
&lt;Add the following&gt;

For implementations that allow (real z) and (imag z) to have different
exactness, then (exact? z) returns #t if and only if both (exact?
(real z))
and (exact? (imag z)) return #t.

&lt;end of addition&gt;
</pre></blockquote><pre style="margin: 0em;">

Once again, this proceeds from a delusory belief that one number,
as a result of its mere representation, can have two different
exactnesses simultaneously.  This will not fly.
</pre></blockquote><pre style="margin: 0em;">

</pre><tt>If z is a complex number then precisely one of (exact? z) and (inexact? 
</tt><tt>z) is true, not both, and not neither.  A number does not have two 
</tt><tt>different &quot;exactnesses&quot; simultaneously under my definition.
</tt><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
&lt;Change the comparison predicates to the following&gt;
</pre></blockquote><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
(= z1 : : : ) procedure
(&lt; x1 : : : ) procedure
(&gt; x1 : : : ) procedure
(&lt;= x1 : : : ) procedure
(&gt;= x1 : : : ) procedure
</pre></blockquote><pre style="margin: 0em;">
&lt;clip&gt;
</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
Note: If an implementation uses IEEE 754/854 format for its inexact
numbers, then these procedures shall return #f if called with two or
more arguments when one of the arguments is a NaN.
</pre></blockquote><pre style="margin: 0em;">

&quot;one of&quot; should be changed to &quot;one or more of&quot; -- this does
not change meaning, but adds clarity.  And I think this should
be true of NaN's always, no matter how numbers are represented.
</pre></blockquote><pre style="margin: 0em;">

The principle I'm working on here is that if

(proc x)

</pre><tt>returns #t for any real finite or infinite x, then it should return #t 
</tt><tt>for NaN.  We have
</tt><pre style="margin: 0em;">

(= x) =&gt; #t

</pre><tt>for all real finite or infinite x, so this should also be true if x is 
</tt><tt>NaN.  Similarly for the other predicates.
</tt><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">


</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
&lt;change the following predicates&gt;
</pre></blockquote><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
(zero? z) library procedure
(positive? x) library procedure
(negative? x) library procedure
(odd? n) library procedure
(even? n) library procedure
</pre></blockquote><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
These numerical predicates test a number for a particular
property, returning #t or #f.
</pre></blockquote><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
If an implementation uses IEEE 754/854 format for its inexact
numbers, then zero?, positive?, and negative? return #f if called with
a NaN argument.
</pre></blockquote><pre style="margin: 0em;">

I would go further and say *all* of these procedures should return
#f if called with a NaN argument, regardless of how numbers or NaNs
are represented.
</pre></blockquote><pre style="margin: 0em;">

NaNs are not integers, so they cannot be arguments to odd? and even?.

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
&lt;change the following procedures&gt;
</pre></blockquote><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
(max x1 x2 : : : ) library procedure
(min x1 x2 : : : ) library procedure
</pre></blockquote><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
These procedures return the maximum or minimum of their
arguments.
</pre></blockquote><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
(max 3 4) =) 4 ; exact
(max 3.9 4) =) 4.0 ; inexact
</pre></blockquote><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
If an implementation uses IEEE 754/854 format for its inexact
numbers, and any of the arguments to max and min are NaNs, then
max and min returns one of the NaN arguments as its result.
</pre></blockquote><pre style="margin: 0em;">

use &quot;a&quot; rather than &quot;one of the&quot;, unless there is some
significance to the eq?-ness of the NaN returned with
one of its arguments.  And say simply &quot;NaNs&quot; if there is
not some significance to representing them in a particular
IEEE format.
</pre></blockquote><pre style="margin: 0em;">

</pre><tt>Ah, so I should say &quot;If the inexact format has NaNs then ...&quot; rather 
</tt><tt>then mentioning IEEE 754 explicitly?  Or perhaps I will have to say &quot;If 
</tt><tt>the inexact format has NaNs that behave the same as NaNs in IEEE 
</tt><tt>754/854 arithmetic then ...&quot;, but the latter seems to be rather 
</tt><tt>verbose.
</tt><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><tt>&lt;change floor, ceiling, truncate, and round to take rational 
</tt><tt>arguments,
</tt><pre style="margin: 0em;">
not real arguments&gt;
</pre></blockquote><pre style="margin: 0em;">

I do not agree with you that these procedures ought not take real
arguments. Instead, they should return inexact numbers when given
inexact numbers and NaN when given NaN.
</pre></blockquote><pre style="margin: 0em;">

</pre><tt>In my classification of numbers, the infinities and NaN cannot be 
</tt><tt>integers, there is no &quot;nearest integer&quot; to these objects, either above 
</tt><tt>or below them.  Can you describe a use for
</tt><pre style="margin: 0em;">

(trunc +inf.0) =&gt; ???

or something similar?

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
&lt;change rationalize to take rational arguments, not real arguments&gt;
</pre></blockquote><pre style="margin: 0em;">

This does not make sense.  If you have rational arguments to start
with, what are you using rationalize for?
</pre></blockquote><pre style="margin: 0em;">

To find a &quot;simpler&quot; rational approximation to the argument.

</pre><tt>I agree, this needs to be fixed.  I should have said that the 
</tt><tt>infinities and NaNs are not valid arguments to rationalize.  If a 
</tt><tt>system wants to have numbers like (sqrt 2), then they should be allowed 
</tt><tt>as arguments to rationalize, too.
</tt><pre style="margin: 0em;">

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00059" href="msg00059.html">Re: My suggestions to the R6RS committee about numerics</a></strong>
<ul><li><em>From:</em> bear</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00001" href="msg00001.html">My suggestions to the R6RS committee about numerics</a></strong>
<ul><li><em>From:</em> Bradley Lucier</li></ul></li>
<li><strong><a name="00054" href="msg00054.html">Re: My suggestions to the R6RS committee about numerics</a></strong>
<ul><li><em>From:</em> bear</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00055.html">Re: Two specific suggestions.</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00057.html">string-&gt;number</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00054.html">Re: My suggestions to the R6RS committee about numerics</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00059.html">Re: My suggestions to the R6RS committee about numerics</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00056"><strong>Date</strong></a></li>
<li><a href="threads.html#00056"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
