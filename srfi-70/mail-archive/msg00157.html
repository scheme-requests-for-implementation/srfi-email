<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: inexactness vs. exactness -->
<!--X-From-R13: Bnhy Epuyvr <fpuyvrNpbzpnfg.arg> -->
<!--X-Date: Sun, 24 Jul 2005 18:43:06 +0200 (DFT) -->
<!--X-Message-Id: BF093D4A.AF4D%schlie@comcast.net -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 5fb7e0870507240705438a6915@mail.gmail.com -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: inexactness vs. exactness</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00156.html">Date Prev</a>][<a href="msg00158.html">Date Next</a>][<a href="msg00156.html">Thread Prev</a>][<a href="msg00159.html">Thread Next</a>][<a href="maillist.html#00157">Date Index</a>][<a href="threads.html#00157">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: inexactness vs. exactness</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-70">SRFI 70</a> from before July 7th, 2015.  The new archives for SRFI 70 are <a href="http://srfi-email.schemers.org/srfi-70/">here</a>.  Eventually, the entire history will be moved there, including any new messages.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: Alex Shinn &lt;<a href="mailto:alexshinn@DOMAIN.HIDDEN">alexshinn@xxxxxxxxx</a>&gt;,	William D Clinger &lt;<a href="mailto:will@DOMAIN.HIDDEN">will@xxxxxxxxxxx</a>&gt;</li>
<li><em>Subject</em>: Re: inexactness vs. exactness</li>
<li><em>From</em>: Paul Schlie &lt;<a href="mailto:schlie@DOMAIN.HIDDEN">schlie@xxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Sun, 24 Jul 2005 12:42:50 -0400</li>
<li><em>Cc</em>: &lt;<a href="mailto:srfi-70@DOMAIN.HIDDEN">srfi-70@xxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-70@DOMAIN.HIDDEN">srfi-70@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:5fb7e0870507240705438a6915@DOMAIN.HIDDEN">5fb7e0870507240705438a6915@xxxxxxxxxxxxxx</a>&gt;</li>
<li><em>User-agent</em>: Microsoft-Entourage/11.1.0.040913</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>&gt; From: Alex Shinn &lt;alexshinn@xxxxxxxxx&gt;
&gt;&gt; William D Clinger &lt;will@xxxxxxxxxxx&gt; wrote:
&gt;&gt; Suppose (for a contradiction) that inexact numbers do denote
&gt;&gt; neighborhoods.  Then let [x, y] be the neighborhood denoted
&gt;&gt; by the inexact number 1.0.  If 0 &lt; x &lt;= y, then the inexact
&gt;&gt; number (* 1.0 1.0) denotes [x*x, y*y].  If (* 1.0 1.0)
&gt;&gt; evaluates to 1.0, then 1.0 denotes both [x, y] and [x*x, y*y],
&gt;&gt; hence x = x*x and y = y*y.  Therefore x = 1.0 = y, so under
&gt;&gt; our assumptions, the inexact number 1.0 really denotes only
&gt;&gt; itself.
&gt; 
&gt; Does it even make sense to make this kind of comparison?  It
&gt; seems you're knocking down the straw man that is limited precision
&gt; floating point.  One can demonstrate all kinds of contradictions if
&gt; you compare computer math with real math, regardless of what
&gt; theoretical basis you're using.
&gt; 
&gt; If you take the idea that inexacts represent single real values,
&gt; then all equations have to be qualified with &quot;so long as the values
&gt; and intermediate results remain within the precision the system
&gt; provides.&quot;
&gt; 
&gt; If instead you assume that inexacts represent ranges, then the
&gt; qualification instead becomes &quot;all values within the range are
&gt; indistinguishable.&quot;  In the above contradiction, x and y when
&gt; represented on the computer are indistinguishable from 1.0,
&gt; so without any steps at all you can conclude x = y = 1.0.
&gt; This goes for any real number, not just 1.0.
&gt; 
&gt; As the introduction to numbers in R5RS states
&gt; 
&gt;     It is important to distinguish between the mathematical numbers,
&gt;     the Scheme numbers that attempt to model them, the machine
&gt;     representations used to implement the Scheme numbers, and
&gt;     notations used to write numbers.
&gt; 
&gt; Perhaps it is best to leave it this way and let individual people
&gt; (and implementations) apply interpretations to those numbers
&gt; as suits them.

Given that in practice both exact and inexact values are presumed to
represent finite values to some likely bounded practical precision;
might it be reasonable to roughly define that all numerical values
may be considered &quot;abstractly infinitely precise&quot; values &quot;rounded&quot; to
the precision defined by their respective implementations, (where it
is presumed that retained precision of exact values will be at-least
as precise as inexact values, and ideally have the equivalent bounds
on their representable magnitudes, so that +- inf may represent the
bounds of either representation equivalently).

Thereby in effect, abstractly:

 &lt;exact-value&gt; :: (precise-&gt;exact &lt;some-value&gt;)

 &lt;inexact-value&gt; :: (precise-&gt;inexact &lt;some-value&gt;)

and correspondingly:

 (&lt;function&gt; &lt;some-value&gt;) =&gt; &lt;exact-value&gt; ::
 (precise-&gt;exact (&lt;precise-function&gt; &lt;some-value&gt;)) =&gt; &lt;exact-value&gt;

 (&lt;function&gt; &lt;some-value&gt;) =&gt; &lt;inexact-value&gt; ::
 (precise-&gt;inexact (&lt;precise-function&gt; &lt;some-value&gt;)) =&gt; &lt;inexact-value&gt;

thereby again abstractly:

 (&lt;= (- &lt;some-value&gt; (exact-interval-precision- &lt;some-value&gt;))
     &lt;some-value&gt;
     (+ &lt;some-value&gt; (exact-interval-precision+ &lt;some-value&gt;)))
  =&gt; #t

where the exact-interval-precision for any value at or beyond an
implementation's magnitude bounds is itself infinite, thereby all
abstractly precise values of greater magnitude are considered
equivalent regardless if represented as exact or inexact values.

  exact:     #e-1/0  ..    #e-0/1 0 #e+0/1   ..  #e+1/0
                |||||||||||||||||||||||||||||||||||||
precise: -1/0        ..      -0/1 0 +0/1     ..        +1/0
                |  |  |  |  |  |  |  |  |  |  |  |  |
inexact:     #i-1/0  ..    #i-0/1 0 #i+0/1   ..  #i+1/0

(where I understand that the notion of an exact value being
 potentially imprecise is a bit of a paradox, but personally
 I'd rather be able to define PI for example to a potentially
 much greater, albeit finite, precision of an exact, than be
 limited to defining it's value at the precision of an inexact
 floating point representation for example.)



</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00159" href="msg00159.html">Re: inexactness vs. exactness</a></strong>
<ul><li><em>From:</em> Alan Watson</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00156" href="msg00156.html">Re: inexactness vs. exactness</a></strong>
<ul><li><em>From:</em> Alex Shinn</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00156.html">Re: inexactness vs. exactness</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00158.html">Re: inexactness vs. exactness</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00156.html">Re: inexactness vs. exactness</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00159.html">Re: inexactness vs. exactness</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00157"><strong>Date</strong></a></li>
<li><a href="threads.html#00157"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
