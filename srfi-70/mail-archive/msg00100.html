<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: comparison operators and *typos -->
<!--X-From-R13: Bnhy Epuyvr <fpuyvrNpbzpnfg.arg> -->
<!--X-Date: Mon,  4 Jul 2005 19:49:43 +0200 (DFT) -->
<!--X-Message-Id: BEEEEEE5.AB71%schlie@comcast.net -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20050703184239.18E2F1B77B4@voluntocracy.org -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: comparison operators and *typos</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00099.html">Date Prev</a>][<a href="msg00101.html">Date Next</a>][<a href="msg00098.html">Thread Prev</a>][<a href="msg00103.html">Thread Next</a>][<a href="maillist.html#00100">Date Index</a>][<a href="threads.html#00100">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: comparison operators and *typos</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-70">SRFI 70</a> from before July 7th, 2015.  The new archives for SRFI 70 are <a href="http://srfi-email.schemers.org/srfi-70/">here</a>.  The new archives contain all messages, not just those from before July 7th, 2015.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: Aubrey Jaffer &lt;<a href="mailto:agj@DOMAIN.HIDDEN">agj@xxxxxxxxxxxx</a>&gt;</li>
<li><em>Subject</em>: Re: comparison operators and *typos</li>
<li><em>From</em>: Paul Schlie &lt;<a href="mailto:schlie@DOMAIN.HIDDEN">schlie@xxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Mon, 04 Jul 2005 13:49:25 -0400</li>
<li><em>Cc</em>: &lt;<a href="mailto:srfi-70@DOMAIN.HIDDEN">srfi-70@xxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-70@DOMAIN.HIDDEN">srfi-70@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:20050703184239.18E2F1B77B4@DOMAIN.HIDDEN">20050703184239.18E2F1B77B4@xxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>User-agent</em>: Microsoft-Entourage/11.1.0.040913</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>&gt;  | From: Paul Schlie &lt;schlie@xxxxxxxxxxx&gt;
&gt;  | 
&gt;  | ... it seems both reasonable and useful to define:
&gt;  | 
&gt;  |   (= -0.0 0 0.0) =&gt; #t
&gt;  |   
&gt;  |   thereby zero's are considered to compare equal, enabling (= 0 any-zero)
&gt;  | 
&gt;  |   (&lt; -0.0 0.0) =&gt; #t
&gt;  |   (&gt; 0.0 -0.0) =&gt; #t
&gt; 
&gt; Mathematically, `=', `&lt;', and `&gt;' are mutually exclusive.  So -0.0
&gt; cannot simultaneously be `=' and `&lt;' 0.0.

- why not? as it seems useful; any practical example to the contrary?

&gt;  |   thereby only regions which do not overlap compare &lt; or &gt;
&gt; 
&gt; So what is returned by comparisons of overlapped regions?

- for ordered comparisons excluding equivalence, they return false.

&gt;  |   (&lt;= -0.0 0 0.0) =&gt; #t
&gt;  |   (&gt;= 0.0 0 -0.0) =&gt; #t
&gt;  | 
&gt;  |   thereby only 0 is (and (&lt;= x 0.0) (&gt;= x -0.0))
&gt; 
&gt; That could only be true if 0 is not within any inexact neighborhood.
&gt; It would then be the only real number for which EXACT-&gt;INEXACT fails
&gt; to return a value.
&gt; 
&gt; Because (= -0.0 0.0), x can also be 0.0; and (&lt;= 0.0 -0.0) should also
&gt; return true.  We have thus reached a situation where -0.0 and 0.0 are
&gt; indistinguishable.

- thereby as noted only:  -0.0 is (and (= x 0) (&lt; x 0))
  and correspondingly only 0.0 is (and (= x 0) (&gt; x 0))

&gt;  | &gt; | &gt;   (tan 1.5707963267948965) ==&gt; 16.331778728383844e15
&gt;  | &gt; | &gt;   (tan 1.5707963267948967) ==&gt; -6.218352966023783e15
&gt;  | &gt; TAN not reaching #i+/0 is a simple matter of the mantissa not having
&gt;  | &gt; enough resolution around 1.5708.  With an 11.bit exponent, over
&gt;  | &gt; 1024.bit precision would be needed for a floating point number to have
&gt;  | &gt; an infinite TANgent.
&gt;  | 
&gt;  | - are you saying that since pi/2 can't be represented with sufficient
&gt;  |   precision to yield:
&gt;  | 
&gt;  |   (tan (+ pi/2 0.0)) -&gt; inf.0, or (tan (- pi/2 0.0)) =&gt; -inf.0
&gt;  | 
&gt;  |   that they shouldn't be formally defined to be so?
&gt; 
&gt; No amount of precision will make (+ pi/2 0.0) return a different
&gt; number from (- pi/2 0.0).

- (tan (+ pi/2 0.0)) will be negative and technically infinite.

  (tan (- pi/2 0.0)) will be positive and technically infinite.

  therefore the difference between the two values is technically infinite?
  (which seems like a pretty big difference to me?)

&gt;  |   which I'd disagree with, as although I accept that a particular
&gt;  |   implementation may not have sufficient precision to exceed the
&gt;  |   dynamic range of the representation, therefore may only yield
&gt;  |   smaller values; I don't believe it's correct to define (tan pi/2)
&gt;  |   as being anything other than &lt;+|-&gt;inf.0 (aka ~inf.0, or e~/0).
&gt; 
&gt; Mathematically, tan(pi/2) is undefined.

- unless one can define a value which can consistently represent both
  positive and negative infinity, such as ~inf.0 (aka e~/0)

&gt;  | &gt;  | &gt; Note that the one-sided LIMIT gets it right without needing
&gt;  | &gt;  | &gt; any new numbers:
&gt;  | &gt;  | &gt; 
&gt;  | &gt;  | &gt;   (limit tan 1.5707963267948965 -1.0e-15)       ==&gt; +1/0
&gt;  | &gt;  | &gt;   (limit tan 1.5707963267948965 1.0e-15)        ==&gt; -1/0
&gt;  | &gt;  | 
&gt;  | &gt;  | - yes, which is why the simultaneous two sided limit == +-1/0 == ~1/0
&gt;  | &gt; 
&gt;  | &gt; By the definition, the two-sided limit of tan at pi/2 does not exist
&gt;  | &gt; because the one-sided limits are not equal.
&gt;  | 
&gt;  | - really, I was under the impression that they were?
&gt; 
&gt; Look it up: &lt;<a  rel="nofollow" href="http://en.wikipedia.org/wiki/Limit_of_a_function">http://en.wikipedia.org/wiki/Limit_of_a_function</a>&gt;

- yes, and correspondingly:
  
<a  rel="nofollow" href="http://en.wikipedia.org/wiki/How_to_evaluate_the_limit_of_a_real-valued_func">http://en.wikipedia.org/wiki/How_to_evaluate_the_limit_of_a_real-valued_func</a>
tion

  particularly: &quot;Limits do not always exist&quot;, in the absents of being able
  to denote a value which has an ambiguous sign, i.e.: ~inf.0, ~1.0, etc.
 
  and: &quot;L'H&#xF4;pital's rule, and division by zero&quot;, which then clearly enables
  the definition of (tan x) as (/ (sin x) (cos x)), as x -&gt; pi/2, in
  combination with the above, enabling the precise result of ~inf.0.

&gt;  |   for example if I defined an inexact number system based on binary
&gt;  |   fractions of pi, then it would only require a few bits of
&gt;  |   precision to represent pi/2 exactly, and produce fully symmetric
&gt;  |   results for (tan x) which would be equal to &lt;+|-&gt;inf.0 at pi/2.
&gt; 
&gt; Mathematically, tan(pi/2) is undefined; but the one-sided limits tend
&gt; to positive infinity and negative infinity.  Going to great lengths to
&gt; have pi/2 in your number system so that tan(pi/2) can return an
&gt; infinity with indeterminate sign is computationally useless.
&gt; SRFI-70's #i0/0 is sufficient to represent any indeterminate quantity.
&gt; That there are finer shades of distinction for indeterminates is
&gt; perhaps interesting, but certainly not a necessity for R6RS.

- tan(pi/2) is well understood to be -inf.0 if approached from the left,
  and +inf if approached from the right, therefore correspondingly well
  defined as ~inf.0, if such a value representation were defined. (which
  seems perfectly reasonable as it would be equivalent to the reciprocal
  of the values about absolute 0, who's reciprocal is not +inf.0 as
  incorrectly presumed in many implementations.)

&gt;  | &gt;  |   and (/ 1 #e0) == (/ 1 (+ #e0 ~0.0)) == #i~1/0 == ~inf.0
&gt;  | &gt; 
&gt;  | &gt; Knowing that the value of an expression could be positive infinity or
&gt;  | &gt; negative infinity is much less useful than knowing which infinity it
&gt;  | &gt; is.
&gt;  | 
&gt;  | - agreed, but without being able to determine the sign of a zero,
&gt;  | which I agree is often not important, you can't determine the sign
&gt;  | of it's reciprocal which is an infinity, (so the problem is fully
&gt;  | symmetric, if signs of infinities are likely important, then so are
&gt;  | the signs of zeros it would seem.)
&gt; 
&gt; Inexact numbers are approximate.  Most calculations returning inexact
&gt; numbers lose information.  Which side the zero, pi, or other number
&gt; was approached from is one of the casualties of approximate computing.

- producing a sign about any value seems egregious, as it represents an
  instantaneous loss of indefinite precision; even about 0, as it's
  reciprocal would be then potentially be absolutely incorrect.

&gt; One must be careful with numerical properties.  If I understand your
&gt; system, adding -0.0 to 0.0 returns -0.0.

- no, I'd likely define that (+ -0.0 0.0) =&gt; ~0.0; as 0.0 == +0.0,

  thereby: (+ -0.0 +0.0) ::
  (+ (+ -0.0 ~0.0) (+ +0.0 ~0.)) ::
  (+ [(+ -0.0 +0.0) or (+ -0.0 -0.0)] [(+ +0.0 +0.0)or (+ +0.0 -0.0)]) ::
  (+ [-0.0 or 0] [+0.0 or 0]) ::
  [(+ -0.0 +0.0) or (+ -0.0 0) or (+ 0 +0.0) or (+ 0 0)] ::
  [[self] or -0.0 or +0.0 or 0] =&gt; ~0.0

&gt;                                         But that -0.0 may have been
&gt; generated by (* -5 0.0) while the 0.0 was the result of (/ #i+1/0).
&gt; Taking the reciprocal of the resulting -0.0 will be the wrong
&gt; infinity.  Just because an attribute is there, doesn't mean it is
&gt; reliable.

- no as: (+ (* -5 0.0) (/ #i+1/0)) :: (+ -0.0 +0.0) =&gt; ~0.0
 
&gt; (/ (+ (* -5 0.0) (/ #i+1/0)))

  :: (/ ~0.0) =&gt; ~inf.0

  [thereby although the absolute sign has been lost, it's correctly
  attributed as being ambiguous, thereby any subsequent uses of it's
  value will have a corresponding ambiguity]

  :: (/ -0.0 (/ +inf.0)) :: (/ -0.0 +0.0) =&gt; ~0.0



</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00103" href="msg00103.html">Re: comparison operators and *typos</a></strong>
<ul><li><em>From:</em> Aubrey Jaffer</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00098" href="msg00098.html">Re: comparison operators and *typos</a></strong>
<ul><li><em>From:</em> Aubrey Jaffer</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00099.html">infinity notations</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00101.html">Re: infinity notations</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00098.html">Re: comparison operators and *typos</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00103.html">Re: comparison operators and *typos</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00100"><strong>Date</strong></a></li>
<li><a href="threads.html#00100"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
