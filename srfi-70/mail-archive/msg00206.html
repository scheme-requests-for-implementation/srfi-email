<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: inexactness vs. exactness -->
<!--X-From-R13: Bnhy Epuyvr <fpuyvrNpbzpnfg.arg> -->
<!--X-Date: Tue,  9 Aug 2005 19:21:54 +0200 (DFT) -->
<!--X-Message-Id: BF1E5E5D.B21B%schlie@comcast.net -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: BF1E5B23.B218%schlie@comcast.net -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: inexactness vs. exactness</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00205.html">Date Prev</a>][<a href="msg00207.html">Date Next</a>][<a href="msg00205.html">Thread Prev</a>][<a href="msg00197.html">Thread Next</a>][<a href="maillist.html#00206">Date Index</a>][<a href="threads.html#00206">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: inexactness vs. exactness</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-70">SRFI 70</a> from before July 7th, 2015.  The <a href="http://srfi-email.schemers.org/srfi-70">new archives</a> for SRFI 70 contain all messages, not just those from before July 7th, 2015.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: bear &lt;<a href="mailto:bear@DOMAIN.HIDDEN">bear@xxxxxxxxx</a>&gt;</li>
<li><em>Subject</em>: Re: inexactness vs. exactness</li>
<li><em>From</em>: Paul Schlie &lt;<a href="mailto:schlie@DOMAIN.HIDDEN">schlie@xxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Tue, 09 Aug 2005 13:21:33 -0400</li>
<li><em>Cc</em>: Aubrey Jaffer &lt;<a href="mailto:agj@DOMAIN.HIDDEN">agj@xxxxxxxxxxxx</a>&gt;, &lt;<a href="mailto:will@DOMAIN.HIDDEN">will@xxxxxxxxxxx</a>&gt;,	&lt;<a href="mailto:srfi-70@DOMAIN.HIDDEN">srfi-70@xxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-70@DOMAIN.HIDDEN">srfi-70@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:BF1E5B23.B218%25schlie@DOMAIN.HIDDEN">BF1E5B23.B218%schlie@xxxxxxxxxxx</a>&gt;</li>
<li><em>User-agent</em>: Microsoft-Entourage/11.1.0.040913</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>(sorry, obviously I can't do arithmetic, as 10^300 =&gt; ~1K bits of precision
implying that an application domain specific library would be required for
public key cryptography beyond this precision, but still seems reasonable
for most very large integer and/or geometric purposes that I can think of?)


&gt; From: Paul Schlie &lt;schlie@xxxxxxxxxxx&gt;
&gt; Date: Tue, 09 Aug 2005 13:07:47 -0400
&gt; To: bear &lt;bear@xxxxxxxxx&gt;
&gt; Cc: Aubrey Jaffer &lt;agj@xxxxxxxxxxxx&gt;, &lt;will@xxxxxxxxxxx&gt;,
&gt; &lt;srfi-70@xxxxxxxxxxxxxxxxx&gt;
&gt; Subject: Re: inexactness vs. exactness
&gt; Resent-From: &lt;srfi-70@xxxxxxxxxxxxxxxxx&gt;
&gt; Resent-Date: Tue,  9 Aug 2005 19:09:43 +0200 (DFT)
&gt; 
&gt;&gt; From: bear &lt;bear@xxxxxxxxx&gt;
&gt;&gt; On Mon, 8 Aug 2005, Paul Schlie wrote:
&gt;&gt; 
&gt;&gt;&gt; Thanks, I guess my point/question was predominantly related to the
&gt;&gt;&gt; observation that there seems often little need for truly &quot;exact&quot;
&gt;&gt;&gt; values beyond theoretical geometry and/or combinatorial mathematics,
&gt;&gt;&gt; which often themselves only require a determinable finite precision;
&gt;&gt; 
&gt;&gt; This is a point on which you're going to lose.  Combinatorial
&gt;&gt; mathematics has developed subfields called cryptography,
&gt;&gt; compression, and correction codes which are fundamental to
&gt;&gt; modern networking.  If you're doing any of those and you
&gt;&gt; round anything off, you lose.
&gt; 
&gt; - no, I've tried to already consider this, but as such algorithms tend to
&gt;   only require (and actually rely on) finite precision modular integer
&gt;   arithmetic, most typically well within the ~3K or so equivalent bits of
&gt;   integer precision what would be required to represent a double's dynamic
&gt;   range of a ~10^300 exactly (even for pubic key algorithms, which tend to
&gt;   be typically be limited in practice to ~2k bits for even very secure key
&gt;   exchanges).
&gt; 
&gt;&gt;&gt; while simultaneously observing there's often broader need for more
&gt;&gt;&gt; precise potentially &quot;inexact&quot; values than typically supported by
&gt;&gt;&gt; double precision floating point implementations; so it just seemed
&gt;&gt;&gt; that in practice that it may be more useful to define that &quot;exact&quot;
&gt;&gt;&gt; values need only be as precise as necessary to support the exact
&gt;&gt;&gt; representation of the integer values bounded by the dynamic range of
&gt;&gt;&gt; the implementation's &quot;inexact&quot; implementation, and their
&gt;&gt;&gt; corresponding reciprocal values in practice (as you've implied);
&gt;&gt; 
&gt;&gt; NACK!  If you have limited precision, and the limited precision
&gt;&gt; affects the answer, then the answer is inexact.  PERIOD.  There is no
&gt;&gt; such thing as &quot;exact numbers limited in precision&quot; to *ANY* limit of
&gt;&gt; precision.  Once you go beyond a limit of precision and round
&gt;&gt; something, you aren't talking about exact numbers anymore.  Exact
&gt;&gt; numbers are, by definition, *infinitely* precise.  You may be talking
&gt;&gt; about limiting the representation size of exact numbers, thereby
&gt;&gt; decreasing the size of the set of exact numbers you can represent; but
&gt;&gt; that's not the same thing.
&gt; 
&gt; - so what, in practice all values beyond the theoretical are based on
&gt;   measured values which are imprecise by definition; therefore in practice
&gt;   I find it hard to believe that there's any truly identifiable value of
&gt;   lossless calculations beyond the precision typically required by lossless
&gt;   cryptography by default (which as required more domain specific library
&gt;   packages can themselves leverage without having to burden the general
&gt;   implementation or programmer with preventing the specification of
&gt;   calculations which may yield irrational values, and/or force the
&gt;   truncation of a result to significantly less precision than may be
&gt;   supported by a inexact implementation?)
&gt; 
&gt;&gt; Infinite precision in finite memory arises when the number happens to
&gt;&gt; match our representational scheme very well; integers and ratios of
&gt;&gt; integers happen to be infinitely precise things we can represent in
&gt;&gt; finite memory - but the finiteness of our memory means that we can
&gt;&gt; only represent an infinitesimal fraction of those in any fixed amount
&gt;&gt; of space. Things work because our usual calculations tend to give us
&gt;&gt; results that are in the set of things we can represent; and when they
&gt;&gt; don't, we can throw an error, if it's last-bit critical, or return an
&gt;&gt; inexact number, if it isn't.
&gt;&gt; 
&gt;&gt;&gt; thereby both providing a likely reasonably efficient &quot;inexact&quot; (aka
&gt;&gt;&gt; double) &gt;and a likely reasonably precise corresponding &quot;exact&quot;
&gt;&gt;&gt; representation,
&gt;&gt; 
&gt;&gt; I will say it again.  Exact numbers aren't &quot;reasonably&quot; precise.  they
&gt;&gt; are *exact*, which is to say &quot;infinitely&quot; precise.  You are arguing
&gt;&gt; for extended-precision inexact numbers, and I agree with you that
&gt;&gt; these are needed and useful - but to call them exact is to confuse the
&gt;&gt; issue and does not help.
&gt; 
&gt; - yes, I know what the definition of the word is, but don't believe it's
&gt;   literally significant beyond some reasonably typically required precision
&gt;   as I've tried to explain above given our cryptography example.
&gt; 
&gt;   As in practice, it seems much more useful to know for example that an
&gt;   inexact value may only be precise to ~50 bits of precision, and
&gt;   hypothetically an exact value may only be precise to ~3000 bits, and both
&gt;   constrained to the same dynamic range, where then with that knowledge, the
&gt;   most appropriate form may be utilized directly, and/or leveraged by more
&gt;   application specific domain libraries as may be required.
&gt; 
&gt; (I know we differ in opinion on this point, but thank you for the
&gt;  opportunity to express it, regardless of our being in agreement.)
&gt; 
&gt; 


</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00205" href="msg00205.html">Re: inexactness vs. exactness</a></strong>
<ul><li><em>From:</em> Paul Schlie</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00205.html">Re: inexactness vs. exactness</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00207.html">Wrapping up SRFI-70</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00205.html">Re: inexactness vs. exactness</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00197.html">Re: inexactness vs. exactness</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00206"><strong>Date</strong></a></li>
<li><a href="threads.html#00206"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
