<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: My ideas about infinity in Scheme (revised) -->
<!--X-From-R13: "Qubatxnv Luh" <zngurzngvpnNpvgvm.arg> -->
<!--X-Date: Mon, 23 May 2005 07:34:58 +0200 (DFT) -->
<!--X-Message-Id: 20050523053421.96DE3139@mx1.informatik.uni&#45;tuebingen.de -->
<!--X-Content-Type: text/plain -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: My ideas about infinity in Scheme (revised)</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00020.html">Date Prev</a>][<a href="msg00022.html">Date Next</a>][<a href="msg00015.html">Thread Prev</a>][<a href="msg00038.html">Thread Next</a>][<a href="maillist.html#00021">Date Index</a>][<a href="threads.html#00021">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: My ideas about infinity in Scheme (revised)</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-70">SRFI 70</a> from before July 7th, 2015.  The <a href="http://srfi-email.schemers.org/srfi-70">new archives</a> for SRFI 70 contain all messages, not just those from before July 7th, 2015.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: &quot;Aubrey Jaffer&quot; &lt;<a href="mailto:agj@DOMAIN.HIDDEN">agj@xxxxxxxxxxxx</a>&gt;</li>
<li><em>Subject</em>: Re: My ideas about infinity in Scheme (revised)</li>
<li><em>From</em>: &quot;Chongkai Zhu&quot; &lt;<a href="mailto:mathematica@DOMAIN.HIDDEN">mathematica@xxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Mon, 23 May 2005 13:33:49 +0800</li>
<li><em>Cc</em>: &quot;srfi-70&quot; &lt;<a href="mailto:srfi-70@DOMAIN.HIDDEN">srfi-70@xxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-70@DOMAIN.HIDDEN">srfi-70@xxxxxxxxxxxxxxxxx</a></li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>  
======= Aubrey Jaffer wrote: =======
&gt; 
&gt;  | Date: Fri, 20 May 2005 10:28:12 +0800
&gt;  | From: &quot;Chongkai Zhu&quot; &lt;mathematica@xxxxxxxxx&gt;
&gt;  | 
&gt;  | I have also considered infinities in Scheme and have some different
&gt;  | ideas:
&gt;  | 
&gt;  | 1. We need both exact (rational) infinity and inexact infinity, that
&gt;  |    is, four special numbers:
&gt;  | 
&gt;  | 1/0 -1/0 +inf.0 -inf.0
&gt;  | 
&gt;  | The first two are rational and thus exact.
&gt; 
&gt; In math texts (<a  rel="nofollow" href="http://en.wikipedia.org/wiki/Rational_numbers">http://en.wikipedia.org/wiki/Rational_numbers</a>):
&gt; 
&gt;  A rational number is a ratio or quotient of two integers, usually
&gt;  written as the vulgar fraction a/b, where b is not zero.
&gt; 
&gt;  | Even if this SRFI won't specify exact infinity, it should not use
&gt;  | the &quot;syntax of numerical constants&quot; 1/0 and -1/0, but +inf.0 and
&gt;  | -inf.0 instead, so that a latter SRFI can use 1/0 and -1/0 as exact
&gt;  | infinity.
&gt; 
&gt; In hundreds of years of using rational numbers, mathematicians have
&gt; not discovered 1/0 to be a useful extension to the rational numbers.
&gt; 
&gt;  | This also keeps the tradition that &quot;x/y&quot; (in which x and
&gt;  | y are both integers) is a rational, and the syntax of an inexact
&gt;  | constant contains a dot.
&gt; 
&gt; 1/0 is very evocative for infinity.  While &quot;finit&quot; is a Latin root,
&gt; &quot;infinit&quot; is a Middle English derivation.  Thus &quot;inf&quot; will be not be
&gt; nearly as evocative for most people.  More than programmers see data
&gt; written by programs.
&gt; 
&gt; How about &quot;1/0.&quot; and &quot;-1/0.&quot;?

Good. I just want (to leave room for) exact infinity and keep
tranditional syntax. &quot;1/0.&quot; and &quot;-1/0.&quot; will work for that.

&gt; 
&gt;  | For the same reason, the syntax of &quot;indeterminate&quot; should be &quot;0/0&quot;
&gt;  | (exact) and &quot;nan.0&quot; (inexact).  The names +inf.0, -inf.0 and nan.0
&gt;  | were borrowed from PLT scheme.
&gt; 
&gt; While the number syntax of R5RS can be readily extended to include
&gt; +inf.0, -inf.0 (because of the leading sign). &quot;nan.0&quot; runs afoul of
&gt; R5RS 2.1 Identifiers:
&gt; 
&gt;    ... in all implementations a sequence of letters, digits, and
&gt;    &quot;extended alphabetic characters&quot; that begins with a character that
&gt;    cannot begin a number is an identifier.
&gt; 
&gt; If NAN.0 is syntactically a number, then NOT, NULL-ENVIRONMENT, NULL?,
&gt; NUMBER-&gt;STRING, NUMBER?, and NUMERATOR are not identifiers.

PLT Scheme has both &quot;+nan.0&quot; and &quot;-nan.0&quot;, and it actually doesn't have
&quot;nan.0&quot;. So actually it doesn't run afoul of R5RS. A tricky solution.

For &quot;1/0.&quot; and &quot;-1/0.&quot;, &quot;0/0.&quot; will be a nature choice.

&gt; 
&gt;  | Another rationale is utility.  For example, interval arithmetic
&gt;  | will need exact infinity.
&gt; 
&gt; I have used interval arithmetic in Scheme (coding #f for infinity).
&gt; Why does it need exact infinity?

Although you use #f for infinity, it means an exact infinity.
If we have exact infinity, than an interval is a pair of two rational,
which will simplify the code of interval arithmetic (and made it more
readable).

&gt; 
&gt;  | 2. Since we have both positive infinity and negative infinity, we
&gt;  |    are forced to have two (or four, if exactness is also
&gt;  |    considered) zeroes: positive and negative.  IMO, this model is
&gt;  |    more preferable than the &quot;limit&quot;.
&gt; 
&gt; Limits are familiar to everyone who has studied the Calculus.  To my
&gt; knowledge, limits have only been implemented on computers in symbolic
&gt; mathematics programs.  To have them in Scheme may be an advancement.
&gt; 

But how can you ensure the limit always return the right answer? I read
the reference implementation only to find that it is a numerical one and
can be easily cheated. AFAIK, CASs do some limits symbolically. And I
can accept a CAS give some wrong result (even different CASs return
different result giving the same input). But Scheme can't do so. 
Then must be an exact algorithm to do each thing in a Scheme spec!

I tried the reference implementation in PLT Scheme:

(define (finite? z)
  (not (and (= z (* 2 z)) (not (zero? z)))))

(define sequence-&gt;limit
  (let ((almost-zero
	 (do ((inc 1.0 (/ inc 2)) (linc 2 inc))
	     ((zero? inc) linc))))
    (lambda (proc sequence)
      (define val (proc (cadr sequence)))
      (define lval (proc (car sequence)))
      (define (loop sequence trend ldelta)
	(cond ;; don't PROC last X if diverging or there is no trend
	 ((and (null? (cdr sequence)) (not trend) (zero? ldelta)) val)
	 ((and (null? (cdr sequence)) (not trend) (not (real? val))) #f)
	 ((and (null? (cdr sequence)) (eq? trend 'diverging))
	  (and (real? val) (* (- val lval) +inf.0)))
	 (else
	  (set! lval val)
	  (set! val (proc (car sequence)))
	  (if (finite? val)
	      (let ((delta (magnitude (- val lval))))
		;;(print (car sequence) '==&gt; val 'delta delta trend)
		(case trend
		  ((converging)
		   (cond ((null? (cdr sequence)) val)
			 ((&gt; delta (+ almost-zero ldelta)) #f)
			 (else (loop (cdr sequence) trend delta))))
		  ((diverging)
		   (cond ((&lt; delta ldelta) #f)
			 ((null? (cdr sequence)) val)
			 (else (loop (cdr sequence) trend delta))))
		  (else
		   (cond ((null? (cdr sequence)) val)
			 ((&gt; delta (+ almost-zero ldelta))
			  (loop (cdr sequence) 'diverging delta))
			 ((&lt; delta ldelta)
			  (loop (cdr sequence) 'converging delta))
			 (else
			  (loop (cdr sequence) trend delta))))))
	      val))))
      (cond ((and (finite? val) (finite? lval))
	     (loop (cddr sequence) #f (magnitude (- val lval))))
	    ((finite? lval) val)
	    (else lval)))))

(define limit
  (let ((almost-inc #f)
	(almost-inf #f)
	(sequence+1/0 #f)
	(sequence-1/0 #f))
    (do ((x 1.0 (+ x x))
	 (x-prev 0.0 x))
	((= x +inf.0)
	 (do ((x x-prev (+ x frac))
	      (frac (/ x-prev 2) (/ frac 2)))
	     ((= x +inf.0))
	   (set! almost-inc (* 2 frac))
	   (set! almost-inf x))))
    (set! sequence+1/0
	  (let ((inc (* 1024 almost-inc)))
	    (do ((x (+ almost-inf (* -8 inc)) (+ x inc))
		 (lst '() (cons x lst)))
		((not (finite? x)) (reverse (cons x lst))))))
    (set! sequence-1/0 (map - sequence+1/0))
    (lambda (proc z1 . z2)
      (cond ((finite? z1)
	     (set! z2 (car z2))
	     (if (= z1 (+ z1 z2))
		 (proc z1)
		 (let ((dec (/ z2 8.0)))
		   (do ((x (+ z1 z2) (- x dec))
			(cnt 7 (+ -1 cnt))
			(lst '() (cons x lst)))
		       ((negative? cnt)
			(sequence-&gt;limit proc (reverse (cons z1 lst))))))))
	    (else (sequence-&gt;limit proc (if (positive? z1)
					    sequence+1/0
					    sequence-1/0)))))))


&gt; (limit (lambda (x) (/ (sin x) x)) 0 1.0e-9)
1.0
&gt; (limit (lambda (x) (/ (sin x) x)) 0 1)
bug /: division by zero
&gt; (limit (lambda (x) (if (exact? x) 1 0)) 0 1.0e-9)
0
&gt; (limit (lambda (x) (if (rational? x) 1 0)) 0 1.0e-9)
1

Note that the final case can't be solved with any numerical method.


&gt;  | For example, in PLT Scheme:
&gt;  | 
&gt;  | Language: Textual (MzScheme, includes R5RS).
&gt;  | &gt; (/ -0.0)
&gt;  | -inf.0
&gt;  | &gt; (/ 0.0)
&gt;  | +inf.0
&gt;  | &gt; (/ +0.0)
&gt;  | +inf.0
&gt;  | &gt; (+ 0.0 -0.0)
&gt;  | 0.0
&gt;  | 
&gt;  | The only compromise is the last case: (+ 0.0 -0.0) evals to +0.0
&gt;  | 
&gt;  | Other computation rules should be straight forward.
&gt; 
&gt; ;; MzScheme version 205:
&gt; 
&gt; &gt; (eqv? 0.0 +0.0)
&gt; #t
&gt; &gt; (eqv? 0.0 -0.0)
&gt; #f
&gt; &gt; (&lt; -0.0 +0.0)
&gt; #f
&gt; &gt; (* 2.0 -0.0)
&gt; 0.0
&gt; &gt; (/ 0.5 -0.0)
&gt; -inf.0
&gt; &gt; (/ (* 2.0 -0.0))
&gt; +inf.0
&gt; 

I never meant what MzScheme does is all right.

IMO, using +0, -0 (+0.0 and -0.0 for inexact numbers), things
should be (x is a positive number):

(* x -0.0) and (* -x 0.0) should be -0.0,
(* x 0.0) and (* -x -0.0) should be 0.0

(&lt; -1/0 -x -0 0 x 1/0)

(= 0 +0)

Anything else that is still not explained?

-		
Chongkai Zhu

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00038" href="msg00038.html">Re: My ideas about infinity in Scheme (revised)</a></strong>
<ul><li><em>From:</em> Aubrey Jaffer</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00020.html">Re: My ideas about infinity in Scheme (revised)</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00022.html">Re: My ideas about infinity in Scheme (revised)</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00015.html">Re: My ideas about infinity in Scheme (revised)</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00038.html">Re: My ideas about infinity in Scheme (revised)</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00021"><strong>Date</strong></a></li>
<li><a href="threads.html#00021"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
