<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: vector compare -->
<!--X-From-R13: Eronfgvna Stare <fronfgvna.rtareNcuvyvcf.pbz> -->
<!--X-Date: Thu,  9 Jun 2005 12:41:56 +0200 (DFT) -->
<!--X-Message-Id: OFA3D3B08D.AF552B83&#45;ONC125701B.002DEBB9&#45;C125701B.003AC342@philips.com -->
<!--X-Content-Type: multipart/alternative -->
<!--X-Reference: 87m0iD.A.KhH.de_pCB@rotkohl -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: vector compare</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00039.html">Date Prev</a>][<a href="msg00041.html">Date Next</a>][<a href="msg00044.html">Thread Prev</a>][<a href="msg00047.html">Thread Next</a>][<a href="maillist.html#00040">Date Index</a>][<a href="threads.html#00040">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: vector compare</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-67">SRFI 67</a> from before July 7th, 2015.  The new archives for SRFI 67 are <a href="http://srfi-email.schemers.org/srfi-67/">here</a>.  Eventually, the entire history will be moved there, including any new messages.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: <a href="mailto:srfi-67@DOMAIN.HIDDEN">srfi-67@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Subject</em>: Re: vector compare</li>
<li><em>From</em>: Sebastian Egner &lt;<a href="mailto:sebastian.egner@DOMAIN.HIDDEN">sebastian.egner@xxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Thu, 9 Jun 2005 12:41:09 +0200</li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-67@DOMAIN.HIDDEN">srfi-67@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:87m0iD.A.KhH.de_pCB@DOMAIN.HIDDEN">87m0iD.A.KhH.de_pCB@rotkohl</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->

<br><font size=2><tt>Per Bothner wrote:</tt></font>
<br><font size=2><tt>&gt; Do you have any examples or use cases or algorithms
that are simpler<br>
&gt; when using this &quot;natural order&quot;? &nbsp;What prior art is
there for<br>
&gt; using this order?<br>
</tt></font>
<br><font size=2 face="sans-serif">Built-in lexicographical orders on vectors
have hurt me more than once</font>
<br><font size=2 face="sans-serif">for ordering actual 'vectors', i.e.
elements of vector spaces (abelian group</font>
<br><font size=2 face="sans-serif">with a field acting on it) of different
dimension. By using the lex order you</font>
<br><font size=2 face="sans-serif">effectively fix an embedding of the
lower-dimensional vector spaces into</font>
<br><font size=2 face="sans-serif">the higher---and that is often the wrong
thing to do.</font>
<br>
<br><font size=2 face="sans-serif">Concerning prior art: Are you really
asking me why anybody anywhere would</font>
<br><font size=2 face="sans-serif">like to order sequences by length and
then lexicographically, instead just</font>
<br><font size=2 face="sans-serif">lexicographically, and where you can
find published references to programs</font>
<br><font size=2 face="sans-serif">that do that?</font>
<br>
<br><font size=2 face="sans-serif">Actually, I do not intend to settle
this question by digging up 'prior art' and</font>
<br><font size=2 face="sans-serif">looking where the bigger pile is. Let
us focus on which problem we would</font>
<br><font size=2 face="sans-serif">like to solve, and how the solutions
fit with the structures that are present in</font>
<br><font size=2 face="sans-serif">Scheme. The advantage of ordering LIST
and VECTOR the same is that</font>
<br><font size=2 face="sans-serif">it is easier to remember. The advantage
of ordering them differently is that</font>
<br><font size=2 face="sans-serif">you get the choice---based on the basic
operations.</font>
<br>
<br><font size=2><tt>&gt; &gt; If I understand correctly, your argument
is that LIST and VECTOR should<br>
&gt; &gt; both be interpreted as mere implementations of some abstract
SEQUENCE<br>
&gt; &gt; data type,<br>
&gt; <br>
&gt; I'm saying that some Scheme implementations (at least Kawa) and at<br>
&gt; least one SRFI (44) does this. &nbsp;I'm also pointing out that Common
Lisp<br>
&gt; does this. &nbsp;I.e. this is not a far-fetched concept.</tt></font>
<br>
<br><font size=2 face="sans-serif">SRFI 44 defines a lot and implements
nothing. I think SRFI 44 represents a good deal of</font>
<br><font size=2 face="sans-serif">good work. Yet it is still to be seen
that this is really the way data structures should be</font>
<br><font size=2 face="sans-serif">organized in Scheme. Comparing containers,
for example, is a problem: SRFI 44 defines</font>
<br><font size=2 face="sans-serif">nothing for that but its design excludes
several possible approaches already.</font>
<br>
<br><font size=2 face="sans-serif">Concerning Kawa and Common Lisp, the
problem is the same: The object system brings</font>
<br><font size=2 face="sans-serif">structure to the world of data types---but
it also imposes a certain point of view.</font>
<br><font size=2 face="sans-serif">This point of is certainly plausible,
but it is not the only one, and its benefits are overrated.</font>
<br>
<br><font size=2 face="sans-serif">My point of view is that the user should
be enabled to construct exactly the data structures</font>
<br><font size=2 face="sans-serif">required for an application from prefab
building blocks---instead of finding a fully organized</font>
<br><font size=2 face="sans-serif">world already. Initially the organized
world is nice, but sooner or later you hit brick walls,</font>
<br><font size=2 face="sans-serif">and the more complex it gets the more
that hurts.</font>
<br>
<br><font size=2 face="sans-serif">Now, if you have sequence data that
is naturally ordered lexicographically than you can</font>
<br><font size=2 face="sans-serif">use LISTs or VECTORs ordered as lists
to represent the data. If you have sequences </font>
<br><font size=2 face="sans-serif">that are naturally ordered by length
and then lexicographically you can use VECTORs</font>
<br><font size=2 face="sans-serif">or LISTs ordered as vectors. And in
both cases it is likely that the concrete default </font>
<br><font size=2 face="sans-serif">representation has something to do with
the application already. (Which is the result of</font>
<br><font size=2 face="sans-serif">the 'natural ordering based on the available
primitive operations' thing.)</font>
<br><font size=2><tt><br>
&gt; It is true that if an ordering is defined for sequence,<br>
&gt; then it would be bad to define inconsistent orderings for different<br>
&gt; sub-types of sequence. &nbsp;I'm making a weaker claim: if you define
an<br>
&gt; operation F on type A and on type B that are both sub-types of a common<br>
&gt; super-type S then good object-oriented design suggests you should<br>
&gt; define the operation F to have common properties (axioms) for both<br>
&gt; A and B.</tt></font>
<br>
<br><font size=2 face="sans-serif">And this what this SRFI is doing: Vector,
List, Number, String, Symbol, Char, etc. are all</font>
<br><font size=2 face="sans-serif">subtypes of the overall Scheme object
type---and they all provide a compare procedure</font>
<br><font size=2 face="sans-serif">that satisfies certain axioms. Furthermore
the orderings of number types are required</font>
<br><font size=2 face="sans-serif">to be compatible with the tower of numeric
data types in R5RS, even though the tower</font>
<br><font size=2 face="sans-serif">does not really define a subtype hierarchy
in the strong sense, because that makes</font>
<br><font size=2 face="sans-serif">sense mathematically. Finally, default-compare
refines pair-compare. And that is as far</font>
<br><font size=2 face="sans-serif">as the subtype thing goes in this SRFI.
In particular, LIST and VECTOR are *not* seen</font>
<br><font size=2 face="sans-serif">as two concrete realizations of a common
container supertype.</font>
<br>
<br><font size=2 face="sans-serif">Now your point of view is that Vector
and List should be interpreted as subtypes</font>
<br><font size=2 face="sans-serif">of &nbsp;a Sequence type---because SRFI
44, Kawa, and Common Lisp do that way</font>
<br><font size=2 face="sans-serif">and it is &quot;not a far-fetched concept.&quot;
(Quite natural even, I would say.)</font>
<br><font size=2 face="sans-serif">But I do not find this concept back
in the definition of Scheme as it is now,</font>
<br><font size=2 face="sans-serif">and there are alternative approaches
that give you more choice.</font>
<br>
<br><font size=2 face="sans-serif">Don't get me wrong, I am in fact a fan
of the Sequence approach. I even experimented</font>
<br><font size=2 face="sans-serif">with my own Sequence data type as an
add-on for Scheme, but not as an abstract</font>
<br><font size=2 face="sans-serif">type (or interface) to unify LIST and
VECTOR. The sequences I experimented with</font>
<br><font size=2 face="sans-serif">were self-optimizing (amortized) data
structures that eventually adapt to their use</font>
<br><font size=2 face="sans-serif">case (in particular LIFO, FIFO, or random-access)
and are reasonably efficient</font>
<br><font size=2 face="sans-serif">(i.e. O(n log n) with small constants)
over an extremely large scale of size, including</font>
<br><font size=2 face="sans-serif">external memory algorithms. In the end,
the implementation went out of hand for</font>
<br><font size=2 face="sans-serif">a hobby project and I had to stop. Now
these sequences do not fit SRFI 44, nor</font>
<br><font size=2 face="sans-serif">Kawa, nor Common LISP and they coexist
with LIST and VECTOR.</font>
<br>
<br><font size=2><tt>&gt; Even if you view vectors and lists as both sequences,
it doesn't<br>
&gt; follow that on operation F must be defined in terms of sequences.<br>
&gt; However, it's usually a good idea.<br>
&gt; <br>
&gt; Moreover, some schemes provide &quot;uniform vectors&quot;, and there
are SRFIs<br>
&gt; that define them. &nbsp;What is the natural order for a uniform vector?<br>
&gt; By your argument, and I think &quot;common sense&quot; (admittedly
unreliable)<br>
&gt; it should be the same order as for normal vectors. &nbsp;Certainly
if you<br>
&gt; believe uniform vectors &quot;inherit&quot; from an &quot;abstract
vector&quot; type.<br>
&gt; <br>
&gt; Now consider strings. &nbsp;Is a string a vector? &nbsp;If you have
uniform<br>
&gt; vectors, then it seems very strange to not view a string as a uniform<br>
&gt; vector. &nbsp;It follows that the ordering for strings should be the
same<br>
&gt; as for uniform vectors.<br>
&gt; <br>
&gt; Strings use lexicographic order.<br>
&gt; Hence uniform vectors should use lexicographic order.<br>
&gt; Hence vectors should use lexicographic order.</tt></font>
<br>
<br><font size=2 face="sans-serif">My whole point is that the order to
be defined for a data type does not follow</font>
<br><font size=2 face="sans-serif">from the data type or its supertypes
but is part of what the data type means.</font>
<br><font size=2 face="sans-serif">Now if the uniform vectors represent
elements of vector spaces than you might</font>
<br><font size=2 face="sans-serif">want a different ordering than if they
represent strings.</font>
<br>
<br><font size=2 face="sans-serif">Btw., strings are one the most exceptional
things around. The lex. ordering is</font>
<br><font size=2 face="sans-serif">historic and not at all 'God-given'.
Japanese dictionaries contain several</font>
<br><font size=2 face="sans-serif">alternative orderings: By stroke number,
by radical (prototypes of parts of the</font>
<br><font size=2 face="sans-serif">actual characters, most are also characters
in themselves), or by pronounciation.</font>
<br><font size=2 face="sans-serif">&quot;The natural order&quot; of strings
is a matter of taste. In Germany the treatment of</font>
<br><font size=2 face="sans-serif">Umlauts has changed during the past
30 years: Today &amp;auml; is inserted where</font>
<br><font size=2 face="sans-serif">'ae' would be. But I have lots of dictionaries
at home that insert &amp;auml; where</font>
<br><font size=2 face="sans-serif">'a' would be. Using Unicode scalar values
&amp;auml; has a high scalar value</font>
<br><font size=2 face="sans-serif">so it would be inserted after 'z'. Ordering
strings by length&gt;lex can also make</font>
<br><font size=2 face="sans-serif">sense in some applications.</font>
<br><font size=2 face="sans-serif">&nbsp;</font>
<br><font size=2 face="sans-serif">So I have difficulties following you
argumentation above.</font>
<br><font size=2 face="sans-serif">My point of view is:</font>
<br>
<br><font size=2 face="sans-serif">Yes, strings use lex. order because
that makes sense as a general default.</font>
<br><font size=2 face="sans-serif">No, that does not imply that uniform
vectors should also use lex. order.</font>
<br><font size=2 face="sans-serif">They can better provide one or more
orders that make sense for</font>
<br><font size=2 face="sans-serif">their intended applications. And no,
that still does not imply that the built-in</font>
<br><font size=2 face="sans-serif">VECTOR type should be ordered in any
particular way for the sake of</font>
<br><font size=2 face="sans-serif">uniformity.</font>
<br>
<br><font size=2 face="sans-serif">Historically, &quot;uniform vectors&quot;
do not allow you to specify the ordering you</font>
<br><font size=2 face="sans-serif">want to use---but they should. Lukily,
in the majority of the cases it is sufficient</font>
<br><font size=2 face="sans-serif">to define any ordering at all. If u8vector
or anything provides a default order,</font>
<br><font size=2 face="sans-serif">I would make it length&gt;lex because
that is the most natural and efficient for</font>
<br><font size=2 face="sans-serif">this type, unless you tell me that you
always use them in hashing in which</font>
<br><font size=2 face="sans-serif">case I would make the default order
by hashcode, then length&gt;lex. ;-)</font>
<br>
<br><font size=2 face="sans-serif">Sebastian.</font>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00039.html">Re: Optional arguments at the beginning</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00041.html">Re: vector compare</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00044.html">Re: vector compare</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00047.html">Re: vector compare</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00040"><strong>Date</strong></a></li>
<li><a href="threads.html#00040"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
