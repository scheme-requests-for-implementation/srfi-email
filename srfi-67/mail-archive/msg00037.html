<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: vector compare -->
<!--X-From-R13: Eronfgvna Stare <fronfgvna.rtareNcuvyvcf.pbz> -->
<!--X-Date: Thu,  9 Jun 2005 09:19:48 +0200 (DFT) -->
<!--X-Message-Id: OF7B1F9CDE.F4ED119E&#45;ONC125701B.0027F89A&#45;C125701B.002840B7@philips.com -->
<!--X-Content-Type: multipart/alternative -->
<!--X-Reference: dJAr2.A.s6H.Eu9pCB@rotkohl -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: vector compare</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00036.html">Date Prev</a>][<a href="msg00038.html">Date Next</a>][<a href="msg00035.html">Thread Prev</a>][<a href="msg00038.html">Thread Next</a>][<a href="maillist.html#00037">Date Index</a>][<a href="threads.html#00037">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: vector compare</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: <a href="mailto:srfi-67@DOMAIN.HIDDEN">srfi-67@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Subject</em>: Re: vector compare</li>
<li><em>From</em>: Sebastian Egner &lt;<a href="mailto:sebastian.egner@DOMAIN.HIDDEN">sebastian.egner@xxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Thu, 9 Jun 2005 09:18:59 +0200</li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-67@DOMAIN.HIDDEN">srfi-67@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:dJAr2.A.s6H.Eu9pCB@DOMAIN.HIDDEN">dJAr2.A.s6H.Eu9pCB@rotkohl</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->

<br><font size=2><tt>&gt; The default compare for vectors is unusual, and
more critically it is<br>
&gt; incompatible with the default compare for lists and strings.<br>
&gt; The latter are both lexicographic compare.</tt></font>
<br>
<br><font size=2 face="sans-serif">Correct. In this SRFI, vectors are compared
first by length and then</font>
<br><font size=2 face="sans-serif">lexicographically by default.</font>
<br>
<br><font size=2><tt>&gt; I couldn't find a rationale for this difference.</tt></font>
<br>
<br><font size=2 face="sans-serif">The paragraph &quot;What is the 'natural
order' of lists and vectors?'</font>
<br>
<br><font size=2 face="sans-serif">&nbsp; &nbsp; &nbsp; &nbsp; http://srfi.schemers.org/srfi-67/srfi-67.html#node_toc_node_sec_Temp_20</font>
<br>
<br><font size=2 face="sans-serif">states our motivation (extra dry) for
this design.</font>
<br>
<br><font size=2><tt>&gt; Note that this difference makes it difficult
to have a unified<br>
&gt; &quot;sequence hierarchy&quot; as in Common Lisp. &nbsp;</tt></font>
<br><font size=2><tt>&gt; The problem is that ordering is defined in terms
of</tt></font>
<br><font size=2><tt>&gt; *implementation* types rather than semantics.<br>
</tt></font>
<br><font size=2 face="sans-serif">If I understand correctly, your argument
is that LIST and VECTOR should</font>
<br><font size=2 face="sans-serif">both be interpreted as mere implementations
of some abstract SEQUENCE</font>
<br><font size=2 face="sans-serif">data type, and that the ordering should
be defined for SEQUENCE, only. Hence,</font>
<br><font size=2 face="sans-serif">all implementations of sequence should
have the same (default) ordering---</font>
<br><font size=2 face="sans-serif">independently of what operations they
actually provide.</font>
<br>
<br><font size=2 face="sans-serif">This is in contrast to the point of
view we have taken for this SRFI:</font>
<br><font size=2 face="sans-serif">There are two abstract data types called
VECTOR and LIST, where </font>
<br><font size=2 face="sans-serif">VECTOR is specified by a SIZE procedure
and a REF procedure</font>
<br><font size=2 face="sans-serif">(e.g. constant-time random access finite-length
sequences) and</font>
<br><font size=2 face="sans-serif">LIST is specified by procedures EMPTY?,
HEAD and TAIL (e.g.</font>
<br><font size=2 face="sans-serif">unbounded finite stacks). </font>
<br>
<br><font size=2 face="sans-serif">In our point of view, these abstract
types have a life of their own</font>
<br><font size=2 face="sans-serif">and are <b>not</b> just simplified versions
of some hypothetical abstract</font>
<br><font size=2 face="sans-serif">SEQUENCE type. (Which is entirely absent
in Scheme as it is today.)</font>
<br>
<br><font size=2 face="sans-serif">Now for LIST the natural ordering is
lexicographic. For VECTOR the</font>
<br><font size=2 face="sans-serif">both SIZE and REF operations are assumed
constant time and the</font>
<br><font size=2 face="sans-serif">natural ordering is defined as first
by SIZE, then by REF (lex).</font>
<br>
<br><font size=2 face="sans-serif">The concrete LIST and VECTOR types specified
in Scheme are</font>
<br><font size=2 face="sans-serif">implementations of the abstract LIST
and VECTOR---and inherit</font>
<br><font size=2 face="sans-serif">the ordering (part of the semantics)
from the abstract one. In fact,</font>
<br><font size=2 face="sans-serif">we do not even talk about the abstract
LIST and VECTOR data</font>
<br><font size=2 face="sans-serif">types explicitly; we only say &quot;is
ordered like a VECTOR.&quot;</font>
<br>
<br><font size=2 face="sans-serif">My experience is that both orders are
needed quite frequently</font>
<br><font size=2 face="sans-serif">because sequence data types (i.e. finite
collections with elements</font>
<br><font size=2 face="sans-serif">ordered by their relative position)
are used for so many different</font>
<br><font size=2 face="sans-serif">purposes. The abstract SEQUENCE type
is great for simplifying</font>
<br><font size=2 face="sans-serif">complicated data structure libraries
(like EDISON) but it also</font>
<br><font size=2 face="sans-serif">rubs out any distinction between more
specialized sequence</font>
<br><font size=2 face="sans-serif">types (stack, queue, deque, steque,
string, chain, rope, vector,</font>
<br><font size=2 face="sans-serif">tuple, array, streams, files etc.) At
least, I believe that having the</font>
<br><font size=2 face="sans-serif">operations you need---and not more---is
the key to efficient data</font>
<br><font size=2 face="sans-serif">structures.</font>
<br>
<br><font size=2 face="sans-serif">To summarize, in our interpretation
a VECTOR is not just a LIST</font>
<br><font size=2 face="sans-serif">with a &quot;#&quot; in front---it is
an entirely different abstract data type </font>
<br><font size=2 face="sans-serif">(&gt;constant-time random-access finite
sequence&lt;), and as such</font>
<br><font size=2 face="sans-serif">its instances should be ordered by the
most appropriate order.</font>
<br>
<br><font size=2 face="sans-serif">If Scheme ever includes the notion of
SEQUENCE, and some</font>
<br><font size=2 face="sans-serif">hierarchy of more restricted types,
it might be time to redesign</font>
<br><font size=2 face="sans-serif">(e.g. defining the ordering together
with the type or something).</font>
<br>
<br><font size=2 face="sans-serif">Sebastian.</font>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00038" href="msg00038.html">Re: vector compare</a></strong>
<ul><li><em>From:</em> Per Bothner</li></ul></li>
<li><strong><a name="00044" href="msg00044.html">Re: vector compare</a></strong>
<ul><li><em>From:</em> Michael Sperber</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00036.html">Optional arguments at the beginning</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00038.html">Re: vector compare</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00035.html">Re: vector compare</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00038.html">Re: vector compare</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00037"><strong>Date</strong></a></li>
<li><a href="threads.html#00037"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
