<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: Encodings. -->
<!--X-From-R13: Bnhy Epuyvr <fpuyvrNpbzpnfg.arg> -->
<!--X-Date: Fri, 13 Feb 2004 02:40:44 +0100 (NFT) -->
<!--X-Message-Id: BC519542.A4DE%schlie@comcast.net -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20040212231505.C71A16BFFF@laime.cs.uchicago.edu -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: Encodings.</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00027.html">Date Prev</a>][<a href="msg00029.html">Date Next</a>][<a href="msg00027.html">Thread Prev</a>][<a href="msg00030.html">Thread Next</a>][<a href="maillist.html#00028">Date Index</a>][<a href="threads.html#00028">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: Encodings.</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-52">SRFI 52</a> from before July 7th, 2015.  The new archives for SRFI 52 are <a href="http://srfi-email.schemers.org/srfi-52/">here</a>.  The new archives contain all messages, not just those from before July 7th, 2015.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: &lt;<a href="mailto:srfi-52@DOMAIN.HIDDEN">srfi-52@xxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Subject</em>: Re: Encodings.</li>
<li><em>From</em>: Paul Schlie &lt;<a href="mailto:schlie@DOMAIN.HIDDEN">schlie@xxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Thu, 12 Feb 2004 20:40:34 -0500</li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-52@DOMAIN.HIDDEN">srfi-52@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:20040212231505.C71A16BFFF@DOMAIN.HIDDEN">20040212231505.C71A16BFFF@xxxxxxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>User-agent</em>: Microsoft-Entourage/10.1.4.030702.0</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>Hi Robby,

Sorry, but unfortunately I'm missing your point; as it seems to me that
the only potential ambiguity that exists by continuing to restrict the
composition of scheme code to using a &quot;truly portable&quot; character subset
as exists today, is a formal specification of how to express/display
characters and strings composed of characters beyond scheme's portable
character set. (as scheme programs utilizing portable characters already
can be converted/displayed/editable on most known present/future hosts).

Which for all practical purposes doesn't seem like much of problem, as
scheme already enables the numerical expression/display of arbitrary
character/byte encoded values, (which of course would be specific to
the character encoding scheme an implementation chose to utilize, which
fortunately not specified by the standard; thereby enabling scheme
implementations to adopt the assumed character encoding utilized by it's
host environment, thereby enabling the assumption of character and raw
data byte storage and I/O sequence equivalence; thereby enabling
character/byte strings and ports to arbitrarily store and interface with
it's environment utilizing any data encoding format that may be required
for any arbitrary purpose. (actually a fairly flexible scheme).

For the sake of argument, in circumstances where it may be desirable to
support the expression of non-portably-displayable encoded extended
character-set characters, why not simply define their names spelled
within scheme's portable character set; just as #\space is spelled out.

i.e.: #\uc:ezet, #\uc:some-chinese-character-name, #\uc:pi, etc.

  or: (uc 'ezet), (uc 'some-chinese-character-name), (uc 'pi), etc.

which I believe have already been named/spelled in unicode's documentation.

As otherwise complications arise when one tries to:

- specify the character encoding format utilized by scheme, as it then
may force characters to translated between scheme's character encoding,
and that presumed by the host's environment, thereby preventing the use
of scheme's character strings and ports for arbitrarily encoded data,
for which scheme presently specifies no alternative facility.

- specify the use of a specific extended character-set for both scheme
program code and arbitrary character data, which may not easily be
unambiguously translated between arbitrary other character-sets, and/or
possibly not even displayable or easily editable on arbitrary platforms.

Incidentally, while admitting to likely being somewhat both culturally
and/or historically biased, I know I have no interest (even if Unicode
were ubiquitous), trying to decipher a program composed of mixed Chinese,
Japanese, English, French, Greek, Slavic, etc. identifiers and comments; as
if programs like this were allowed to be produced, they would be basically
unsupportable, and the industry would collapse upon itself, as it already
has enough problems trying to maintain code written in a single relatively
restricted language and character set, which for good or bad, folks within
the computing world have had to become reasonably familiar with, thereby
unifying programmers ability to develop, debug, and share common code;
otherwise we'll end up with a heterogeneous language code base such that
rather than (+ 1 1 1) -&gt; 3, well end up with (+ 1 1 1) -&gt; 1 to no one's
true benefit.

-paul-


&gt; From: Robby Findler &lt;robby@xxxxxxxxxxxxxxx&gt;
&gt;&gt; At Thu, 12 Feb 2004 16:23:17 -0500, Paul Schlie wrote:
&gt;&gt; As Ken properly pointed out, and which should be abundantly clear to most
&gt;&gt; by now; attempting to enable scheme to more conveniently process text
&gt;&gt; encoded in an arbitrary character set, is distinctly different than
&gt;&gt; attempting to enable scheme to utilize arbitrary characters within its
&gt;&gt; program identifier/comment definitions.
&gt;&gt; 
&gt;&gt; While the first is arguably noble, the second would be clearly a mistake.
&gt; 
&gt; I think you're missing one of the real virtues of Scheme (LISP,
&gt; originally). As someone has already pointed out, Scheme's data is a
&gt; very good representation for Scheme's code.
&gt; 
&gt; Indeed, Schemers can exploit this to tremendous advantage. For example,
&gt; imagine you wanted to write a test suite for a macro you had written
&gt; and in particular wanted to test that syntax error are raised properly
&gt; for bad inputs. In Scheme, this is merely a additional 2 lines in your
&gt; testing infrastructure (one to call `expand' and one to catch the
&gt; exception). You do not need to step out of the language or start
&gt; scripting another instance of your compiler.
&gt; 
&gt; Going even further, consider DrScheme. DrScheme only has one virtual
&gt; machine that runs DrScheme itself's code and simultaneously runs the
&gt; user's program. Scheme's code as data is one piece of the puzzle that
&gt; makes this work so well.
&gt; 
&gt; Robby

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00030" href="msg00030.html">Re: Encodings.</a></strong>
<ul><li><em>From:</em> Robby Findler</li></ul></li>
<li><strong><a name="00033" href="msg00033.html">Re: Encodings.</a></strong>
<ul><li><em>From:</em> bear</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00027" href="msg00027.html">Re: Encodings.</a></strong>
<ul><li><em>From:</em> Robby Findler</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00027.html">Re: Encodings.</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00029.html">Re: Encodings.</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00027.html">Re: Encodings.</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00030.html">Re: Encodings.</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00028"><strong>Date</strong></a></li>
<li><a href="threads.html#00028"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
