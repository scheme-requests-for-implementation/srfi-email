<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: SRFI 43 Reference Implementation vector&#45;map bug -->
<!--X-From-R13: Fnlybe Qnzcoryy <pnzcoryyNoybbqnaqpbssrr.arg> -->
<!--X-Date: Fri,  4 Feb 2005 22:15:06 +0100 (NFT) -->
<!--X-Message-Id: Pine.LNX.4.44.0502041404090.14248&#45;200000@autodrip.bloodandcoffee.net -->
<!--X-Content-Type: multipart/mixed -->
<!--X-Reference: bcc8ce54ace54f07be5022f418810d8c@mit.edu -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: SRFI 43 Reference Implementation vector-map bug</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00000.html">Date Prev</a>][<a href="msg00002.html">Date Next</a>][<a href="msg00000.html">Thread Prev</a>][<a href="msg00002.html">Thread Next</a>][<a href="maillist.html#00001">Date Index</a>][<a href="threads.html#00001">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: SRFI 43 Reference Implementation vector-map bug</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: &quot;Will M. Farr&quot; &lt;<a href="mailto:farr@DOMAIN.HIDDEN">farr@xxxxxxx</a>&gt;</li>
<li><em>Subject</em>: Re: SRFI 43 Reference Implementation vector-map bug</li>
<li><em>From</em>: Taylor Campbell &lt;<a href="mailto:campbell@DOMAIN.HIDDEN">campbell@xxxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Fri, 4 Feb 2005 14:05:25 -0800 (PST)</li>
<li><em>Cc</em>: <a href="mailto:srfi-43@DOMAIN.HIDDEN">srfi-43@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-43@DOMAIN.HIDDEN">srfi-43@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:bcc8ce54ace54f07be5022f418810d8c@DOMAIN.HIDDEN">bcc8ce54ace54f07be5022f418810d8c@xxxxxxx</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>On Fri, 4 Feb 2005, Will M. Farr wrote:

&gt; Hello,
&gt; 
&gt; I just grabbed your reference implementation of SRFI 43 (vector-lib) 
&gt; from srfi.schemers.org, and I found a bug in vector-map.  The 
&gt; correction is to replace the lines
&gt; 
&gt; (loop f target vec (- len 1))  and (loop f target vectors (- len 1))
&gt; 
&gt; in %vector-map1! and %vector-map2+! with
&gt; 
&gt; (loop f target vec len) and (loop f target vectors len)
&gt; 
&gt; You already subtract one when using a given index in 
&gt; vector-ref/vector-set, so you don't need to do it entering the loop.  I 
&gt; don't know if this matters (most of the ports of vector-lib don't seem 
&gt; to use the reference implementation), but I thought you might want to 
&gt; know.

Thanks for reporting that bug.  This prompted me to review the code
again, which I noticed several more bugs in.  I could swear I tested my
last modifications before I committed them, but it seems that there was
quite a bit that was somewhat broken.  I've attached a new reference
implementation, which is much less buggy &amp; which I've moved into the
public domain.

(What other Scheme systems did you find implemented SRFI 43 from
scratch, by the way?  The only system I know of that already boasts
SRFI 43 support is Chicken, and there it's just a modification of an
old version of my reference implementation.)
</pre><pre>;;;;;; SRFI 43: Vector library                           -*- Scheme -*-

;;; Taylor Campbell wrote this code; he places it in the public domain.



;;; --------------------
;;; Exported procedure index
;;;
;;; * Constructors
;;; make-vector vector
;;; vector-unfold                   vector-unfold-right
;;; vector-copy                     vector-reverse-copy
;;; vector-append                   vector-concatenate
;;;
;;; * Predicates
;;; vector?
;;; vector-empty?
;;; vector=
;;;
;;; * Selectors
;;; vector-ref
;;; vector-length
;;;
;;; * Iteration
;;; vector-fold                     vector-fold-right
;;; vector-map                      vector-map!
;;; vector-for-each
;;; vector-count
;;;
;;; * Searching
;;; vector-index                    vector-skip
;;; vector-index-right              vector-skip-right
;;; vector-binary-search
;;; vector-any                      vector-every
;;;
;;; * Mutators
;;; vector-set!
;;; vector-swap!
;;; vector-fill!
;;; vector-reverse!
;;; vector-copy!                    vector-reverse-copy!
;;; vector-reverse!
;;;
;;; * Conversion
;;; vector-&gt;list                    reverse-vector-&gt;list
;;; list-&gt;vector                    reverse-list-&gt;vector



;;; --------------------
;;; Commentary on efficiency of the code

;;; This code is somewhat tuned for efficiency.  There are several
;;; internal routines that can be optimized greatly to greatly improve
;;; the performance of much of the library.  These internal procedures
;;; are already carefully tuned for performance, and lambda-lifted by
;;; hand.  Some other routines are lambda-lifted by hand, but only the
;;; loops are lambda-lifted, and only if some routine has two possible
;;; loops -- a fast path and an n-ary case --, whereas _all_ of the
;;; internal routines' loops are lambda-lifted so as to never cons a
;;; closure in their body (VECTOR-PARSE-START+END doesn't have a loop),
;;; even in Scheme systems that perform no loop optimization (which is
;;; most of them, unfortunately).
;;;
;;; Fast paths are provided for common cases in most of the loops in
;;; this library.
;;;
;;; All calls to primitive vector operations are protected by a prior
;;; type check; they can be safely converted to use unsafe equivalents
;;; of the operations, if available.  Ideally, the compiler should be
;;; able to determine this, but the state of Scheme compilers today is
;;; not a happy one.
;;;
;;; Efficiency of the actual algorithms is a rather mundane point to
;;; mention; vector operations are rarely beyond being straightforward.



;;; --------------------
;;; Utilities

;;; SRFI 8, too trivial to put in the dependencies list.
(define-syntax receive
  (syntax-rules ()
    ((receive ?formals ?producer ?body1 ?body2 ...)
     (call-with-values (lambda () ?producer)
       (lambda ?formals ?body1 ?body2 ...)))))

;;; Not the best LET*-OPTIONALS, but not the worst, either.  Use Olin's
;;; if it's available to you.
(define-syntax let*-optionals
  (syntax-rules ()
    ((let*-optionals (?x ...) ((?var ?default) ...) ?body1 ?body2 ...)
     (let ((args (?x ...)))
       (let*-optionals args ((?var ?default) ...) ?body1 ?body2 ...)))
    ((let*-optionals ?args ((?var ?default) ...) ?body1 ?body2 ...)
     (let*-optionals:aux ?args ?args ((?var ?default) ...)
       ?body1 ?body2 ...))))

(define-syntax let*-optionals:aux
  (syntax-rules ()
    ((aux ?orig-args-var ?args-var () ?body1 ?body2 ...)
     (if (null? ?args-var)
         (let () ?body1 ?body2 ...)
         (error &quot;too many arguments&quot; (length ?orig-args-var)
                ?orig-args-var)))
    ((aux ?orig-args-var ?args-var
         ((?var ?default) ?more ...)
       ?body1 ?body2 ...)
     (if (null? ?args-var)
         (let* ((?var ?default) ?more ...) ?body1 ?body2 ...)
         (let ((?var (car ?args-var))
               (new-args (cdr ?args-var)))
           (let*-optionals:aux ?orig-args-var new-args
               (?more ...)
             ?body1 ?body2 ...))))))

(define (nonneg-int? x)
  (and (integer? x)
       (not (negative? x))))

(define (between? x y z)
  (and (&lt;  x y)
       (&lt;= y z)))

(define (unspecified-value) (if #f #f))

;++ This should be implemented more efficiently.  It shouldn't cons a
;++ closure, and the cons cells used in the loops when using this could
;++ be reused.
(define (vectors-ref vectors i)
  (map (lambda (v) (vector-ref v i)) vectors))



;;; --------------------
;;; Error checking

;;; Error signalling (not checking) is done in a way that tries to be
;;; as helpful to the person who gets the debugging prompt as possible.
;;; That said, error _checking_ tries to be as unredundant as possible.

;;; I don't use any sort of general condition mechanism; I use simply
;;; SRFI 23's ERROR, even in cases where it might be better to use such
;;; a general condition mechanism.  Fix that when porting this to a
;;; Scheme implementation that has its own condition system.

;;; In argument checks, upon receiving an invalid argument, the checker
;;; procedure recursively calls itself, but in one of the arguments to
;;; itself is a call to ERROR; this mechanism is used in the hopes that
;;; the user may be thrown into a debugger prompt, proceed with another
;;; value, and let it be checked again.

;;; Type checking is pretty basic, but easily factored out and replaced
;;; with whatever your implementation's preferred type checking method
;;; is.  I doubt there will be many other methods of index checking,
;;; though the index checkers might be better implemented natively.

;;; (CHECK-TYPE &lt;type-predicate?&gt; &lt;value&gt; &lt;callee&gt;) -&gt; value
;;;   Ensure that VALUE satisfies TYPE-PREDICATE?; if not, signal an
;;;   error stating that VALUE did not satisfy TYPE-PREDICATE?, showing
;;;   that this happened while calling CALLEE.  Return VALUE if no
;;;   error was signalled.
(define (check-type pred? value callee)
  (if (pred? value)
      value
      ;; Recur: when (or if) the user gets a debugger prompt, he can
      ;; proceed where the call to ERROR was with the correct value.
      (check-type pred?
                  (error &quot;erroneous value&quot;
                         (list pred? value)
                         `(while calling ,callee))
                  callee)))

;;; (CHECK-INDEX &lt;vector&gt; &lt;index&gt; &lt;callee&gt;) -&gt; index
;;;   Ensure that INDEX is a valid index into VECTOR; if not, signal an
;;;   error stating that it is not and that this happened in a call to
;;;   CALLEE.  Return INDEX when it is valid.  (Note that this does NOT
;;;   check that VECTOR is indeed a vector.)
(define (check-index vec index callee)
  (let ((index (check-type integer? index callee)))
    (cond ((&lt; index 0)
           (check-index vec
                        (error &quot;vector index too low&quot;
                               index
                               `(into vector ,vec)
                               `(while calling ,callee))
                        callee))
          ((&gt;= index (vector-length vec))
           (check-index vec
                        (error &quot;vector index too high&quot;
                               index
                               `(into vector ,vec)
                               `(while calling ,callee))
                        callee))
          (else index))))

;;; (CHECK-INDICES &lt;vector&gt;
;;;                &lt;start&gt; &lt;start-name&gt;
;;;                &lt;end&gt; &lt;end-name&gt;
;;;                &lt;caller&gt;) -&gt; [start end]
;;;   Ensure that START and END are valid bounds of a range within
;;;   VECTOR; if not, signal an error stating that they are not, with
;;;   the message being informative about what the argument names were
;;;   called -- by using START-NAME &amp; END-NAME --, and that it occurred
;;;   while calling CALLEE.  Also ensure that VEC is in fact a vector.
;;;   Returns no useful value.
(define (check-indices vec start start-name end end-name callee)
  (let ((lose (lambda things
                (apply error &quot;vector range out of bounds&quot;
                       (append things
                               `(vector was ,vec)
                               `(,start-name was ,start)
                               `(,end-name was ,end)
                               `(while calling ,callee)))))
        (start (check-type integer? start callee))
        (end   (check-type integer? end   callee)))
    (cond ((&gt; start end)
           ;; I'm not sure how well this will work.  The intent is that
           ;; the programmer tells the debugger to proceed with both a
           ;; new START &amp; a new END by returning multiple values
           ;; somewhere.
           (receive (new-start new-end)
                    (lose `(,end-name &lt; ,start-name))
             (check-indices vec
                            new-start start-name
                            new-end end-name
                            callee)))
          ((&lt; start 0)
           (check-indices vec
                          (lose `(,start-name &lt; 0))
                          start-name
                          end end-name
                          callee))
          ((&gt;= start (vector-length vec))
           (check-indices vec
                          (lose `(,start-name &gt; len)
                                `(len was ,(vector-length vec)))
                          start-name
                          end end-name
                          callee))
          ((&gt; end (vector-length vec))
           (check-indices vec
                          start start-name
                          (lose `(,end-name &gt; len)
                                `(len was ,(vector-length vec)))
                          end-name
                          callee))
          (else
           (values start end)))))



;;; --------------------
;;; Internal routines

;;; These should all be integrated, native, or otherwise optimized --
;;; they're used a _lot_ --.  All of the loops and LETs inside loops
;;; are lambda-lifted by hand, just so as not to cons closures in the
;;; loops.  (If your compiler can do better than that if they're not
;;; lambda-lifted, then lambda-drop (?) them.)

;;; (VECTOR-PARSE-START+END &lt;vector&gt; &lt;arguments&gt;
;;;                         &lt;start-name&gt; &lt;end-name&gt;
;;;                         &lt;callee&gt;)
;;;       -&gt; [start end]
;;;   Return two values, composing a valid range within VECTOR, as
;;;   extracted from ARGUMENTS or defaulted from VECTOR -- 0 for START
;;;   and the length of VECTOR for END --; START-NAME and END-NAME are
;;;   purely for error checking.
(define (vector-parse-start+end vec args start-name end-name callee)
  (let ((len (vector-length vec)))
    (cond ((null? args)
           (values 0 len))
          ((null? (cdr args))
           (check-indices vec
                          (car args) start-name
                          len end-name
                          callee))
          ((null? (cddr args))
           (check-indices vec
                          (car  args) start-name
                          (cadr args) end-name
                          callee))
          (else
           (error &quot;too many arguments&quot;
                  `(extra args were ,(cddr args))
                  `(while calling ,callee))))))

(define-syntax let-vector-start+end
  (syntax-rules ()
    ((let-vector-start+end ?callee ?vec ?args (?start ?end)
       ?body1 ?body2 ...)
     (let ((?vec (check-type vector? ?vec ?callee)))
       (receive (?start ?end)
                (vector-parse-start+end ?vec ?args '?start '?end
                                        ?callee)
         ?body1 ?body2 ...)))))

;;; (%SMALLEST-LENGTH &lt;vector-list&gt; &lt;default-length&gt; &lt;callee&gt;)
;;;       -&gt; exact, nonnegative integer
;;;   Compute the smallest length of VECTOR-LIST.  DEFAULT-LENGTH is
;;;   the length that is returned if VECTOR-LIST is empty.  Common use
;;;   of this is in n-ary vector routines:
;;;     (define (f vec . vectors)
;;;       (let ((vec (check-type vector? vec f)))
;;;         ...(%smallest-length vectors (vector-length vec) f)...))
;;;   %SMALLEST-LENGTH takes care of the type checking -- which is what
;;;   the CALLEE argument is for --; thus, the design is tuned for
;;;   avoiding redundant type checks.
(define %smallest-length
  (letrec ((loop (lambda (vector-list length callee)
                   (if (null? vector-list)
                       length
                       (loop (cdr vector-list)
                             (min (vector-length
                                   (check-type vector?
                                               (car vector-list)
                                               callee))
                                  length)
                             callee)))))
    loop))

;;; (%VECTOR-COPY! &lt;target&gt; &lt;tstart&gt; &lt;source&gt; &lt;sstart&gt; &lt;send&gt;)
;;;   Copy elements at locations SSTART to SEND from SOURCE to TARGET,
;;;   starting at TSTART in TARGET.
;;;
;;; Optimize this!  Probably with some combination of:
;;;   - Force it to be integrated.
;;;   - Let it use unsafe vector element dereferencing routines: bounds
;;;     checking already happens outside of it.  (Or use a compiler
;;;     that figures this out, but Olin Shivers' PhD thesis seems to
;;;     have been largely ignored in actual implementations...)
;;;   - Implement it natively as a VM primitive: the VM can undoubtedly
;;;     perform much faster than it can make Scheme perform, even with
;;;     bounds checking.
;;;   - Implement it in assembly: you _want_ the fine control that
;;;     assembly can give you for this.
;;; I already lambda-lift it by hand, but you should be able to make it
;;; even better than that.
(define %vector-copy!
  (letrec ((loop/l-&gt;r (lambda (target source send i j)
                        (cond ((&lt; i send)
                               (vector-set! target j
                                            (vector-ref source i))
                               (loop/l-&gt;r target source send
                                          (+ i 1) (+ j 1))))))
           (loop/r-&gt;l (lambda (target source sstart i j)
                        (cond ((&gt;= i sstart)
                               (vector-set! target j
                                            (vector-ref source i))
                               (loop/r-&gt;l target source sstart
                                          (- i 1) (- j 1)))))))
    (lambda (target tstart source sstart send)
      (if (&gt; sstart tstart)             ; Make sure we don't copy over
                                        ;   ourselves.
          (loop/l-&gt;r target source send sstart tstart)
          (loop/r-&gt;l target source sstart (- send 1)
                     (+ -1 tstart send (- sstart)))))))

;;; (%VECTOR-REVERSE-COPY! &lt;target&gt; &lt;tstart&gt; &lt;source&gt; &lt;sstart&gt; &lt;send&gt;)
;;;   Copy elements from SSTART to SEND from SOURCE to TARGET, in the
;;;   reverse order.
(define %vector-reverse-copy!
  (letrec ((loop (lambda (target source sstart i j)
                   (cond ((&gt;= i sstart)
                          (vector-set! target j (vector-ref source i))
                          (loop target source sstart
                                (- i 1)
                                (+ j 1)))))))
    (lambda (target tstart source sstart send)
      (loop target source sstart
            (- send 1)
            tstart))))

(define %vector-reverse!
  (letrec ((loop (lambda (vec i j)
                   (cond ((&lt;= i j)
                          (let ((v (vector-ref vec i)))
                            (vector-set! vec i (vector-ref vec j))
                            (vector-set! vec j v)
                            (loop vec (+ i 1) (- j 1))))))))
    (lambda (vec start end)
      (loop vec start (- end 1)))))

(define %vector-fold1
  (letrec ((loop (lambda (kons knil len vec i)
                   (if (= i len)
                       knil
                       (loop kons
                             (kons i knil (vector-ref vec i))
                             len vec (+ i 1))))))
    (lambda (kons knil len vec)
      (loop kons knil len vec 0))))

(define %vector-fold2+
  (letrec ((loop (lambda (kons knil len vectors i)
                   (if (= i len)
                       knil
                       (loop kons
                             (apply kons i knil
                                    (vectors-ref vectors i))
                             len vectors (+ i 1))))))
    (lambda (kons knil len vectors)
      (loop kons knil len vectors 0))))

(define %vector-map1!
  (letrec ((loop (lambda (f target vec i)
                   (if (zero? i)
                       target
                       (let ((j (- i 1)))
                         (vector-set! target j
                                      (f j (vector-ref vec j)))
                         (loop f target vec j))))))
    (lambda (f target vec len)
      (loop f target vec len))))

(define %vector-map2+!
  (letrec ((loop (lambda (f target vectors i)
                   (if (zero? i)
                       target
                       (let ((j (- i 1)))
                         (vector-set! target j
                           (apply f j (vectors-ref vectors j)))
                         (loop f target vectors j))))))
    (lambda (f target vectors len)
      (loop f target vectors len))))



;;;;;;;;;;;;;;;;;;;;;;;; ***** vector-lib ***** ;;;;;;;;;;;;;;;;;;;;;;;

;;; --------------------
;;; Constructors

;;; (MAKE-VECTOR &lt;size&gt; [&lt;fill&gt;]) -&gt; vector
;;;   [R5RS] Create a vector of length LENGTH.  If FILL is present,
;;;   initialize each slot in the vector with it; if not, the vector's
;;;   initial contents are unspecified.
(define make-vector make-vector)

;;; (VECTOR &lt;elt&gt; ...) -&gt; vector
;;;   [R5RS] Create a vector containing ELEMENT ..., in order.
(define vector vector)

;;; This ought to be able to be implemented much more efficiently -- if
;;; we have the number of arguments available to us, we can create the
;;; vector without using LENGTH to determine the number of elements it
;;; should have.
;(define (vector . elements) (list-&gt;vector elements))

;;; (VECTOR-UNFOLD &lt;f&gt; &lt;length&gt; &lt;initial-seed&gt; ...) -&gt; vector
;;;     (F &lt;index&gt; &lt;seed&gt; ...) -&gt; [elt seed' ...]
;;;   The fundamental vector constructor.  Creates a vector whose
;;;   length is LENGTH and iterates across each index K between 0 and
;;;   LENGTH, applying F at each iteration to the current index and the
;;;   current seeds to receive N+1 values: first, the element to put in
;;;   the Kth slot and then N new seeds for the next iteration.
(define vector-unfold
  (letrec ((tabulate!                   ; Special zero-seed case.
            (lambda (f vec i len)
              (cond ((&lt; i len)
                     (vector-set! vec i (f i))
                     (tabulate! f vec (+ i 1) len)))))
           (unfold1!                    ; Fast path for one seed.
            (lambda (f vec i len seed)
              (if (&lt; i len)
                  (receive (elt new-seed)
                           (f i seed)
                    (vector-set! vec i elt)
                    (unfold1! f vec (+ i 1) len new-seed)))))
           (unfold2+!                   ; Slower variant for N seeds.
            (lambda (f vec i len seeds)
              (if (&lt; i len)
                  (receive (elt . new-seeds)
                           (apply f i seeds)
                    (vector-set! vec i elt)
                    (unfold2+! f vec (+ i 1) len new-seeds))))))
    (lambda (f len . initial-seeds)
      (let ((f   (check-type procedure?  f   vector-unfold))
            (len (check-type nonneg-int? len vector-unfold)))
        (let ((vec (make-vector len)))
          (cond ((null? initial-seeds)
                 (tabulate! f vec 0 len))
                ((null? (cdr initial-seeds))
                 (unfold1! f vec 0 len (car initial-seeds)))
                (else
                 (unfold2+! f vec 0 len initial-seeds)))
          vec)))))

;;; (VECTOR-UNFOLD-RIGHT &lt;f&gt; &lt;length&gt; &lt;initial-seed&gt; ...) -&gt; vector
;;;     (F &lt;seed&gt; ...) -&gt; [seed' ...]
;;;   Like VECTOR-UNFOLD, but it generates elements from LENGTH to 0
;;;   (still exclusive with  LENGTH and inclusive with 0), not 0 to
;;;   LENGTH as with VECTOR-UNFOLD.
(define vector-unfold-right
  (letrec ((tabulate!
            (lambda (f vec i)
              (cond ((&gt;= i 0)
                     (vector-set! vec i (f i))
                     (tabulate! f vec (- i 1))))))
           (unfold1!
            (lambda (f vec i seed)
              (if (&gt;= i 0)
                  (receive (elt new-seed)
                           (f i seed)
                    (vector-set! vec i elt)
                    (unfold1! f vec (- i 1) new-seed)))))
           (unfold2+!
            (lambda (f vec i seeds)
              (if (&gt;= i 0)
                  (receive (elt . new-seeds)
                           (apply f i seeds)
                    (vector-set! vec i elt)
                    (unfold2+! f vec (- i 1) new-seeds))))))
    (lambda (f len . initial-seeds)
      (let ((f   (check-type procedure?  f   vector-unfold-right))
            (len (check-type nonneg-int? len vector-unfold-right)))
        (let ((vec (make-vector len))
              (i (- len 1)))
          (cond ((null? initial-seeds)
                 (tabulate! f vec i))
                ((null? (cdr initial-seeds))
                 (unfold1!  f vec i (car initial-seeds)))
                (else
                 (unfold2+! f vec i initial-seeds)))
          vec)))))

;++ Flush VECTOR-TABULATE: it's superseded by VECTOR-UNFOLD.

;;; (VECTOR-TABULATE &lt;f&gt; &lt;length&gt;) -&gt; vector
;;;     (F &lt;index&gt;)
;;;   Create a vector whose length is LENGTH.  Initialize it with the
;;;   results of (f INDEX) for every INDEX in the resulting vector.
;;;   The order of applications of F is unspecified.
;++(define (vector-tabulate f len)
;++  (check-type procedure? f vector-tabulate)
;++  (check-type nonneg-int? len vector-tabulate)
;++  (let ((new-vector (make-vector len)))
;++    (do ((i 0 (+ i 1)))
;++        ((= i len) new-vector)
;++      (vector-set! new-vector i (f i)))))

;;; (VECTOR-COPY &lt;vector&gt; [&lt;start&gt; &lt;end&gt; &lt;fill&gt;]) -&gt; vector
;;;   Create a newly allocated vector containing the elements from the
;;;   range [START,END) in VECTOR.  START defaults to 0; END defaults
;;;   to the length of VECTOR.  END may be greater than the length of
;;;   VECTOR, in which case the vector is enlarged; if FILL is passed,
;;;   the new locations from which there is no respective element in
;;;   VECTOR are filled with FILL.
(define (vector-copy vec . args)
  (let ((vec (check-type vector? vec vector-copy)))
    ;; We can't use LET-VECTOR-START+END, because we have one more
    ;; argument, and we want finer control, too.
    ;;
    ;; Olin's implementation of LET*-OPTIONALS would prove useful here:
    ;; the built-in argument-checks-as-you-go-along produces almost
    ;; _exactly_ the same code as VECTOR-COPY:PARSE-ARGS.
    (receive (start end fill)
             (vector-copy:parse-args vec args)
      (let ((new-vector (make-vector (- end start) fill)))
        (%vector-copy! new-vector 0
                       vec        start
                       (if (&gt; end (vector-length vec))
                           (vector-length vec)
                           end))
        new-vector))))

;;; Auxiliary for VECTOR-COPY.
(define (vector-copy:parse-args vec args)
  (if (null? args)
      (values 0 (vector-length vec) (unspecified-value))
      (let ((start (check-index vec (car args) vector-copy)))
        (if (null? (cdr args))
            (values start (vector-length vec) (unspecified-value))
            (let ((end (check-type nonneg-int? (cadr args)
                                   vector-copy)))
              (cond ((&gt;= start (vector-length vec))
                     (error &quot;start bound out of bounds&quot;
                            `(start was ,start)
                            `(end was ,end)
                            `(vector was ,vec)
                            `(while calling ,vector-copy)))
                    ((&gt; start end)
                     (error &quot;can't invert a vector copy!&quot;
                            `(start was ,start)
                            `(end was ,end)
                            `(vector was ,vec)
                            `(while calling ,vector-copy)))
                    ((null? (cddr args))
                     (values start end (unspecified-value)))
                    (else
                     (let ((fill (caddr args)))
                       (if (null? (cdddr args))
                           (values start end fill)
                           (error &quot;too many arguments&quot;
                                  vector-copy
                                  (cdddr args)))))))))))

;;; (VECTOR-REVERSE-COPY &lt;vector&gt; [&lt;start&gt; &lt;end&gt;]) -&gt; vector
;;;   Create a newly allocated vector whose elements are the reversed
;;;   sequence of elements between START and END in VECTOR.  START's
;;;   default is 0; END's default is the length of VECTOR.
(define (vector-reverse-copy vec . maybe-start+end)
  (let-vector-start+end vector-reverse-copy vec maybe-start+end
                        (start end)
    (let ((new (make-vector (- end start))))
      (%vector-reverse-copy! new 0 vec start end)
      new)))

;;; (VECTOR-APPEND &lt;vector&gt; ...) -&gt; vector
;;;   Append VECTOR ... into a newly allocated vector and return that
;;;   new vector.
(define (vector-append . vectors)
  (vector-concatenate:aux vectors vector-append))

;;; (VECTOR-CONCATENATE &lt;vector-list&gt;) -&gt; vector
;;;   Concatenate the vectors in VECTOR-LIST.  This is equivalent to
;;;     (apply vector-append VECTOR-LIST)
;;;   but VECTOR-APPEND tends to be implemented in terms of
;;;   VECTOR-CONCATENATE, and some Schemes bork when the list to apply
;;;   a function to is too long.
;;;
;;; Actually, they're both implemented in terms of an internal routine.
(define (vector-concatenate vector-list)
  (vector-concatenate:aux vector-list vector-concatenate))

;;; Auxiliary for VECTOR-APPEND and VECTOR-CONCATENATE
(define vector-concatenate:aux
  (letrec ((compute-length
            (lambda (vectors len callee)
              (if (null? vectors)
                  len
                  (let ((vec (check-type vector? (car vectors)
                                         callee)))
                    (compute-length (cdr vectors)
                                    (+ (vector-length vec) len)
                                    callee)))))
           (concatenate!
            (lambda (vectors target to)
              (if (null? vectors)
                  target
                  (let* ((vec1 (car vectors))
                         (len (vector-length vec1)))
                    (%vector-copy! target to vec1 0 len)
                    (concatenate! (cdr vectors) target
                                  (+ to len)))))))
    (lambda (vectors callee)
      (cond ((null? vectors)            ;+++
             (make-vector 0))
            ((null? (cdr vectors))      ;+++
             ;; Blech, we still have to allocate a new one.
             (let* ((vec (check-type vector? (car vectors) callee))
                    (len (vector-length vec))
                    (new (make-vector len)))
               (%vector-copy! new 0 vec 0 len)
               new))
            (else
             (let ((new-vector
                    (make-vector (compute-length vectors 0 callee))))
               (concatenate! vectors new-vector 0)
               new-vector))))))



;;; --------------------
;;; Predicates

;;; (VECTOR? &lt;value&gt;) -&gt; boolean
;;;   [R5RS] Return #T if VALUE is a vector and #F if not.
(define vector? vector?)

;;; (VECTOR-EMPTY? &lt;vector&gt;) -&gt; boolean
;;;   Return #T if VECTOR has zero elements in it, i.e. VECTOR's length
;;;   is 0, and #F if not.
(define (vector-empty? vec)
  (let ((vec (check-type vector? vec vector-empty?)))
    (zero? (vector-length vec))))

;;; (VECTOR= &lt;elt=?&gt; &lt;vector&gt; ...) -&gt; boolean
;;;     (ELT=? &lt;value&gt; &lt;value&gt;) -&gt; boolean
;;;   Determine vector equality generalized across element comparators.
;;;   Vectors A and B are equal iff their lengths are the same and for
;;;   each respective elements E_a and E_b (element=? E_a E_b) returns
;;;   a true value.  ELT=? is always applied to two arguments.  Element
;;;   comparison must be consistent wtih EQ?; that is, if (eq? E_a E_b)
;;;   results in a true value, then (ELEMENT=? E_a E_b) must result in a
;;;   true value.  This may be exploited to avoid multiple unnecessary
;;;   element comparisons.  (This implementation does, but does not deal
;;;   with the situation that ELEMENT=? is EQ? to avoid more unnecessary
;;;   comparisons, but I believe this optimization is probably fairly
;;;   insignificant.)
;;;   
;;;   If the number of vector arguments is zero or one, then #T is
;;;   automatically returned.  If there are N vector arguments,
;;;   VECTOR_1 VECTOR_2 ... VECTOR_N, then VECTOR_1 &amp; VECTOR_2 are
;;;   compared; if they are equal, the vectors VECTOR_2 ... VECTOR_N
;;;   are compared.  The precise order in which ELT=? is applied is not
;;;   specified.
(define (vector= elt=? . vectors)
  (let ((elt=? (check-type procedure? elt=? vector=)))
    (cond ((null? vectors)
           #t)
          ((null? (cdr vectors))
           (check-type vector? (car vectors) vector=)
           #t)
          (else
           (let loop ((vecs vectors))
             (let ((vec1 (check-type vector? (car vecs) vector=))
                   (vec2+ (cdr vecs)))
               (or (null? vec2+)
                   (and (binary-vector= elt=? vec1 (car vec2+))
                        (loop vec2+)))))))))
(define (binary-vector= elt=? vector-a vector-b)
  (or (eq? vector-a vector-b)           ;+++
      (let ((length-a (vector-length vector-a))
            (length-b (vector-length vector-b)))
        (letrec ((loop (lambda (i)
                         (or (= i length-a)
                             (and (&lt; i length-b)
                                  (test (vector-ref vector-a i)
                                        (vector-ref vector-b i)
                                        i)))))
                 (test (lambda (elt-a elt-b i)
                         (and (or (eq? elt-a elt-b) ;+++
                                  (elt=? elt-a elt-b))
                              (loop (+ i 1))))))
          (and (= length-a length-b)
               (loop 0))))))



;;; --------------------
;;; Selectors

;;; (VECTOR-REF &lt;vector&gt; &lt;index&gt;) -&gt; value
;;;   [R5RS] Return the value that the location in VECTOR at INDEX is
;;;   mapped to in the store.
(define vector-ref vector-ref)

;;; (VECTOR-LENGTH &lt;vector&gt;) -&gt; exact, nonnegative integer
;;;   [R5RS] Return the length of VECTOR.
(define vector-length vector-length)



;;; --------------------
;;; Iteration

;;; (VECTOR-FOLD &lt;kons&gt; &lt;initial-knil&gt; &lt;vector&gt; ...) -&gt; knil
;;;     (KONS &lt;knil&gt; &lt;elt&gt; ...) -&gt; knil' ; N vectors -&gt; N+1 args
;;;   The fundamental vector iterator.  KONS is iterated over each
;;;   index in all of the vectors in parallel, stopping at the end of
;;;   the shortest; KONS is applied to an argument list of (list I
;;;   STATE (vector-ref VEC I) ...), where STATE is the current state
;;;   value -- the state value begins with KNIL and becomes whatever
;;;   KONS returned at the respective iteration --, and I is the
;;;   current index in the iteration.  The iteration is strictly left-
;;;   to-right.
;;;     (vector-fold KONS KNIL (vector E_1 E_2 ... E_N))
;;;       &lt;=&gt;
;;;     (KONS (... (KONS (KONS KNIL E_1) E_2) ... E_N-1) E_N)
(define (vector-fold kons knil vec . vectors)
  (let ((kons (check-type procedure? kons vector-fold))
        (vec  (check-type vector?    vec  vector-fold)))
    (if (null? vectors)
        (%vector-fold1 kons knil (vector-length vec) vec)
        (%vector-fold2+ kons knil
                        (%smallest-length vectors
                                          (vector-length vec)
                                          vector-fold)
                        (cons vec vectors)))))

;;; (VECTOR-FOLD-RIGHT &lt;kons&gt; &lt;initial-knil&gt; &lt;vector&gt; ...) -&gt; knil
;;;     (KONS &lt;knil&gt; &lt;elt&gt; ...) -&gt; knil' ; N vectors =&gt; N+1 args
;;;   The fundamental vector recursor.  Iterates in parallel across
;;;   VECTOR ... right to left, applying KONS to the elements and the
;;;   current state value; the state value becomes what KONS returns
;;;   at each next iteration.  KNIL is the initial state value.
;;;     (vector-fold-right KONS KNIL (vector E_1 E_2 ... E_N))
;;;       &lt;=&gt;
;;;     (KONS (... (KONS (KONS KNIL E_N) E_N-1) ... E_2) E_1)
;;;
;;; Not implemented in terms of a more primitive operations that might
;;; called %VECTOR-FOLD-RIGHT due to the fact that it wouldn't be very
;;; useful elsewhere.
(define vector-fold-right
  (letrec ((loop1 (lambda (kons knil vec i)
                    (if (negative? i)
                        knil
                        (loop1 kons (kons i knil (vector-ref vec i))
                               vec
                               (+ i 1)))))
           (loop2+ (lambda (kons knil vectors i)
                     (if (negative? i)
                         knil
                         (loop2+ kons
                                 (apply kons i knil
                                        (vectors-ref vectors i))
                                 vectors
                                 (+ i 1))))))
    (lambda (kons knil vec . vectors)
      (let ((kons (check-type procedure? kons vector-fold-right))
            (vec  (check-type vector?    vec  vector-fold-right)))
        (if (null? vectors)
            (loop1  kons knil vec (- (vector-length vec) 1))
            (loop2+ kons knil (cons vec vectors)
                    (- (%smallest-length vectors
                                         (vector-length vec)
                                         vector-fold-right)
                       1)))))))

;;; (VECTOR-MAP &lt;f&gt; &lt;vector&gt; ...) -&gt; vector
;;;     (F &lt;elt&gt; ...) -&gt; value ; N vectors -&gt; N args
;;;   Constructs a new vector of the shortest length of the vector
;;;   arguments.  Each element at index I of the new vector is mapped
;;;   from the old vectors by (F I (vector-ref VECTOR I) ...).  The
;;;   dynamic order of application of F is unspecified.
(define (vector-map f vec . vectors)
  (let ((f   (check-type procedure? f   vector-map))
        (vec (check-type vector?    vec vector-map)))
    (if (null? vectors)
        (let ((len (vector-length vec)))
          (%vector-map1! f (make-vector len) vec len))
        (let ((len (%smallest-length vectors
                                     (vector-length vec)
                                     vector-map)))
          (%vector-map2+! f (make-vector len) vectors len)))))

;;; (VECTOR-MAP! &lt;f&gt; &lt;vector&gt; ...) -&gt; unspecified
;;;     (F &lt;elt&gt; ...) -&gt; element' ; N vectors -&gt; N args
;;;   Similar to VECTOR-MAP, but rather than mapping the new elements
;;;   into a new vector, the new mapped elements are destructively
;;;   inserted into the first vector.  Again, the dynamic order of
;;;   application of F is unspecified, so it is dangerous for F to
;;;   manipulate the first VECTOR.
(define (vector-map! f vec . vectors)
  (let ((f   (check-type procedure? f   vector-map!))
        (vec (check-type vector?    vec vector-map!)))
    (if (null? vectors)
        (%vector-map1!  f vec vec (vector-length vec))
        (%vector-map2+! f vec (cons vec vectors)
                        (%smallest-length vectors
                                          (vector-length vec)
                                          vector-map!)))
    (unspecified-value)))

;;; (VECTOR-FOR-EACH &lt;f&gt; &lt;vector&gt; ...) -&gt; unspecified
;;;     (F &lt;elt&gt; ...) ; N vectors -&gt; N args
;;;   Simple vector iterator: applies F to each index in the range [0,
;;;   LENGTH), where LENGTH is the length of the smallest vector
;;;   argument passed, and the respective element at that index.  In
;;;   contrast with VECTOR-MAP, F is reliably applied to each
;;;   subsequent elements, starting at index 0 from left to right, in
;;;   the vectors.
(define vector-for-each
  (letrec ((for-each1
            (lambda (f vec i len)
              (cond ((&lt; i len)
                     (f i (vector-ref vec i))
                     (for-each1 f vec (+ i 1) len)))))
           (for-each2+
            (lambda (f vecs i len)
              (cond ((&lt; i len)
                     (apply f i (vectors-ref vecs i))
                     (for-each2+ f vecs (+ i 1) len))))))
    (lambda (f vec . vectors)
      (let ((f   (check-type procedure? f   vector-for-each))
            (vec (check-type vector?    vec vector-for-each)))
        (if (null? vectors)
            (for-each1 f vec 0 (vector-length vec))
            (for-each2+ f (cons vec vectors) 0
                        (%smallest-length vectors
                                          (vector-length vec)
                                          vector-for-each)))))))

;;; (VECTOR-COUNT &lt;predicate?&gt; &lt;vector&gt; ...)
;;;       -&gt; exact, nonnegative integer
;;;     (PREDICATE? &lt;index&gt; &lt;value&gt; ...) ; N vectors -&gt; N+1 args
;;;   PREDICATE? is applied element-wise to the elements of VECTOR ...,
;;;   and a count is tallied of the number of elements for which a
;;;   true value is produced by PREDICATE?.  This count is returned.
(define (vector-count pred? vec . vectors)
  (let ((pred? (check-type procedure? pred? vector-count))
        (vec   (check-type vector?    vec   vector-count)))
    (if (null? vectors)
        (%vector-fold1 (lambda (index count elt)
                         (if (pred? index elt)
                             (+ count 1)
                             count))
                       0
                       (vector-length vec)
                       vec)
        (%vector-fold2+ (lambda (index count . elts)
                          (if (apply pred? index elts)
                              (+ count 1)
                              count))
                        0
                        (%smallest-length vectors
                                          (vector-length vec)
                                          vector-count)
                        (cons vec vectors)))))



;;; --------------------
;;; Searching

;;; (VECTOR-INDEX &lt;predicate?&gt; &lt;vector&gt; ...)
;;;       -&gt; exact, nonnegative integer or #F
;;;     (PREDICATE? &lt;elt&gt; ...) -&gt; boolean ; N vectors -&gt; N args
;;;   Search left-to-right across VECTOR ... in parallel, returning the
;;;   index of the first set of values VALUE ... such that (PREDICATE?
;;;   VALUE ...) returns a true value; if no such set of elements is
;;;   reached, return #F.
(define (vector-index pred? vec . vectors)
  (vector-index/skip pred? vec vectors vector-index))

;;; (VECTOR-SKIP &lt;predicate?&gt; &lt;vector&gt; ...)
;;;       -&gt; exact, nonnegative integer or #F
;;;     (PREDICATE? &lt;elt&gt; ...) -&gt; boolean ; N vectors -&gt; N args
;;;   (vector-index (lambda elts (not (apply PREDICATE? elts)))
;;;                 VECTOR ...)
;;;   Like VECTOR-INDEX, but find the index of the first set of values
;;;   that do _not_ satisfy PREDICATE?.
(define (vector-skip pred? vec . vectors)
  (vector-index/skip (lambda elts (not (apply pred? elts)))
                     vec vectors
                     vector-skip))

;;; Auxiliary for VECTOR-INDEX &amp; VECTOR-SKIP
(define vector-index/skip
  (letrec ((loop1  (lambda (pred? vec len i)
                     (cond ((= i len) #f)
                           ((pred? (vector-ref vec i)) i)
                           (else (loop1 pred? vec len (+ i 1))))))
           (loop2+ (lambda (pred? vectors len i)
                     (cond ((= i len) #f)
                           ((apply pred? (vectors-ref vectors i)) i)
                           (else (loop2+ pred? vectors len
                                         (+ i 1)))))))
    (lambda (pred? vec vectors callee)
      (let ((pred? (check-type procedure? pred? callee))
            (vec   (check-type vector?    vec   callee)))
        (if (null? vectors)
            (loop1 pred? vec (vector-length vec) 0)
            (loop2+ pred? (cons vec vectors)
                    (%smallest-length vectors
                                      (vector-length vec)
                                      callee)
                    0))))))

;;; (VECTOR-INDEX-RIGHT &lt;predicate?&gt; &lt;vector&gt; ...)
;;;       -&gt; exact, nonnegative integer or #F
;;;     (PREDICATE? &lt;elt&gt; ...) -&gt; boolean ; N vectors -&gt; N args
;;;   Right-to-left variant of VECTOR-INDEX.
(define (vector-index-right pred? vec . vectors)
  (vector-index/skip-right pred? vec vectors vector-index-right))

;;; (VECTOR-SKIP-RIGHT &lt;predicate?&gt; &lt;vector&gt; ...)
;;;       -&gt; exact, nonnegative integer or #F
;;;     (PREDICATE? &lt;elt&gt; ...) -&gt; boolean ; N vectors -&gt; N args
;;;   Right-to-left variant of VECTOR-SKIP.
(define (vector-skip-right pred? vec . vectors)
  (vector-index/skip-right (lambda elts (not (apply pred? elts)))
                           vec vectors
                           vector-index-right))

(define vector-index/skip-right
  (letrec ((loop1  (lambda (pred? vec i)
                     (cond ((negative? i) #f)
                           ((pred? (vector-ref vec i)) i)
                           (else (loop1 pred? vec (- i 1))))))
           (loop2+ (lambda (pred? vectors i)
                     (cond ((negative? i) #f)
                           ((apply pred? (vectors-ref vectors i)) i)
                           (else (loop2+ pred? vectors (- i 1)))))))
    (lambda (pred? vec vectors callee)
      (let ((pred? (check-type procedure? pred? callee))
            (vec   (check-type vector?    vec   callee)))
        (if (null? vectors)
            (loop1 pred? vec (- (vector-length vec) 1))
            (loop2+ pred? (cons vec vectors)
                    (- (%smallest-length vectors
                                         (vector-length vec)
                                         callee)
                       1)))))))

;;; (VECTOR-BINARY-SEARCH &lt;vector&gt; &lt;value&gt; &lt;cmp&gt; [&lt;start&gt; &lt;end&gt;])
;;;       -&gt; exact, nonnegative integer or #F
;;;     (CMP &lt;value1&gt; &lt;value2&gt;) -&gt; integer
;;;       positive -&gt; VALUE1 &gt; VALUE2
;;;       zero     -&gt; VALUE1 = VALUE2
;;;       negative -&gt; VALUE1 &lt; VALUE2
;;;   Perform a binary search through VECTOR for VALUE, comparing each
;;;   element to VALUE with CMP.
(define (vector-binary-search vec value cmp . maybe-start+end)
  (let ((cmp (check-type procedure? cmp vector-binary-search)))
    (let-vector-start+end vector-binary-search vec maybe-start+end
                          (start end)
      (let loop ((start start) (end end) (j #f))
        (let ((i (quotient (+ start end) 2)))
          (if (and j (= i j))
              #f
              (let ((comparison
                     (check-type integer?
                                 (cmp (vector-ref vec i) value)
                                 `(,cmp for ,vector-binary-search))))
                (cond ((zero?     comparison) i)
                      ((positive? comparison) (loop start i i))
                      (else                   (loop i end i))))))))))

;;; (VECTOR-ANY &lt;pred?&gt; &lt;vector&gt; ...) -&gt; value
;;;   Apply PRED? to each parallel element in each VECTOR ...; if PRED?
;;;   should ever return a true value, immediately stop and return that
;;;   value; otherwise, when the shortest vector runs out, return #F.
;;;   The iteration and order of application of PRED? across elements
;;;   is of the vectors is strictly left-to-right.
(define vector-any
  (letrec ((loop1 (lambda (pred? vec i len len-1)
                    (and (not (= i len))
                         (if (= i len-1)
                             (pred? (vector-ref vec i))
                             (or (pred? (vector-ref vec i))
                                 (loop1 pred? vec (+ i 1)
                                        len len-1))))))
           (loop2+ (lambda (pred? vectors i len len-1)
                     (and (not (= i len))
                          (if (= i len-1)
                              (apply pred? (vectors-ref vectors i))
                              (or (apply pred? (vectors-ref vectors i))
                                  (loop2+ pred? vectors (+ i 1)
                                         len len-1)))))))
    (lambda (pred? vec . vectors)
      (let ((pred? (check-type procedure? pred? vector-any))
            (vec   (check-type vector?    vec   vector-any)))
        (if (null? vectors)
            (let ((len (vector-length vec)))
              (loop1 pred? vec 0 len (- len 1)))
            (let ((len (%smallest-length vectors
                                         (vector-length vec)
                                         vector-any)))
              (loop2+ pred? (cons vec vectors) 0 len (- len 1))))))))

;;; (VECTOR-EVERY &lt;pred?&gt; &lt;vector&gt; ...) -&gt; value
;;;   Apply PRED? to each parallel value in each VECTOR ...; if PRED?
;;;   should ever return #F, immediately stop and return #F; otherwise,
;;;   if PRED? should return a true value for each element, stopping at
;;;   the end of the shortest vector, return the last value that PRED?
;;;   returned.  In the case that there is an empty vector, return #T.
;;;   The iteration and order of application of PRED? across elements
;;;   is of the vectors is strictly left-to-right.
(define vector-every
  (letrec ((loop1 (lambda (pred? vec i len len-1)
                    (or (= i len)
                        (if (= i len-1)
                            (pred? (vector-ref vec i))
                            (and (pred? (vector-ref vec i))
                                 (loop1 pred? vec (+ i 1)
                                        len len-1))))))
           (loop2+ (lambda (pred? vectors i len len-1)
                     (or (= i len)
                         (if (= i len-1)
                             (apply pred? (vectors-ref vectors i))
                             (and (apply pred? (vectors-ref vectors i))
                                  (loop2+ pred? vectors (+ i 1)
                                          len len-1)))))))
    (lambda (pred? vec . vectors)
      (let ((pred? (check-type procedure? pred? vector-every))
            (vec   (check-type vector?    vec   vector-every)))
        (if (null? vectors)
            (let ((len (vector-length vec)))
              (loop1 pred? vec 0 len (- len 1)))
            (let ((len (%smallest-length vectors
                                         (vector-length vec)
                                         vector-every)))
              (loop2+ pred? (cons vec vectors) 0 len (- len 1))))))))



;;; --------------------
;;; Mutators

;;; (VECTOR-SET! &lt;vector&gt; &lt;index&gt; &lt;value&gt;) -&gt; unspecified
;;;   [R5RS] Assign the location at INDEX in VECTOR to VALUE.
(define vector-set! vector-set!)

;;; (VECTOR-SWAP! &lt;vector&gt; &lt;index1&gt; &lt;index2&gt;) -&gt; unspecified
;;;   Swap the values in the locations at INDEX1 and INDEX2.
(define (vector-swap! vec i j)
  (let ((vec (check-type vector? vec vector-swap!)))
    (let ((i (check-index vec i vector-swap!))
          (j (check-index vec j vector-swap!)))
      (let ((x (vector-ref vec i)))
        (vector-set! vec i (vector-ref vec j))
        (vector-set! vec j x)))))

;;; (VECTOR-FILL! &lt;vector&gt; &lt;value&gt; [&lt;start&gt; &lt;end&gt;]) -&gt; unspecified
;;;   [R5RS+] Fill the locations in VECTOR between START, whose default
;;;   is 0, and END, whose default is the length of VECTOR, with VALUE.
;;;
;;; This one can probably be made really fast natively.
(define vector-fill!
  (let ((%vector-fill! vector-fill!))   ; Take the native one, under
                                        ;   the assumption that it's
                                        ;   faster, so we can use it if
                                        ;   there are no optional
                                        ;   arguments.
    (lambda (vec value . maybe-start+end)
      (if (null? maybe-start+end)
          (%vector-fill! vec value)     ;+++
          (let-vector-start+end vector-fill! vec maybe-start+end
                                (start end)
            (do ((i start (+ i 1)))
                ((= i end))
              (vector-set! vec i value)))))))

;;; (VECTOR-COPY! &lt;target&gt; &lt;tstart&gt; &lt;source&gt; [&lt;sstart&gt; &lt;send&gt;])
;;;       -&gt; unspecified
;;;   Copy the values in the locations in [SSTART,SEND) from SOURCE to
;;;   to TARGET, starting at TSTART in TARGET.
(define (vector-copy! target tstart source . maybe-sstart+send)
  (let* ((target (check-type vector? target vector-copy!))
         (tstart (check-index target tstart vector-copy!)))
    (let-vector-start+end vector-copy! source maybe-sstart+send
                          (sstart send)
      (let* ((source-length (vector-length source))
             (lose (lambda (argument)
                     (error &quot;vector range out of bounds&quot;
                            argument
                            `(while calling ,vector-copy!)
                            `(target was ,target)
                            `(target-length was ,(vector-length target))
                            `(tstart was ,tstart)
                            `(source was ,source)
                            `(source-length was ,source-length)
                            `(sstart was ,sstart)
                            `(send   was ,send)))))
        (cond ((&lt; sstart 0)
               (lose '(sstart &lt; 0)))
              ((&lt; send 0)
               (lose '(send &lt; 0)))
              ((&gt; sstart send)
               (lose '(sstart &gt; send)))
              ((&gt;= sstart source-length)
               (lose '(sstart &gt;= source-length)))
              ((&gt; send source-length)
               (lose '(send &gt; source-length)))
              (else
               (%vector-copy! target tstart
                              source sstart send)))))))

;;; (VECTOR-REVERSE-COPY! &lt;target&gt; &lt;tstart&gt; &lt;source&gt; [&lt;sstart&gt; &lt;send&gt;])
(define (vector-reverse-copy! target tstart source . maybe-sstart+send)
  (let* ((target (check-type vector? target vector-reverse-copy!))
         (tstart (check-index target tstart vector-reverse-copy!)))
    (let-vector-start+end vector-reverse-copy source maybe-sstart+send
                          (sstart send)
      (let* ((source-length (vector-length source))
             (lose (lambda (argument)
                     (error &quot;vector range out of bounds&quot;
                            argument
                            `(while calling ,vector-reverse-copy!)
                            `(target was ,target)
                            `(target-length was ,(vector-length target))
                            `(tstart was ,tstart)
                            `(source was ,source)
                            `(source-length was ,source-length)
                            `(sstart was ,sstart)
                            `(send   was ,send)))))
        (cond ((&lt; sstart 0)
               (lose '(sstart &lt; 0)))
              ((&lt; send 0)
               (lose '(send &lt; 0)))
              ((&gt; sstart send)
               (lose '(sstart &gt; send)))
              ((&gt;= sstart source-length)
               (lose '(sstart &gt;= source-length)))
              ((&gt; send source-length)
               (lose '(send &gt; source-length)))
              ((and (eq? target source)
                    (= sstart tstart))
               (%vector-reverse! target tstart send))
              ((and (eq? target source)
                    (or (between? sstart tstart send)
                        (between? sstart (+ tstart (- send sstart))
                                  send)))
               (error &quot;vector range for self-copying overlaps&quot;
                      vector-reverse-copy!
                      `(vector was ,target)
                      `(tstart was ,tstart)
                      `(sstart was ,sstart)
                      `(send   was ,send)))
              (else
               (%vector-reverse-copy! target tstart
                                      source sstart send)))))))

;;; (VECTOR-REVERSE! &lt;vector&gt; [&lt;start&gt; &lt;end&gt;]) -&gt; unspecified
;;;   Destructively reverse the contents of the sequence of locations
;;;   in VECTOR between START, whose default is 0, and END, whose
;;;   default is the length of VECTOR.
(define (vector-reverse! vec . start+end)
  (let-vector-start+end vector-reverse! vec start+end
                        (start end)
    (%vector-reverse! vec start end)))



;;; --------------------
;;; Conversion

;;; (VECTOR-&gt;LIST &lt;vector&gt; [&lt;start&gt; &lt;end&gt;]) -&gt; list
;;;   [R5RS+] Produce a list containing the elements in the locations
;;;   between START, whose default is 0, and END, whose default is the
;;;   length of VECTOR, from VECTOR.
(define vector-&gt;list
  (let ((%vector-&gt;list vector-&gt;list))
    (lambda (vec . maybe-start+end)
      (if (null? maybe-start+end)       ; Oughta use CASE-LAMBDA.
          (%vector-&gt;list vec)           ;+++
          (let-vector-start+end vector-&gt;list vec maybe-start+end
                                (start end)
            ;(unfold (lambda (i)        ; No SRFI 1.
            ;          (&lt; i start))
            ;        (lambda (i) (vector-ref vec i))
            ;        (lambda (i) (- i 1))
            ;        (- end 1))
            (do ((i (- end 1) (- i 1))
                 (result '() (cons (vector-ref vec i) result)))
                ((&lt; i start) result)))))))

;;; (REVERSE-VECTOR-&gt;LIST &lt;vector&gt; [&lt;start&gt; &lt;end&gt;]) -&gt; list
;;;   Produce a list containing the elements in the locations between
;;;   START, whose default is 0, and END, whose default is the length
;;;   of VECTOR, from VECTOR, in reverse order.
(define (reverse-vector-&gt;list vec . maybe-start+end)
  (let-vector-start+end reverse-vector-&gt;list vec maybe-start+end
                        (start end)
    ;(unfold (lambda (i) (= i end))     ; No SRFI 1.
    ;        (lambda (i) (vector-ref vec i))
    ;        (lambda (i) (+ i 1))
    ;        start)
    (do ((i start (+ i 1))
         (result '() (cons (vector-ref vec i) result)))
        ((= i end) result))))

;;; (LIST-&gt;VECTOR &lt;list&gt; [&lt;start&gt; &lt;end&gt;]) -&gt; vector
;;;   [R5RS+] Produce a vector containing the elements in LIST, which
;;;   must be a proper list, between START, whose default is 0, &amp; END,
;;;   whose default is the length of LIST.  It is suggested that if the
;;;   length of LIST is known in advance, the START and END arguments
;;;   be passed, so that LIST-&gt;VECTOR need not call LENGTH to determine
;;;   the the length.
;;;
;;; This implementation diverges on circular lists, unless LENGTH fails
;;; and causes - to fail as well.  Given a LENGTH* that computes the
;;; length of a list's cycle, this wouldn't diverge, and would work
;;; great for circular lists.
(define list-&gt;vector
  (let ((%list-&gt;vector list-&gt;vector))
    (lambda (lst . maybe-start+end)
      ;; Checking the type of a proper list is expensive, so we do it
      ;; amortizedly, or let %LIST-&gt;VECTOR or LIST-TAIL do it.
      (if (null? maybe-start+end)       ; Oughta use CASE-LAMBDA.
          (%list-&gt;vector lst)           ;+++
          ;; We can't use LET-VECTOR-START+END, because we're using the
          ;; bounds of a _list_, not a vector.
          (let*-optionals maybe-start+end
              ((start 0)
               (end (length lst)))      ; Ugh -- LENGTH
            (let ((start (check-type nonneg-int? start list-&gt;vector))
                  (end   (check-type nonneg-int? end   list-&gt;vector)))
              ((lambda (f)
                 (vector-unfold f (- end start) lst))
               (lambda (l)
                 (cond ((null? l)
                        (error &quot;list was too short&quot;
                               `(list was ,lst)
                               `(attempted end was ,end)
                               `(while calling ,list-&gt;vector)))
                       ((pair? l)
                        (values (car l) (cdr l)))
                       (else
                        ;; Make this look as much like what CHECK-TYPE
                        ;; would report as possible.
                        (error &quot;erroneous value&quot;
                               ;; We want SRFI 1's PROPER-LIST?, but it
                               ;; would be a waste to link all of SRFI
                               ;; 1 to this module for only the single
                               ;; function PROPER-LIST?.
                               (list list? lst)
                               `(while calling
                                 ,list-&gt;vector))))))))))))

;;; (REVERSE-LIST-&gt;VECTOR &lt;list&gt; [&lt;start&gt; &lt;end&gt;]) -&gt; vector
;;;   Produce a vector containing the elements in LIST, which must be a
;;;   proper list, between START, whose default is 0, and END, whose
;;;   default is the length of LIST, in reverse order.  It is suggested
;;;   that if the length of LIST is known in advance, the START and END
;;;   arguments be passed, so that REVERSE-LIST-&gt;VECTOR need not call
;;;   LENGTH to determine the the length.
;;;
;;; This also diverges on circular lists unless, again, LENGTH returns
;;; something that makes - bork.
(define (reverse-list-&gt;vector lst . maybe-start+end)
  (let*-optionals maybe-start+end
      ((start 0)
       (end (length lst)))              ; Ugh -- LENGTH
    (let ((start (check-type nonneg-int? start reverse-list-&gt;vector))
          (end   (check-type nonneg-int? end   reverse-list-&gt;vector)))
      ((lambda (f)
         (vector-unfold-right f (- end start) lst))
       (lambda (index l)
         (cond ((null? l)
                (error &quot;list too short&quot;
                       `(list was ,lst)
                       `(attempted end was ,end)
                       `(while calling ,reverse-list-&gt;vector)))
               ((pair? l)
                (values (car l) (cdr l)))
               (else
                (error &quot;erroneous value&quot;
                       (list list? lst)
                       `(while calling ,reverse-list-&gt;vector)))))))))
</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00002" href="msg00002.html">Re: SRFI 43 Reference Implementation vector-map bug</a></strong>
<ul><li><em>From:</em> Will M. Farr</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00000.html">Final SRFI 43: Vector library</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00002.html">Re: SRFI 43 Reference Implementation vector-map bug</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00000.html">Final SRFI 43: Vector library</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00002.html">Re: SRFI 43 Reference Implementation vector-map bug</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00001"><strong>Date</strong></a></li>
<li><a href="threads.html#00001"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
