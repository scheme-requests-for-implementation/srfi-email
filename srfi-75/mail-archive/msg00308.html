<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: Issues with Unicode -->
<!--X-From-R13: Xbua Qbjna <pbjnaNppvy.bet> -->
<!--X-Date: Sun, 30 Apr 2006 17:44:59 +0200 (MST) -->
<!--X-Message-Id: 20060430154454.GN19498@ccil.org -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: y9lbqushdsw.fsf@informatik.uni&#45;tuebingen.de -->
<!--X-Reference: 20060423162334.GC25909@ccil.org -->
<!--X-Reference: 1146361526.21841.103.camel@vmx.eros&#45;os.org -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: Issues with Unicode</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00307.html">Date Prev</a>][<a href="msg00309.html">Date Next</a>][<a href="msg00303.html">Thread Prev</a>][<a href="msg00304.html">Thread Next</a>][<a href="maillist.html#00308">Date Index</a>][<a href="threads.html#00308">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: Issues with Unicode</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: &quot;Jonathan S. Shapiro&quot; &lt;<a href="mailto:shap@DOMAIN.HIDDEN">shap@xxxxxxxxxxx</a>&gt;</li>
<li><em>Subject</em>: Re: Issues with Unicode</li>
<li><em>From</em>: John Cowan &lt;<a href="mailto:cowan@DOMAIN.HIDDEN">cowan@xxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Sun, 30 Apr 2006 11:44:54 -0400</li>
<li><em>Cc</em>: <a href="mailto:srfi-75@DOMAIN.HIDDEN">srfi-75@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-75@DOMAIN.HIDDEN">srfi-75@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:1146361526.21841.103.camel@DOMAIN.HIDDEN">1146361526.21841.103.camel@xxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>References</em>: &lt;<a href="mailto:y9lbqushdsw.fsf@DOMAIN.HIDDEN">y9lbqushdsw.fsf@xxxxxxxxxxxxxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20060423162334.GC25909@DOMAIN.HIDDEN">20060423162334.GC25909@xxxxxxxx</a>&gt; &lt;<a href="mailto:1146361526.21841.103.camel@DOMAIN.HIDDEN">1146361526.21841.103.camel@xxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>User-agent</em>: Mutt/1.3.28i</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>[Note:  Due to a typo, Shapiro's response to me was not forwarded to
the srfi-75 mailing list.  I have therefore included it in full
below, as well as an unusually full response.]

Jonathan S. Shapiro scripsit:

&gt; On Sun, 2006-04-23 at 12:23 -0400, John Cowan wrote:
&gt; 
&gt; &gt; &gt; 4. In considering what to do about identifiers, I concluded that the
&gt; &gt; &gt; problem should be divided into &quot;first characters&quot; and &quot;follow
&gt; &gt; &gt; characters&quot;. This aligned things nicely with the existing Unicode
&gt; &gt; &gt; identifier model, and it was sufficient to then add a few punctuation
&gt; &gt; &gt; characters to the legal set. The set of additional characters was taken
&gt; &gt; &gt; from the Common LISP standard, but it should not be hard to adapt it to
&gt; &gt; &gt; scheme.
&gt; &gt; 
&gt; &gt; IMHO this is over-conservative, and prevents us from exploiting the weath
&gt; &gt; of mathematical operators and symbols in the standard.  Having wrestled
&gt; &gt; with this issue in drafting XML 1.1, I now firmly believe that identifiers
&gt; &gt; should be defined inclusively, not exclusively, in the Lisp family.
&gt; &gt; See the discussion on p. 132 of the Unicode Standard version 4.0
&gt; &gt; (online at <a  rel="nofollow" href="http://www.unicode.org/versions/Unicode4.0.0/ch05.pdf">http://www.unicode.org/versions/Unicode4.0.0/ch05.pdf</a> ).
&gt; 
&gt; I do not understand this point. Let us talk about a concrete case: the
&gt; BitC identifier specification, which can be found at:
&gt; 
&gt;   <a  rel="nofollow" href="http://www.coyotos.org/docs/bitc/spec.html#2.2">http://www.coyotos.org/docs/bitc/spec.html#2.2</a>
&gt; 
&gt; The list of ``extended alphabetic characters''  might be different for
&gt; Scheme, but you seem to imply that this approach is inappropriate in
&gt; general. After reading that subsection, can you say what issues this
&gt; approach does not address?

I'll quote
<a  rel="nofollow" href="http://www.unicode.org/reports/tr31/#Alternative_Identifier_Syntax">http://www.unicode.org/reports/tr31/#Alternative_Identifier_Syntax</a> ,
which does a better job than I can:

        The disadvantage of working with the syntactic classes defined
        above is the storage space needed for the detailed definitions,
        plus the fact that with each new version of the Unicode Standard
        new characters are added, which an existing parser would not be
        able to recognize. In other words, the recommendations based on
        that table are not upwardly compatible.

        This problem can be addressed by turning the question
        around. Instead of defining the set of code points that are
        allowed, define a small, fixed set of code points that are
        reserved for syntactic use and allow everything else (including
        unassigned code points) as part of an identifier. All parsers
        written to this specification would behave the same way for all
        versions of the Unicode Standard, because the classification of
        code points is fixed forever.

        The drawback of this method is that it allows ``nonsense''
        to be part of identifiers because the concerns of lexical
        classification and of human intelligibility are separated. Human
        intelligibility can, however, be addressed by other means, such
        as usage guidelines that encourage a restriction to meaningful
        terms for identifiers. For an example of such guidelines, see
        the XML 1.1 specification by the W3C [XML1.1].

        By increasing the set of disallowed characters, a reasonably
        intuitive recommendation for identifiers can be achieved. This
        approach uses the full specification of identifier classes, as
        of a particular version of the Unicode Standard, and permanently
        disallows any characters not recommended in that version for
        inclusion in identifiers. All code points unassigned as of that
        version would be allowed in identifiers, so that any future
        additions to the standard would already be accounted for. This
        approach ensures both upwardly compatible identifier stability
        and a reasonable division of characters into those that do and
        do not make human sense as part of identifiers.

        Some additional extensions to the list of disallowed code points
        can be made to further constrain ``unnatural'' identifiers. For
        example, one could include unassigned code points in blocks of
        characters set aside for future encoding as symbols, such as
        mathematical operators.

        With or without such fine-tuning, such a compromise approach
        still incurs the expense of implementing large lists of code
        points. While they no longer change over time, it is a matter
        of choice whether the benefit of enforcing somewhat word-like
        identifiers justifies their cost.

        Alternatively, one can use the properties described below,
        and allow all sequences of characters to be identifiers that
        are neither pattern syntax nor pattern whitespace. This has the
        advantage of simplicity and small tables, but allows many more
        ``unnatural'' identifiers.

        R2      Alternative Identifiers

                To meet this requirement, an implementation shall define
                identifiers to be any string of characters that contains
                neither Pattern_White_Space nor Pattern_Syntax characters.

                Or, it shall declare that it uses a modification, and
                provide a precise list of characters that are added
                to or removed from the sets of code points defined by
                these properties.

&gt; I believe that the specified &quot;extended identifier characters&quot; cover the
&gt; &quot;wealth of mathematical operators&quot;. If not, then by all means expand it
&gt; further, but do so in specific form.

Well, if we look at Pattern_Syntax, we see that about 2760 characters
are permanently banned from use inside identifiers, including several
codepoint ranges where UTC can add additional characters of this type.
All the other non-whitespace Unicode characters become thus usable
in identifiers.  This list is far too long to discuss in detail,
but one can point to some obvious cases.

For example, why should U+003D EQUALS SIGN be permitted but U+2260
NOT EQUAL TO be forbidden?  Why should we write &quot;forall&quot; rather than
U+2200 FORALL, the inverted &quot;A&quot;?  What's wrong with U+22D9 VERY MUCH
GREATER THAN rather than &quot;&gt;&gt;&quot;?  Consider the ceiling and floor
operators.  Consider the APL symbols with their well-known APL
meanings.  Consider the arrows.  Consider the proper signs for
logical AND and OR.  Consider the diamond and square used in
modal logic for possibility and necessity.  I could go on for
a long, long time.

These characters are probably irrelevant to languages that make
hard distinctions between &quot;operators&quot; and &quot;identifiers&quot;, but Lispy
languages have always used the same space for both.

&gt; &gt; &gt;   1. It seems unlikely that the unicode character set is done
&gt; &gt; &gt;      growing. This suggests that the code point embedding in strings
&gt; &gt; &gt;      wants to be delimited.
&gt; &gt; 
&gt; &gt; Care to put your money where your mouth is?  Henry Thompson of the W3C
&gt; &gt; incautiously bet me back in 2001 that within five years Unicode would
&gt; &gt; have exceeded its architectural maximum of 17*65536 = 1,114,112 scalar
&gt; &gt; values.  He's already conceded.
&gt; 
&gt; Yes.

Okay.  Name a price, a date, and (if you like) a third party to hold
the money.  &quot;I'm a poor man, your Majesty&quot;, so I'll set an upper
limit of US$100.

&gt; Please re-read my statement: &quot;It seems *unlikely* that the unicode
&gt; character set is done growing.&quot; Therefore, character code points should
&gt; be delimited. I chose #\{U+xxx.xxx}. The important points are (1) some
&gt; unambiguous bracketing, and (2) some unambiguous human-comprehensible
&gt; indicator that this is intended to be taken as a Unicode code point.
&gt; Since the textual convention for *writing* Unicode code points seems to
&gt; be (almost universally) &quot;U+xxx..xxx&quot;, I chose to adapt this. It is not
&gt; perfect. It works sufficiently well and is visually distinctive.

I do agree that delimiting Unicode character references is appropriate
(carrying around 6-digit forms all the time is annoying and potentially
confusing), and I have no objection to your particular choice of
delimiters, only to your rationale.

&gt; &gt; ...Even the Han script, which is
&gt; &gt; already far and away the largest and is even still growing to some
&gt; &gt; extent, isn't going to get us past Plane 3.  No, until we meet the
&gt; &gt; Galactic Empire, Unicode's current architecture is secure.
&gt; 
&gt; I recall similar arguments about 16 bit address spaces. The delimiters
&gt; resolve both a mechanical and a human parse ambiguity. They do no harm,
&gt; and they may serve to protect us in future.

Comparisons to address spaces are irrelevant.  See
<a  rel="nofollow" href="http://recycledknowledge.blogspot.com/2005/08/unicode-is-big-enough.html">http://recycledknowledge.blogspot.com/2005/08/unicode-is-big-enough.html</a>
for more on this point.

&gt; &gt; &gt; 9. Once you have a variable-length character representation, it becomes
&gt; &gt; &gt; necessary to incorporate separate means for reading bytes from input
&gt; &gt; &gt; streams. For example this is needed if the programmer wishes to
&gt; &gt; &gt; construct code to process files in (e.g.) UTF-32. This raises a question
&gt; &gt; &gt; about newline canonicalization. My suggestion is that the port's
&gt; &gt; &gt; handling of newlines should be independent of the caller. That is,
&gt; &gt; &gt; read-byte on a text-mode port that would normally convert the input \r\n
&gt; &gt; &gt; to \n should return the byte corresponding to \n. If you want unmangled
&gt; &gt; &gt; bytes, use binary mode input.
&gt; &gt; 
&gt; &gt; The trouble there is that you may want to convert \r\n to \n even if the
&gt; &gt; encoding of the port is UTF-16 or something else not ASCII-compatible;
&gt; &gt; indeed, randomly removing \r bytes (as opposed to characters) will
&gt; &gt; randomly corrupt UTF-16 streams.  Newline handling has to be done
&gt; &gt; after character decoding.
&gt; 
&gt; No. Newline decoding is a policy decision about the *meaning* of the
&gt; newline. The issue is precisely to decide what *is* the character
&gt; decoding.

I think we are talking past each other here.  There is no way in
principle to tell what a newline is until you have decoded the
stream of bytes into characters.  The &quot;t&quot; hack in fopen assumes
that all encodings are upward compatible with ASCII, which turns
out not to be the case.  In addition, we now have five representations
of newline:  CR, LF, CR+LF, NEL (U+0085), LS (U+2028).

&gt; More generally, *any* decision about what constitutes a character
&gt; codepoint constitutes a form of interpretation. Fundamentally, I am
&gt; arguing that there need to be uninterpreted and interpreted ports.
&gt; 
&gt; However distasteful some may find this on purist grounds, it has worked
&gt; well for many years in practice, and no other approach has been advanced
&gt; that can claim this. Indeed, other approaches have been sufficiently
&gt; malformed as to lead to general acceptance of the distinction between
&gt; &quot;text&quot; and &quot;raw&quot; I/O descriptors.

Provided you deal with the fact that UTF-16 and EBCDIC and other
non-ASCII-compatible encodings cannot be used over &quot;text&quot;
I/O descriptors, this is fine.

&gt; &gt; &gt; 13. Because the Unicode specification is updated and corrected, it is
&gt; &gt; &gt; necessary for the Scheme standard to specify a version.
&gt; &gt; 
&gt; &gt; I disagree.  Almost all the changes are upward compatible, and by careful
&gt; &gt; wording it is possible to avoid those areas where non-upward-compatible
&gt; &gt; changes are possible...
&gt; 
&gt; If you can find a wording that satisfies this objective, I shall be
&gt; happy to adopt it for BitC as well. I considered the matter (though not
&gt; exhaustively), and could not find such a wording.
&gt; 
&gt; For example, various &quot;upwards compatible&quot; corrections have added
&gt; characters to the set of legal identifier characters. This poses a
&gt; problem: if your implementation of Scheme accepts Unicode 4.1 plus
&gt; corrections a+b+c, and my implementation accepts Unicode 4.1, then there
&gt; are well-formed programs that your system will accept and my system will
&gt; not. This is exactly the sort of problem that compatibility seeks to
&gt; preempt.

The method explained above was designed to bypass this problem.
With it, whatever is not forbidden is permitted.

&gt; I do not propose that we should inhibit implementations from adopting
&gt; upward-compatible corrections to Unicode. Rather, I propose that we
&gt; should state the *least* version of Unicode that a compliant system must
&gt; accept, and further that we encourage implementations (or some external
&gt; checking program) to provide some checking mode in which they interpret
&gt; compliance strictly, in order to ensure that a developer can check the
&gt; universal acceptance compliance of their programs.

I have no problem with that.

&gt; shap

-- 
John Cowan  cowan@xxxxxxxx  <a  rel="nofollow" href="http://ccil.org/~cowan">http://ccil.org/~cowan</a>
In the sciences, we are now uniquely privileged to sit side by side
with the giants on whose shoulders we stand.
        --Gerald Holton

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00298" href="msg00298.html">Issues with Unicode</a></strong>
<ul><li><em>From:</em> Jonathan S. Shapiro</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00307.html">Re: Issues with Unicode</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00309.html">Re: Why are byte ports &quot;ports&quot; as such?</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00303.html">Re: Issues with Unicode</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00304.html">Re: Issues with Unicode</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00308"><strong>Date</strong></a></li>
<li><a href="threads.html#00308"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
