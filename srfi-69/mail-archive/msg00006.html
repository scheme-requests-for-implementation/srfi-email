<!-- MHonArc v2.6.15 -->
<!--X-Subject: various remarks -->
<!--X-From-R13: Eronfgvna Stare <fronfgvna.rtareNcuvyvcf.pbz> -->
<!--X-Date: Tue, 26 Apr 2005 11:28:54 +0200 (MST) -->
<!--X-Message-Id: OF66736782.6E44A2B5&#45;ONC1256FEF.00276E38&#45;C1256FEF.0034148D@philips.com -->
<!--X-Content-Type: multipart/alternative -->
<!--X-Reference: 8P_ZgC.A.6iD.KrWbCB@rotkohl -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>various remarks</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00005.html">Date Prev</a>][<a href="msg00007.html">Date Next</a>][<a href="msg00004.html">Thread Prev</a>][<a href="msg00008.html">Thread Next</a>][<a href="maillist.html#00006">Date Index</a>][<a href="threads.html#00006">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>various remarks</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-69">SRFI 69</a> from before July 7th, 2015.  The new archives for SRFI 69 are <a href="http://srfi-email.schemers.org/srfi-69/">here</a>.  The new archives contain all messages, not just those from before July 7th, 2015.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: <a href="mailto:srfi-69@DOMAIN.HIDDEN">srfi-69@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Subject</em>: various remarks</li>
<li><em>From</em>: Sebastian Egner &lt;<a href="mailto:sebastian.egner@DOMAIN.HIDDEN">sebastian.egner@xxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Tue, 26 Apr 2005 11:27:58 +0200</li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-69@DOMAIN.HIDDEN">srfi-69@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:8P_ZgC.A.6iD.KrWbCB@DOMAIN.HIDDEN">8P_ZgC.A.6iD.KrWbCB@rotkohl</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->

<br><font size=2 face="sans-serif">Nice work! If accepted this might increase
portability a lot and</font>
<br><font size=2 face="sans-serif">I am impatient to write (require &quot;srfi-69&quot;)
for the first time.</font>
<br>
<br><font size=2 face="sans-serif">A few remarks on the gory details:</font>
<br>
<br><font size=2 face="sans-serif">* You specify that hash-table-keys and
hash-table-values do not</font>
<br><font size=2 face="sans-serif">necessarily produce the elements in
the same order. That sounds </font>
<br><font size=2 face="sans-serif">highly dangerous to me, and it is not
clear to me what the gain is.</font>
<br>
<br><font size=2 face="sans-serif">In fact it would be reason for me to
forget about -keys and -values</font>
<br><font size=2 face="sans-serif">and fall back on -fold (like you do
in the reference implementation)</font>
<br><font size=2 face="sans-serif">to avoid introducing an error that will
be potentially very hard to find.</font>
<br><font size=2 face="sans-serif">Are there any relevant hash table implementations
that are a lot faster</font>
<br><font size=2 face="sans-serif">and enumerate keys and values in differing
order?</font>
<br>
<br><font size=2 face="sans-serif">* In view of confusion with SRFI-67
(compare procedures), would</font>
<br><font size=2 face="sans-serif">you consider renaming &quot;comparison&quot;
into something that refers more</font>
<br><font size=2 face="sans-serif">to an equivalence relation than to a
general comparison? One could</font>
<br><font size=2 face="sans-serif">simply call the parameter &lt;i&gt;equal&lt;/i&gt;
with default &lt;code&gt;equal?&lt;/code&gt;.</font>
<br>
<br><font size=2 face="sans-serif">* I also second Neil's proposal to abandon
the aliases.</font>
<br>
<br><font size=2 face="sans-serif">Of course this is a matter of personal
preference, but I can relate</font>
<br><font size=2 face="sans-serif">my own development with aliases: In
Ruby, Matz introduced lots of </font>
<br><font size=2 face="sans-serif">aliases in the built-in classes. At
first that seemed quite useful, but the more</font>
<br><font size=2 face="sans-serif">I used it the less I liked it. In the
end, I always pick one (e.g. either get or ref)</font>
<br><font size=2 face="sans-serif">and forget the other---when somebody
else uses the other, I need</font>
<br><font size=2 face="sans-serif">to consult the documentation to make
sure it's really the same thing and</font>
<br><font size=2 face="sans-serif">its not clear what is won by the aliases.
(Btw, I would go for ref, set!, and delete!)</font>
<br>
<br><font size=2 face="sans-serif">* In the SRFIs I wrote in the past,
I tried hard to stay clear of identifiers that </font>
<br><font size=2 face="sans-serif">are used in the major Scheme implementations.
This supports implementors</font>
<br><font size=2 face="sans-serif">in integrating the new proposal into
their system without conflict, even</font>
<br><font size=2 face="sans-serif">if the functionality could supersede
what they have already. This is</font>
<br><font size=2 face="sans-serif">important because mature systems should
not change abruptly.</font>
<br><font size=2 face="sans-serif">&nbsp; &nbsp;Of course, for your SRFI
this is really hard because most names</font>
<br><font size=2 face="sans-serif">might be in use already---but anyway.</font>
<br>
<br><font size=2 face="sans-serif">* You require &quot;This operation should
have an (amortised) complexity</font>
<br><font size=2 face="sans-serif">of O(1) with respect to the number of
associations in <i>hash-table.</i>&quot;</font>
<br><font size=2 face="sans-serif">You might want to emphasize that this
is conditional to a good hash</font>
<br><font size=2 face="sans-serif">function being used.</font>
<br>
<br><font size=2 face="sans-serif">* Something more of an experimental
feature: My problem with hashing</font>
<br><font size=2 face="sans-serif">in practice is that it is often surprisingly
difficult to come up with a good</font>
<br><font size=2 face="sans-serif">hash function for a new data structure.
Would it be possible to provide</font>
<br><font size=2 face="sans-serif">some help with this? </font>
<br>
<br><font size=2 face="sans-serif">One way to do this is a set of procedures
and macros that construct new</font>
<br><font size=2 face="sans-serif">hash functions from old ones: Whenever
several hash values are to be</font>
<br><font size=2 face="sans-serif">combined, they are 'hashed together'
in a deterministic but distributing way.</font>
<br>
<br><font size=2 face="sans-serif">* You might want to rethink your design
for the interaction between /hash/</font>
<br><font size=2 face="sans-serif">and /bound/. The problem is this:</font>
<br>
<br><font size=2 face="sans-serif">A standard way to combine hash functions
h_1, .., h_n is to evaluate a</font>
<br><font size=2 face="sans-serif">modular polynomial, i.e. h(x) = Sum[h_i(x)
a^i : i in {1..n}] mod m, where </font>
<br><font size=2 face="sans-serif">m is /bound/, and a is a number in {0..m-1}
such that 1, a, a^2, etc. runs</font>
<br><font size=2 face="sans-serif">through all elements of {1..m-1}.</font>
<br>
<br><font size=2 face="sans-serif">Now in your design the hash function
must work for all values of /bound/,</font>
<br><font size=2 face="sans-serif">because /bound/ is chosen by the hash
table and passed to the hash</font>
<br><font size=2 face="sans-serif">function. This is a problem, because
the modular polynomial method</font>
<br><font size=2 face="sans-serif">only works for *some* values of m, namely
those for which a suitable a</font>
<br><font size=2 face="sans-serif">exists. (The first failure is m = 8.)
If the modular polynomial method gets</font>
<br><font size=2 face="sans-serif">used anyway, this is what happens: The
numbers m for which it works </font>
<br><font size=2 face="sans-serif">are low in density (e.g. it works 14888
times for m in {1..10^5}), and if a</font>
<br><font size=2 face="sans-serif">bad m is picked then the hash distribution
is certainly terrible because</font>
<br><font size=2 face="sans-serif">the number of unused hash values is
at least 50%. (The mathematical</font>
<br><font size=2 face="sans-serif">reason is that {1, a, a^2, ..} is a
a proper subgroup of (Z/m*Z)^x and by</font>
<br><font size=2 face="sans-serif">that it is at most (m-1)/2 in size.)</font>
<br>
<br><font size=2 face="sans-serif">As you see, the fact that /bound/ is
an argument to the hash function</font>
<br><font size=2 face="sans-serif">makes it difficult to combine hash functions,
because hash functions</font>
<br><font size=2 face="sans-serif">must work for all values of /bound/---which
is considerably more difficult</font>
<br><font size=2 face="sans-serif">than working for some value of /bound/.</font>
<br>
<br><font size=2 face="sans-serif">For this reason, libraries for hash
tables often use a different approach:</font>
<br><font size=2 face="sans-serif">The hash function always returns a result
in {0..hash-range - 1}, where </font>
<br><font size=2 face="sans-serif">hash-range is a predefined constant,
usually a prime close to but not </font>
<br><font size=2 face="sans-serif">exceeding the maximal immediate integer.
It is then up to hash-ref etc.</font>
<br><font size=2 face="sans-serif">to map a hash value h in {0..hash-range
- 1} into the index range of the</font>
<br><font size=2 face="sans-serif">table at hand---which can then be done
by (h mod n), n = table-size.</font>
<br><font size=2 face="sans-serif">If the implementation only allocates
tables of size a power of two, this </font>
<br><font size=2 face="sans-serif">modular reduction can even be done by
masking out the higher bits</font>
<br><font size=2 face="sans-serif">of h.</font>
<br>
<br><font size=2 face="sans-serif">* Currently, there is no way to portably
make a copy of a hash table:</font>
<br><font size=2 face="sans-serif">You cannot query /equal?/ and /hash/,
and there also no hash-table-copy</font>
<br><font size=2 face="sans-serif">either (which by the way, might be good
to add.)</font>
<br>
<br><font size=2 face="sans-serif">* hash-table-count sounds like counting,
but you specify it is O(1).</font>
<br><font size=2 face="sans-serif">How about hash-table-size then?</font>
<br><font size=2 face="sans-serif"><br>
----<br>
Dr. Sebastian Egner<br>
Senior Scientist Channel Coding &amp; Modulation<br>
Philips Research Laboratories<br>
Prof. Holstlaan 4 (WDC 1-051, 1st floor, room 51)<br>
5656 AA Eindhoven<br>
The Netherlands<br>
tel: &nbsp; &nbsp; &nbsp; +31 40 27-43166 &nbsp; *** SINCE 10-Feb-2005
***<br>
fax: &nbsp; &nbsp; &nbsp;+31 40 27-44004<br>
email: sebastian.egner@xxxxxxxxxxx</font>
<br>
<br>
<br>
<table width=100%>
<tr valign=top>
<td>
<td>
<br>
<br>
<br>
<br>
<br><font size=1 face="sans-serif"><b>srfi-69-request@xxxxxxxxxxxxxxxxx</b></font>
<p><font size=1 face="sans-serif">26-04-2005 00:10</font>
<td><font size=1 face="Arial">&nbsp; &nbsp; &nbsp; &nbsp; </font>
<br><font size=1 face="sans-serif">&nbsp; &nbsp; &nbsp; &nbsp; To:
&nbsp; &nbsp; &nbsp; &nbsp;srfi-69@xxxxxxxxxxxxxxxxx</font>
<br><font size=1 face="sans-serif">&nbsp; &nbsp; &nbsp; &nbsp; cc:
&nbsp; &nbsp; &nbsp; &nbsp;(bcc: Sebastian Egner/EHV/RESEARCH/PHILIPS)</font>
<br><font size=1 face="sans-serif">&nbsp; &nbsp; &nbsp; &nbsp; Subject:
&nbsp; &nbsp; &nbsp; &nbsp;provided for compatibility</font>
<p><font size=1 face="sans-serif">&nbsp; &nbsp; &nbsp; &nbsp; Classification:
&nbsp; &nbsp; &nbsp; &nbsp;</font>
<br>
<br></table>
<br>
<br>
<br><font size=2><tt>Regarding the &quot;provided for compatibility&quot;
aliases...<br>
<br>
 &nbsp; &nbsp;hash-table-ref &nbsp; &nbsp; === hash-table-get<br>
 &nbsp; &nbsp;hash-table-set! &nbsp; &nbsp;=== hash-table-put!<br>
 &nbsp; &nbsp;hash-table-delete! === hash-table-remove!<br>
<br>
I think aliases like this are more appropriate in a library than in a<br>
SRFI.<br>
<br>
Currently, the SRFI draft would require all complying Scheme<br>
implementations to support multiple names for the same operation, which<br>
seems a little odd (&quot;call/cc&quot; notwithstanding).<br>
<br>
I'd lean towards having the SRFI specify only one name per operation,<br>
and having the Scheme implementations and user code comply with that.<br>
<br>
-- <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; http://www.neilvandyke.org/<br>
<br>
</tt></font>
<br>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00005.html">Re: SRFI-44 compatibility</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00007.html">Re: SRFI-44 compatibility</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00004.html">introspection</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00008.html">Naming</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00006"><strong>Date</strong></a></li>
<li><a href="threads.html#00006"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
