<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: Still on David's issues; SRFI 44 -->
<!--X-From-R13: Rnivq Hna Vbea <qinaubeaNpf.oenaqrvf.rqh> -->
<!--X-Date: Wed, 17 Aug 2005 16:15:19 +0200 (DFT) -->
<!--X-Message-Id: 430342F8.6080706@cs.brandeis.edu -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20050814191154.GA2256@humma -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: Still on David's issues; SRFI 44</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00066.html">Date Prev</a>][<a href="msg00068.html">Date Next</a>][<a href="msg00065.html">Thread Prev</a>][<a href="msg00066.html">Thread Next</a>][<a href="maillist.html#00067">Date Index</a>][<a href="threads.html#00067">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: Still on David's issues; SRFI 44</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-69">SRFI 69</a> from before July 7th, 2015.  The new archives for SRFI 69 are <a href="http://srfi-email.schemers.org/srfi-69/">here</a>.  The new archives contain all messages, not just those from before July 7th, 2015.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: <a href="mailto:srfi-69@DOMAIN.HIDDEN">srfi-69@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Subject</em>: Re: Still on David's issues; SRFI 44</li>
<li><em>From</em>: David Van Horn &lt;<a href="mailto:dvanhorn@DOMAIN.HIDDEN">dvanhorn@xxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Wed, 17 Aug 2005 10:00:24 -0400</li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-69@DOMAIN.HIDDEN">srfi-69@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:20050814191154.GA2256@DOMAIN.HIDDEN"><a href="msg00062.html">20050814191154.GA2256@humma</a></a>&gt;</li>
<li><em>References</em>: &lt;<a href="mailto:20050814191154.GA2256@DOMAIN.HIDDEN"><a href="msg00062.html">20050814191154.GA2256@humma</a></a>&gt;</li>
<li><em>User-agent</em>: Mozilla/5.0 (X11; U; SunOS sun4u; en-US; rv:1.6b) Gecko/20031206 Thunderbird/0.4</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre style="margin: 0em;">
Panu Kalliokoski wrote:
</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
Whether SRFI 69 should be about general mappings or hash tables, has
been IMO adequately addressed; if there are suggestions about how to
make it clearer in the abstract that it _is_ about hash tables, they are
welcome.
</pre></blockquote><pre style="margin: 0em;">

</pre><tt>In light of your comments, I agree with you Panu.  This is not just a mapping 
</tt><tt>datastructure.  If my comments seemed off-base it is only because I am 
</tt><tt>confused as to what the precise purpose of this SRFI is.  Without knowing the 
</tt><tt>precise purpose, I cannot make concrete suggestions on the document.  Your 
</tt><tt>response clarifies some, and I appreciate your patience and work.  My 
</tt><tt>suggestions are below.  I have no intentions of being insulting.
</tt><pre style="margin: 0em;">

</pre><tt>I have the following suggestions for the abstract and rationale.  If you 
</tt><tt>comment on these I can provide concrete suggestions for the rest of the 
</tt><tt>document.  I have tried to characterize the purpose of this SRFI as making it 
</tt><tt>possible to write portable code that uses hash tables in the most common ways 
</tt><tt>while remaining efficient.  Do you agree with that characterization?
</tt><pre style="margin: 0em;">

</pre><tt>I think the simple and generic aim should be dropped.  The design of this SRFI 
</tt><tt>should be simple and generic only so far as it furthers the above aim.
</tt><pre style="margin: 0em;">

---8&lt;---

Abstract

;; outline the need for, and design of, the proposal.

</pre><tt>Hash tables are mutable data structures meeting certain complexity 
</tt><tt>requirements that provide a mapping from some set of keys to some set of 
</tt><tt>values associated to those keys.  When a good hash function is used, key 
</tt><tt>lookup and destructive update must be performed in amortised constant time.
</tt><pre style="margin: 0em;">

</pre><tt>Widely recognised as a fundamental data structure, most Scheme systems provide 
</tt><tt>their functionality.  However, no Scheme standard exists for hash tables and 
</tt><tt>the functionality and interfaces provided by implementations varies widely, 
</tt><tt>making it difficult to write portable programs that use hash tables.
</tt><pre style="margin: 0em;">

</pre><tt>This SRFI specifies an API for hash tables designed so that portable programs 
</tt><tt>can be written which make efficient use of common hash table functionality.
</tt><pre style="margin: 0em;">


Rationale

;; explain why the proposal should be incorporated as a standard feature in
;; Scheme implementations. If there are other standards which this proposal
;; will replace or with which it will compete, the rationale should explain
;; why the present proposal is a substantial improvement.

</pre><tt>Hash tables are widely recognised as a fundamental data structure for many 
</tt><tt>kinds of computational tasks.  Almost every non-minimal Scheme implementation 
</tt><tt>provides some kind of hash table functionality, although there is no existing 
</tt><tt>standard.
</tt><pre style="margin: 0em;">

</pre><tt>Alas, although somewhat similar, these hash table APIs have many differences: 
</tt><tt>some trivial, like the naming of certain functions; some complex, like 
</tt><tt>revealing different aspects of the internal implementation to the user; some 
</tt><tt>coarse, like requiring keys to be of some specific type(s); some subtle, like 
</tt><tt>requiring the user to guess the size of the hash table in advance to get 
</tt><tt>optimal performance.  As a result, it is difficult to write portable programs 
</tt><tt>that use hash tables.
</tt><pre style="margin: 0em;">

</pre><tt>The primary aim of this SRFI is to establish a standard API for hash tables so 
</tt><tt>that portable programs can be written which make efficient use of common hash 
</tt><tt>table functionality.  The API resolves the discrepancies between the various 
</tt><tt>names and semantics for hash table operations provided by Scheme systems by 
</tt><tt>standardizing the names and behaviors of the most common operations. 
</tt><tt>Incorporating this SRFI as a standard feature of Scheme implementations makes 
</tt><tt>it possible to write efficient and portable programs that use hash tables.
</tt><pre style="margin: 0em;">

---8&lt;---

</pre><tt>Suggestions on the text given the aim of making it so that portable programs 
</tt><tt>can be written which make efficient use of common hash table functionality:
</tt><pre style="margin: 0em;">

</pre><tt>There are several things in the document that *may* lead to more efficient use 
</tt><tt>depending on the implementation.  I believe all of these should be dropped, 
</tt><tt>leaving specified only those things which *must* lead to efficient use in all 
</tt><tt>conforming implementations.  Specifically:
</tt><pre style="margin: 0em;">

</pre><tt>Drop size-hint.  Size-hint may be ignored as currently specified, thus its 
</tt><tt>status as an optional argument to hash table constructors does nothing to make 
</tt><tt>efficient use of hash tables portable.  Allow implementations to extend the 
</tt><tt>parameters arbitrarily to make implementation specific improvements.
</tt><pre style="margin: 0em;">

</pre><tt>Drop type specific hash tables.  If they are simply shorthands as stated, they 
</tt><tt>do nothing to make efficient use of hash tables portable.
</tt><pre style="margin: 0em;">

</pre><tt>If you'd like to suggest how particular implementations can improve 
</tt><tt>efficiency, you could add the following:  Implementations may improve 
</tt><tt>efficiency by specializing the hash table implementation when given the 
</tt><tt>equivalence procedure =, string=?...
</tt><pre style="margin: 0em;">

</pre><tt>I don't see any reason to complicate the API, in what I would say is an ad-hoc 
</tt><tt>manner, for non-portable gains in potential efficiency.
</tt><pre style="margin: 0em;">

</pre><tt>If you decide not to do this, you should add a rationale for including type 
</tt><tt>specific hash tables, and then a rationale for including this particular set 
</tt><tt>of types.  What is meant by &quot;shorthand&quot; is underspecified.  What are the 
</tt><tt>equivalence procedures used?  What happens when you add a string key to symbol 
</tt><tt>table?  There should be some way of determining if a hash-table value was 
</tt><tt>constructed with one of these constructors, eg symbol-hash-table? or 
</tt><tt>hash-table-type (as in Gauche).
</tt><pre style="margin: 0em;">


</pre><tt>I think you should state the following in the beginning of the specification 
</tt><tt>section.  This seems implied by the current text, but this is more explicit:
</tt><pre style="margin: 0em;">

---8&lt;---

</pre><tt>An implementation that does not provide lookup and destructive update in 
</tt><tt>amortised constant time (when a good hash function is used) does not conform 
</tt><tt>to this SRFI.
</tt><pre style="margin: 0em;">

An implementation that does not provide good hash function definitions for
</pre><tt>hash, {string,string-ci,symbol}-hash, and hash-by-identity does not conform to 
</tt><tt>this SRFI.
</tt><pre style="margin: 0em;">

---8&lt;---


From the document:

   If some key occurs multiple times in alist, it is unspecified which of the
   corresponding values will end up in hash-table.

</pre><tt>Why not specify that they are added in the order they appear in the alist, 
</tt><tt>such as MzScheme does.  If this is not the case, portable programs can't rely 
</tt><tt>on this function unless it is never the case that a key appears twice in the 
</tt><tt>alist.  Is there something gained from this being unspecified that outweighs 
</tt><tt>the loss in portability?  There is no external syntax for hash tables so it 
</tt><tt>seems to read and write hash tables portably one needs a well specified 
</tt><tt>alist-&gt;hash-table and hash-table-&gt;alist.
</tt><pre style="margin: 0em;">


</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
But because David seems to be very concerned about the neglection of
SRFI 44, I probably have to tell why I'm not heeding its call.
</pre></blockquote><pre style="margin: 0em;">

</pre><tt>I really have very little preference as to whether this SRFI follows the 
</tt><tt>conventions of SRFI 44, or if the proposed hash table datatype fits into the 
</tt><tt>subtype hierarchy of SRFI 44 collections.  I'm asking only for a rationale why 
</tt><tt>these choices were made.  Much of your email is an irrelevant critique of SRFI 
</tt><tt>44, but you do provide the basis of a rationale for your choices that should 
</tt><tt>be incorporated into the document.  I believe what I've quoted below is 
</tt><tt>relevant and can be summarized and included.
</tt><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
What would SRFI 44 API of hash tables look like?

Hash tables would have two supertypes: map and collection.  Collection
operations would forget about the keys.  No indexed collection could be
a subtype of a hash table, and no keyed collection could be a subtype of
an indexed collection.

There would be an asymmetry between items in a set and keys in a map:
even though these two are very similar, the former are treated as
&quot;values&quot; while the latter are treated as &quot;keys&quot;.  Consequently,
operations for these have different names.

Hash tables could have a value equivalence function which would be never
used, but the user could not supply a hash function.  This implies that
appropriate hash functions could be guaranteed only up to some specific
coarseness (as with SRFI 69 defaults), and beyond that, hash tables
could not guarantee their complexity constraints.  In fact, every time
the user supplied an unrecognised key equivalence function, the
implementation would have to use a constant hash function (like (lambda
(x) 0) for example) to guarantee correctness, destroying all the value
of hash tables.

Hash tables would lack an operation that folds with both keys and
values, and hash-table-&gt;alist.  Generally, _all_ access to the actual
associations of the hash table would be indirect.

hash-table-update! would not be there, forcing people to look up the key
twice when they update the value.

Hash tables should be able to implement -delete-from! for a bag datatype
that does not yet exist.

Despite all this, I've tried to craft SRFI 69 so that it does not
</pre><tt>_prevent_ a SRFI 44 style API to hash tables. 
</tt></blockquote><pre style="margin: 0em;">


David

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00062" href="msg00062.html">Still on David's issues; SRFI 44</a></strong>
<ul><li><em>From:</em> Panu Kalliokoski</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00066.html">Mutating keys</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00068.html">Drop ref/default, update!/default</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00065.html">Re: Still on David's issues; SRFI 44</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00066.html">Mutating keys</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00067"><strong>Date</strong></a></li>
<li><a href="threads.html#00067"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
