<!-- MHonArc v2.6.15 -->
<!--X-Subject: Comments on SRFI 69 -->
<!--X-From-R13: Rnivq Hna Vbea <qinaubeaNpf.oenaqrvf.rqh> -->
<!--X-Date: Thu, 11 Aug 2005 16:38:49 +0200 (DFT) -->
<!--X-Message-Id: 42FB5F73.6000403@cs.brandeis.edu -->
<!--X-Content-Type: text/plain -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Comments on SRFI 69</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00053.html">Date Prev</a>][<a href="msg00055.html">Date Next</a>][<a href="msg00052.html">Thread Prev</a>][<a href="msg00055.html">Thread Next</a>][<a href="maillist.html#00054">Date Index</a>][<a href="threads.html#00054">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Comments on SRFI 69</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-69">SRFI 69</a> from before July 7th, 2015.  The <a href="http://srfi-email.schemers.org/srfi-69">new archives</a> for SRFI 69 contain all messages, not just those from before July 7th, 2015.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: <a href="mailto:srfi-69@DOMAIN.HIDDEN">srfi-69@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Subject</em>: Comments on SRFI 69</li>
<li><em>From</em>: David Van Horn &lt;<a href="mailto:dvanhorn@DOMAIN.HIDDEN">dvanhorn@xxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Thu, 11 Aug 2005 10:23:47 -0400</li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-69@DOMAIN.HIDDEN">srfi-69@xxxxxxxxxxxxxxxxx</a></li>
<li><em>User-agent</em>: Mozilla/5.0 (X11; U; SunOS sun4u; en-US; rv:1.6b) Gecko/20031206 Thunderbird/0.4</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre style="margin: 0em;">
The SRFI document states the following in the Abstract:

   This SRFI specifies an API for basic hash tables. Hash tables are data
   structures that provide a mapping from some set of keys to some set of
   values associated to those keys.

</pre><tt>From your description of what hash tables are, the name &quot;hash table&quot; seems 
</tt><tt>too specific of a term.  This issue was raised earlier by Marc Feeley, and as 
</tt><tt>far as I can tell was never addressed in the document or discussion list. 
</tt><tt>Perhaps, I'm just missing it.  However, the more important issue here is that 
</tt><tt>what follows in the document is far from a basic API for structures that 
</tt><tt>provide a mapping from some set of keys to some set of values associated to 
</tt><tt>those keys.
</tt><pre style="margin: 0em;">

</pre><tt>One of the most common ways SRFIs go wrong is that their purpose is not 
</tt><tt>clearly articulated.  Without a clear thesis, it is impossible to evaluate 
</tt><tt>design choices and rationales, or even provide helpful suggestions.  Luckily 
</tt><tt>this SRFI does state its aims, however there are conflicts with what is 
</tt><tt>stated.  Further, design choices have been made that violate these aims, and 
</tt><tt>rationales rarely appeal to the aims in a consistent manner.
</tt><pre style="margin: 0em;">

The SRFI document states the following in the Rationale:

   The primary aim of this SRFI is to provide a simple and generic hash table
   API that will answer most of users' needs for basic usage of hash tables.

</pre><tt>This conflates two disparate and competing aims into one; that of providing a 
</tt><tt>simple and generic API for a data structure which &quot;provides a mapping from 
</tt><tt>some set of keys to some set of values associated to those keys,&quot; and that of 
</tt><tt>covering the general usage patterns of hash tables (whatever those patterns 
</tt><tt>may be).  The abstract makes no mention of most common hash table usage, so 
</tt><tt>this second aim seems out of the scope of this SRFI.  But several choices are 
</tt><tt>made contrary to the aim of simplicity and generality, such as the ad-hoc 
</tt><tt>collection of type-specialized hash table procedures and their hash function 
</tt><tt>counterparts.  Appeals for generality in the API have been discounted by the 
</tt><tt>author saying such things as, &quot;I'd rather define these routines to account for 
</tt><tt>the most common situation(s) and be done with it.&quot;
</tt><pre style="margin: 0em;">

</pre><tt>On the other hand, there is widespread use of immutable hash tables, tables 
</tt><tt>with weakly held keys, concurrency, and GC-sensitive tables, but this SRFI 
</tt><tt>addresses none of those common usages or the issues that arise in their 
</tt><tt>presence, and is therefore deficient on this second stated aim.
</tt><pre style="margin: 0em;">

</pre><tt>By conflating these aims, the design choices lack a clear purpose and often 
</tt><tt>seem to reflect the authors personal preferences rather than a reasoned 
</tt><tt>rationale.  Indeed, it is difficult if not impossible to evaluate a design 
</tt><tt>choice when there is not a clear and consistent aim for the SRFI.  I think 
</tt><tt>this document would greatly benefit a more explicit statement of its purpose, 
</tt><tt>resolving the conflict of the current aims.  As it exists now, the SRFI 
</tt><tt>neither provides a basic API for a key-value mapping datastructure, nor 
</tt><tt>provides an API covering most, or even common, users' hash table needs.
</tt><pre style="margin: 0em;">

</pre><tt>Also, I think a key aim that this SRFI should have, but does not, is the 
</tt><tt>selection of names that represent consistent conventions with existing Scheme 
</tt><tt>practices.
</tt><pre style="margin: 0em;">

The SRFI document states the following in the Rationale:

   Hash tables are widely recognized as a fundamental data structure for many
   kinds of computational tasks. Almost every non-minimal Scheme
   implementation provides some kind of hash table functionality.

</pre><tt>This is certainly true.  The majority of Scheme's I'm familiar with include a 
</tt><tt>hash table datastructure and their common operations, however the names vary 
</tt><tt>highly.  This highlights what should be a primary concern in the design of 
</tt><tt>this SRFI, but which has been neglected; to identify a consistent, and 
</tt><tt>portable set of names and parameter conventions.
</tt><pre style="margin: 0em;">

</pre><tt>The author has chosen the name and parameter conventions that run counter to 
</tt><tt>several existing Scheme conventions, such as previous SRFIs, RnRS, and 
</tt><tt>numerous Scheme implementations.  Some choices have no precedent whatsoever. 
</tt><tt>To choose such conventions is perfectly allowable, but the advantage of these 
</tt><tt>new conventions must be thoroughly articulated and compelling.  I don't think 
</tt><tt>that is the case here.  Further, if the aim of this goal is to cover common 
</tt><tt>hash table usage, unprecedented names and conventions run counter to this aim; 
</tt><tt>something which has never been used before is not common.
</tt><pre style="margin: 0em;">


</pre><tt>My preference for this SRFI is the following.  Drop the aim of covering common 
</tt><tt>hash table usage.  Writing such a SRFI is a very ambitious and difficult thing 
</tt><tt>to do, and it requires an extensive amount of surveying common use.  I would 
</tt><tt>expect such a SRFI to discuss the design choices taken by most Scheme 
</tt><tt>implementations, the several related SRFIs, as well as similar libraries from 
</tt><tt>related languages such as ML and Lisp.  SRFI 1 is a good example of such a 
</tt><tt>&quot;common use&quot; SRFI.  Shivers surveyed R4RS/R5RS Scheme, MIT Scheme, Gambit, 
</tt><tt>RScheme, MzScheme, slib, Common Lisp, Bigloo, guile, T, APL and the SML 
</tt><tt>standard basis in designing that library.  A good common use hash table SRFI 
</tt><tt>would need to do likewise.
</tt><pre style="margin: 0em;">

</pre><tt>Instead, this SRFI should focus on providing a simple and generic API for data 
</tt><tt>structures that provide a mapping from some set of keys to some set of values 
</tt><tt>associated to those keys.  All parts of this SRFI that do not contribute to 
</tt><tt>that aim should be dropped.  All rationales that do not appeal this aim, 
</tt><tt>should be abandoned.  I would like to see this API be consistent with the 
</tt><tt>existing datastructure API conventions that exist in Scheme.  Most notably, 
</tt><tt>this SRFI should be consistent in its choice of names and parameter 
</tt><tt>conventions with SRFI 44 [1].  If the author chooses against these 
</tt><tt>conventions, this SRFI then conflicts and competes with SRFI 44 (and others) 
</tt><tt>and as such the &quot;rationale should explain why the present proposal is a 
</tt><tt>substantial improvement&quot; over these existing conventions, as required by the 
</tt><tt>process document.
</tt><pre style="margin: 0em;">

</pre><tt>This SRFI will be an important one.  People will turn to it regardless of how 
</tt><tt>well or poorly constructed it is.  Without a clear and consistent aim, which I 
</tt><tt>believe is the case now, such a SRFI can do a great deal of harm.
</tt><pre style="margin: 0em;">

David

</pre><tt>[1] This issue of SRFI 44 names was raised as the first comment during the 
</tt><tt>discussion period by Scott Miller, to which Bear voiced criticism over SRFI 44 
</tt><tt>on implementation and usability grounds.  This is irrelevant.  SRFI 44 
</tt><tt>included a great deal of work on identifying the proper names for precisely 
</tt><tt>this kind of datastructure.  The choices include rationales, some of which 
</tt><tt>have been appealed to in deciding names in this SRFI.  If this SRFI is not 
</tt><tt>going to use the names of SRFI 44, it *must* include compelling rationales for 
</tt><tt>these names over the names (and rationales) identified in SRFI 44.  Many of 
</tt><tt>the choices made thus far in the SRFI directly conflict with SRFI 44, 
</tt><tt>sometimes in very confusing ways, such as hash-table-equivalence-function, 
</tt><tt>which a reader of SRFI 44 would expect to return an equivalence over the items 
</tt><tt>in the hash table collection, i.e. key value pairs, whereas 
</tt><tt>hash-table-key-equivalence-function would return what SRFI 69 returns for 
</tt><tt>hash-table-equivalence-function.
</tt><pre style="margin: 0em;">

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00055" href="msg00055.html">Re: Comments on SRFI 69</a></strong>
<ul><li><em>From:</em> Panu Kalliokoski</li></ul></li>
<li><strong><a name="00057" href="msg00057.html">Re: Comments on SRFI 69</a></strong>
<ul><li><em>From:</em> felix winkelmann</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00053.html">Re: error in hash table reference implementation</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00055.html">Re: Comments on SRFI 69</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00052.html">Draft period extension, new draft</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00055.html">Re: Comments on SRFI 69</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00054"><strong>Date</strong></a></li>
<li><a href="threads.html#00054"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
