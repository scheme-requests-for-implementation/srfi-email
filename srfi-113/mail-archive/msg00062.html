<!-- MHonArc v2.6.18 -->
<!--X-Subject: Re: handling duplicate elements -->
<!--X-From-R13: Yriva Ibegzna <xjbegznaNtznvy.pbz> -->
<!--X-Date: Sun,  6 Jul 2014 18:58:03 +0000 (UTC) -->
<!--X-Message-Id: CAD2CXettxqQpNMR6Pdhja0XxSGCDFijjt7ASW&#45;U7++Redg7WVQ@mail.gmail.com -->
<!--X-Content-Type: multipart/alternative -->
<!--X-Reference: CAD2CXevyaBF2kj&#45;KhTMn=_3VY=kL1OkUXSiCjn_=QDZ&#45;_12XgA@mail.gmail.com -->
<!--X-Reference: 20140702175522.GE21298@mercury.ccil.org -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: handling duplicate elements</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00061.html">Date Prev</a>][<a href="msg00063.html">Date Next</a>][<a href="msg00061.html">Thread Prev</a>][<a href="msg00063.html">Thread Next</a>][<a href="maillist.html#00062">Date Index</a>][<a href="threads.html#00062">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: handling duplicate elements</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-113">SRFI 113</a> from before July 7th, 2015.  The new archives for SRFI 113 are <a href="http://srfi-email.schemers.org/srfi-113/">here</a>.  The new archives contain all messages, not just those from before July 7th, 2015.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: John Cowan &lt;<a href="mailto:cowan@DOMAIN.HIDDEN">cowan@xxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Subject</em>: Re: handling duplicate elements</li>
<li><em>From</em>: Kevin Wortman &lt;<a href="mailto:kwortman@DOMAIN.HIDDEN">kwortman@xxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Sun, 6 Jul 2014 11:57:42 -0700</li>
<li><em>Cc</em>: <a href="mailto:srfi-113@DOMAIN.HIDDEN">srfi-113@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-113@DOMAIN.HIDDEN">srfi-113@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Dkim-signature</em>: v=1; a=rsa-sha256; c=relaxed/relaxed;        d=gmail.com; s=20120113;        h=mime-version:in-reply-to:references:from:date:message-id:subject:to         :cc:content-type;        bh=nt153ZRLn2NTJnlWAuNHvE4bJNfOa2M4sWkdHjrDL88=;        b=nm7HPgmQcp9Y2xIyP8VxsoKS0xFuruXcjwP3O5Q6wyTeK6Y0uTOKjC5Ip9rzfyfxSz         DPRru6VAcezaocfMidgu/u1r/A6ieDywqfgqMDRryHslgRHqZmqPs0/ekvY88CCo6s39         /XrEZJY2aMVbNaqD24QpafvyqL4zWzjOVXh9SbuuqXQH8a/G0BR5m7FU491XcNXcNze9         aQ6xu9FJ1Wu6GW5wBnjPdj5jn3RWfDyCGe96YWXG+580Ijg/6kK2jkUMbReY2eJO57iF         MeOLfBdU+aX17KMR0Iz+9djtOqLduvmU6B1LBwrxLO/jLp6klVtBGw70WZkHzNcT3072         c9Kw==</li>
<li><em>In-reply-to</em>: &lt;<a href="msg00061.html">20140702175522.GE21298@mercury.ccil.org</a>&gt;</li>
<li><em>References</em>: &lt;CAD2CXevyaBF2kj-KhTMn=_3VY=kL1OkUXSiCjn_=QDZ-_12XgA@mail.gmail.com&gt; &lt;<a href="msg00061.html">20140702175522.GE21298@mercury.ccil.org</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<div dir="ltr"><br><div class="gmail_extra"><div class="gmail_quote"><blockquote class="gmail_quote" style="margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex"><div class="">
<br>
</div>This is very timely, because I am currently working on a new release of<br>
the SRFI, this time with a completely new implementation for sets and<br>
bags. &#xA0;The integer-set implementation will follow in a later release.<br></blockquote><div><br></div><div>Great! I&#39;ve been rewriting my immutable data structures, but have been holding off on proposing a SRFI until this one is finalized. I&#39;d like the interface to the immutable structures to be as close to identical to SRFI 113 as practicable.<br>

</div><div>&#xA0;</div><blockquote class="gmail_quote" style="margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex">
<div class=""><br>
</div>Eqv? would be the relevant predicate, given that when you put something<br>
into a standard Scheme data structure such as a pair or vector, what you<br>
get out is guaranteed to be eqv? to what went in, per R5RS/R7RS 3.4.<br></blockquote><div><br></div><div>Right.<br><br>I have to admit that I&#39;ve always had a hard time grokking the intended distinction between eq? and eqv?. I understand that equal? is a deep O(n) comparison, eq? is a pointer comparison (plus identity of O(1)-sized types), and eqv? lies somewhere in between. At the risk of getting sidetracked, do you happen to have a reference to an explanation of what eqv? means? The R7RS document is very precise but IMO not very instructive on this point.<br>

</div><div>&#xA0;</div><blockquote class="gmail_quote" style="margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex">
<div class="">
</div>I considered this approach, but I decided that it was overkill. &#xA0;Other<br>
than set-adjoin(!), the only procedures that need such selection are the<br>
set operations set-union(!) and set-intersection(!), and since they are<br>
commutative, a simple rule of &quot;first argument beats second argument&quot;<br>
will suffice.<br></blockquote><div><br></div><div>The problem is that it isn&#39;t just adjoin, union, and intersection. Duplicates may arise in the constructor, e.g.<br><br></div><div>(set default-comparator x x x) .<br>

<br></div><div>While a programmer is unlikely to do something that&#39;s so obviously pointless, the same situation could easily arise with<br><br>(set default-comparator a b c)<br><br>where a, b, and c came from client code and happen to be =?.<br>

<br></div><div>The list passed to list-&gt;set and list-&gt;set! may have duplicates, so they are implicated in this too.<br><br></div><div>And, set-map may create duplicates if the mapping procedure is not injective. I think this is the subtlest of these cases and the most likely to catch programmers by surprise. For example, if you map string-upcase on a set of strings, you may wind up with fewer strings than you started with. So whatever we decide, I think the documentation for set-map should remind programmers about non-injective functions.<br>

<br>This is one of the reasons I had an imap/monotone procedure in my draft immutable library; monotone procedures are a common special case of injective function. In hindsight, though, I think it should be imap/nondecreasing instead of imap/monotone. When you map a nondecreasing function on the values of a binary search tree, you can reuse the shape of the tree, which makes imap/nondecreasing potentially much faster than a more general imap that needs to check for duplicates and build a new tree structure from scratch.<br>

</div><div></div>&#xA0;<blockquote class="gmail_quote" style="margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex">
<br>
So I am suggesting that set-adjoin(!) never replaces existing elements,<br>
and adding a new operation set-replace(!) with three arguments: the set,<br>
the element, and a default. &#xA0;If the set contains the element, it is<br>
deleted and the element is adjoined (this is a no-op if they are eqv?);<br>
if not, the default is inserted.<br></blockquote><div><br></div><div>So this suggestion is that set-adjoin and set-replace use &quot;second argument beats first&quot; and all other procedures use &quot;first argument beats second.&quot; This behavior would accommodate my intended use case, of implementing an association-map on top of a set. So I could live with it.<br>

<br>But I&#39;m not 100% happy with it, because it conflates two orthogonal issues: the differences between set-union and set-adjoin are that, in set-adjoin the right argument(s) are elements instead of sets, _and_ that set-adjoin uses &quot;second argument beats first&quot; while set-union uses &quot;first argument beats first.&quot; It would be cleaner to separate these orthogonal concerns. But unfortuantely so far the only way I&#39;ve thought of doing that are optional arguments or first-class selectors, both of which are admittedly rather heavyweight.<br>

<br></div>Kevin Wortman<br><br></div></div></div>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00063" href="msg00063.html">Re: handling duplicate elements</a></strong>
<ul><li><em>From:</em> John Cowan</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00060" href="msg00060.html">handling duplicate elements</a></strong>
<ul><li><em>From:</em> Kevin Wortman</li></ul></li>
<li><strong><a name="00061" href="msg00061.html">Re: handling duplicate elements</a></strong>
<ul><li><em>From:</em> John Cowan</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00061.html">Re: handling duplicate elements</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00063.html">Re: handling duplicate elements</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00061.html">Re: handling duplicate elements</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00063.html">Re: handling duplicate elements</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00062"><strong>Date</strong></a></li>
<li><a href="threads.html#00062"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
