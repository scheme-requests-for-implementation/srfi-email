<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: straw&#45;man [was Re: arithmetic issues] -->
<!--X-From-R13: Bnhy Epuyvr <fpuyvrNpbzpnfg.arg> -->
<!--X-Date: Sun, 22 Jan 2006 19:45:42 +0100 (MET) -->
<!--X-Message-Id: BFF93CF4.CBFB%schlie@comcast.net -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: Pine.LNX.4.58.0601220747110.4954@bolt.sonic.net -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: straw-man [was Re: arithmetic issues]</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00394.html">Date Prev</a>][<a href="msg00396.html">Date Next</a>][<a href="msg00394.html">Thread Prev</a>][<a href="msg00397.html">Thread Next</a>][<a href="maillist.html#00395">Date Index</a>][<a href="threads.html#00395">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: straw-man [was Re: arithmetic issues]</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-77">SRFI 77</a> from before July 7th, 2015.  The new archives for SRFI 77 are <a href="http://srfi-email.schemers.org/srfi-77/">here</a>.  Eventually, the entire history will be moved there, including any new messages.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: bear &lt;<a href="mailto:bear@DOMAIN.HIDDEN">bear@xxxxxxxxx</a>&gt;</li>
<li><em>Subject</em>: Re: straw-man [was Re: arithmetic issues]</li>
<li><em>From</em>: Paul Schlie &lt;<a href="mailto:schlie@DOMAIN.HIDDEN">schlie@xxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Sun, 22 Jan 2006 13:45:24 -0500</li>
<li><em>Cc</em>: William D Clinger &lt;<a href="mailto:will@DOMAIN.HIDDEN">will@xxxxxxxxxxx</a>&gt;, &lt;<a href="mailto:agj@DOMAIN.HIDDEN">agj@xxxxxxxxxxxx</a>&gt;,	&lt;<a href="mailto:sperber@DOMAIN.HIDDEN">sperber@xxxxxxxxxxxxxxxxxxxxxxxxxxx</a>&gt;, &lt;<a href="mailto:srfi-77@DOMAIN.HIDDEN">srfi-77@xxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-77@DOMAIN.HIDDEN">srfi-77@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:Pine.LNX.4.58.0601220747110.4954@DOMAIN.HIDDEN">Pine.LNX.4.58.0601220747110.4954@xxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Thread-index</em>: AcYfhAEGP06w5ot3Edq0XQADk1ictA==</li>
<li><em>Thread-topic</em>: straw-man [was Re: arithmetic issues]</li>
<li><em>User-agent</em>: Microsoft-Entourage/11.2.1.051004</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>&gt; From: bear &lt;bear@xxxxxxxxx&gt;
&gt;&gt; On Sat, 21 Jan 2006, Paul Schlie wrote:
&gt;&gt; - Upon more reflection, given that it's likely unreasonable to presume
&gt;&gt;  that an &lt;exact&gt; implementation must (or even could) reliably support
&gt;&gt;  infinitely precise calculations/representations, it must then support
&gt;&gt;  finite precision calculations, thereby necessitating its definition
&gt;&gt;  of overflow semantics, basically leaving the choice of either modular
&gt;&gt;  or saturating semantics; where either may be considered reasonable,
&gt;&gt;  it seems undisputed that modular semantics tend to be the simplest
&gt;&gt;  and most natural default of most machine and/or SW implementations,
&gt;&gt;  and does not preclude the throwing of a recoverable overflow exception
&gt;&gt;  if supported by the base implementation.
&gt; 
&gt; The thing is, I don't ever want it to be considered &quot;wrong&quot; for
&gt; someone to add #e1.23456 and #e6.54321 and get exactly #e7.77777.
&gt; I mean, that's what the numbers add up to, right?  And if the finite
&gt; representation chosen by an implementor uses powers of ten rather
&gt; than (or in addition to) powers of two, that's exactly what the
&gt; answer will be.  If someone is relying on this answer to be inexact,
&gt; or to exhibit a particular numeric error based on a presumed binary
&gt; representation (ie, relying on the operation expressed by '+' to
&gt; be some particular approximation of addition rather than addition
&gt; itself) then while they might be right for a lot of particular
&gt; implementations, they are wrong in first principles.

- The only point I was attempting to make is that if it's accepted
  that it's likely unreasonable to presume that any implementation
  is capable of reliably supporting indefinitely precise calculations
  and correspondingly representing their resultant values; it must
  be presumed that a finite practical precision limit exists, and
  therefore an overflow/underflow condition may result from an
  arbitrary calculation which should ideally be correspondingly
  defined regardless of what that precision bound may be defined
  as being for a given implementation; thereby although the result
  of the calculation may not be &quot;arithmetically expected&quot; due to
  an implementation's limited precision, it's result is deterministic
  at the bonds if it's capable precision in whatever base number system
  an implementation chooses (further implying the specification of it's
  base in addition to it's fractional and integer precision be
  determinable).

&gt; Similarly, most of the computable reals have a finite, exact and
&gt; reasonably short representation, although it may be a &quot;tree&quot;
&gt; representation involving logarithms, exponents, square roots, factors
&gt; of irrational constants like e and pi, etc.  Such representations
&gt; are something used a lot by specialized mathematical applications like
&gt; Macsyma, although they're something of a pain to implement the basic
&gt; functions for, because people want correct answers.  No matter what
&gt; representation scheme you pick, there'll be numbers you can't represent
&gt; exactly - but in principle, I don't want to ever forbid the &quot;generic&quot;
&gt; operations on exact numbers from returning exact results, period.

- Agreed, an exact implementation based on an integer multiple of the
  fractional division of pi, e, etc. may be very appropriate for various
  applications; but does not preclude the fact that values, including
  those not rational within that number system, exist which may overflow
  the representational precision supported by it's implementation; as
  the presumption of an infinitely precise implementation is not likely
  reasonable regardless of the numerical base chosen (it would seem?).

&gt; If an implementor has gone out of his or her way to build a system
&gt; in which say, the result of log2(327) is exact, I say more power to
&gt; them and I don't want to see a bunch of requirements that can *only*
&gt; be implemented effectively for ieee-float style representations.
&gt; 
&gt; I'd much rather see explicit operations like (ieee53 x) which
&gt; returns the closest inexact number to x that is a member of the set
&gt; of numbers representable as an ieee float with a 53-bit mantissa,

- which would seem to have the odd consequence of potentially introducing
  enormously large errors for otherwise &quot;nearly exact&quot; values if constrained
  to the potentially substantially lesser dynamic range and/or precision of
  an &quot;inexact&quot; representation, which seems rather counter productive for
  values otherwise chosen to be represented more exactly?

  (Which would seem to raise the question: what's the true purpose of an
  &quot;exact&quot; representation if not to enable the representation of values
   with greater precision than may be otherwise represented as an &quot;inexact&quot;
   value?  As in fact the true purpose of an &quot;inexact&quot; representation seems
   to be based on the premise that computational efficiency may be improved
   at the expense of numerical precision, thereby an &quot;exact&quot; implementation,
   should possibly be more correctly viewed as being simply &quot;more precise&quot;
   if it's implementation precision and/or dynamic range exceeds that of an
   &quot;inexact&quot; implementation, but not necessarily &quot;exact&quot;)

&gt; or (ieee53! x) which mutates x forcing it to be that number.
&gt; If an implementation is concerned with speed, it's already using
&gt; some format like this for all its inexact numbers, and these become
&gt; the identity function and a no-op, respectively, get optimized out,
&gt; and do not interfere with speed.  If an implementation is more
&gt; concerned with correctness and uses macsyma-like numbers, then at
&gt; least ordinary code is not subject to numerical errors caused by
&gt; the choice of format unless the programmer explicitly requires
&gt; that choice, and correctness does not suffer.

- It seems fairly simple to presume that values and/or calculations
  based on &quot;inexact&quot; values are meant to be performed &quot;inexactly&quot;,
  and correspondingly those based on &quot;exact&quot; values are intended to be
  performed &quot;more precisely&quot;, as otherwise they would have been specified
  as being &quot;inexact&quot;.

&gt; The abstract of SRFI-77 talks about the need for less variety and
&gt; freedom in numeric implementation; Aside from the thought that the
&gt; numeric tower short of polar-complex numbers should be required
&gt; rather than recommended, I simply do not agree.  I see inexact
&gt; formats, especially where exact results are possible and representable,
&gt; as a source of mathematical errors, and I think that it is the
&gt; implementor's responsibility, insofar as cleverness allows and
&gt; insofar as s/he cares about correctness, to produce a system
&gt; that limits mathematical errors to exactly those explicitly
&gt; requested by the programmer.

- Although maybe I'm alone, it would seem that most ideally &quot;exact&quot;
  values should be simply viewed as being merely &quot;precise&quot; within the
  constraints specified by their implementation (numerical-base, fractional-
  precision-of-that-base, and maximum-integer-multiple-of-that-fractional-
  precision) of which multiple such types may be specified and used; and
 &quot;inexact&quot; values are specified by their implementations (numerical-base,
  fractional-precision-of-that-base, exponential-multiple-
  precision-of-that-base).

  Thereby an &quot;inexact&quot; value utilizes a window of precision within the
  dynamic range which a &quot;exact&quot; value would otherwise be fully precise
  within. (thereby simply is capable of representing only a subset of the
  values otherwise precisely representable within a corresponding &quot;exact&quot;
  implementation covering the same dynamic range, which thereby may justify
  concluding that an overflow/underflow of that dynamic range should yield
  equivalent saturated values?)





</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00394" href="msg00394.html">Re: straw-man [was Re: arithmetic issues]</a></strong>
<ul><li><em>From:</em> bear</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00394.html">Re: straw-man [was Re: arithmetic issues]</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00396.html">Re: Arithmetic issues - feedback</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00394.html">Re: straw-man [was Re: arithmetic issues]</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00397.html">Re: straw-man [was Re: arithmetic issues]</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00395"><strong>Date</strong></a></li>
<li><a href="threads.html#00395"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
