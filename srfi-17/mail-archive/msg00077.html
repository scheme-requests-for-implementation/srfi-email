<!-- MHonArc v2.6.15 -->
<!--X-Subject: A long time ago in a newsgroup far, far away, ... -->
<!--X-From-R13: Oaql Unlabe <fvyireNdhnqevk.pbz> -->
<!--X-Date: Sun, 12 Mar 2000 00:41:51 &#45;0600 (CST) -->
<!--X-Message-Id: 38CB3C37.E89D9ECD@quadrix.com -->
<!--X-Content-Type: text/plain -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>A long time ago in a newsgroup far, far away, ...</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00076.html">Date Prev</a>][<a href="msg00078.html">Date Next</a>][<a href="msg00075.html">Thread Prev</a>][<a href="msg00078.html">Thread Next</a>][<a href="maillist.html#00077">Date Index</a>][<a href="threads.html#00077">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>A long time ago in a newsgroup far, far away, ...</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-17">SRFI 17</a> from before July 7th, 2015.  The new archives for SRFI 17 are <a href="http://srfi-email.schemers.org/srfi-17/">here</a>.  Eventually, the entire history will be moved there, including any new messages.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: <a href="mailto:srfi-17@DOMAIN.HIDDEN">srfi-17@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Subject</em>: A long time ago in a newsgroup far, far away, ...</li>
<li><em>From</em>: Andy Gaynor &lt;<a href="mailto:silver@DOMAIN.HIDDEN">silver@xxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Sun, 12 Mar 2000 06:41:59 +0000</li>
<li><em>Organization</em>: Quadrix Solutions, Inc.</li>
<li><em>Sender</em>: silver</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>... I posted something resembling what's below.
Works to the best of my knowledge.

Regards, [Ag]   Andy Gaynor   silver@xxxxxxxxxxx
_______________________________________________________________________________

;; Copyright &#xA9; (c) 2000 by Andy Gaynor

;; A settable lambda is the accessor procedure itself, slightly extended to
;; retain, set, and return its setter procedure upon request.
;; 
;; A settable lambda is generated by an expression of the following formats:
;; 
;;     ;; The typical notation for defining both accessor and setter
;;     (settable-lambda ((access ...) value ...)
;;       (accessor-body ...)
;;       (setter-body ...))
;; 
;;     ;; The typical notation for defining just the accessor
;;     (settable-lambda (access ...) accessor-body ...)
;; 
;;     ;; The general notation for defining both accessor and setter
;;     (settable-lambda accessor-procedure setter-procedure)
;; 
;; DEFINE-SETTABLE is an analog to DEFINE mirroring settable-lambda notation:
;; 
;;     (define-settable (name (access ...) value ...)
;;       (accessor-body ...)
;;       (setter-body ...))
;; 
;;     (define-settable (name access ...)
;;       accessor-body ...)
;; 
;; The function SETTER returns a settable lambda's setter:
;; 
;;     (setter some-settable-lambda)
;; 
;; SETTER is itself a settable lambda which can set a settable-lambda's setter:
;; 
;;     (set (setter some-settable-lambda) new-setter)
;; 
;; DEFINE-SETTER is an analog to DEFINE for setting the setter.
;; The following two are equivalent:
;; 
;;     (define-setter (some-settable-lambda (access ...) value ...)
;;       setter-body ...)
;; 
;;     (set (setter name) (lambda (access ...)
;;                          (lambda (value ...)
;;                            setter-body ...)))
;; 
;; SET is an extended SET!-like construct.  The following pairs are equivalent:
;; 
;;     (set variable value)
;;     (set! variable value)
;; 
;;     (set (some-settable-lambda access ...) value ...)
;;     (((setter some-settable-lambda) access ...) value ...)
;; 
;; Many macro expanders (including syntax-rules and exrename) won't allow
;; something to be improperly defined in terms of itself (in cpp, you can get
;; away with this).  Given this, SET! itself can only be redefined if it's
;; defined in terms of some other construct.  For maximum extensibility,
;; implementations should define all the advertised constructs in terms of
;; implementation-dependent ones.  Many don't, though.  And so, in general, an
;; alternate to SET! must be chosen as the interface to setter functionality.
;; Choosing the name of a SET! alternate is hard:
;;     set  set*  set*!  set!*  set!! setf
;; Of these, I prefer SET and SET!*.  But I really want SET!, dammit.
;; 
;; Finally, a few familiar operations are defined to be settable-lambdas.
;; These are commented out for now; something unexpected seems to be happening.
;; Help me debug, will you?  nth down there seems to work ok.

;; Thanks to Oleg Kiselyov (oleg@xxxxxxxxx) for pointing a subtle scoping bug
;; in the original code which resulted in infinite recursion when redefining
;; functions used in this implementation like car and cdr.
(define original-cdr cdr)
(define original-car car)

;; Implementation-dependent.
(define (settable-lambda-error . arguments) (/ 0 0))

;; Hey idiot, limit the scope on this magic value.
(define (setter-magic) setter-magic)

(define-syntax settable-lambda
  (syntax-rules ()

    ;; This could have problems with improper (access ...).
    ;; Broken up into () and (access-1 . access-rest).
    ;;((settable-lambda ((access-1 ...) . value-rest) accessor-body setter-body)
    ;; (settable-lambda (lambda (access-1 ...) . accessor-body)
    ;;                  (lambda (access-1 ...) (lambda value-rest . setter-body))))
    ((settable-lambda (() . value-rest) accessor-body setter-body)
     (settable-lambda (lambda () . accessor-body)
                      (lambda () (lambda value-rest . setter-body))))
    ((settable-lambda ((access-1 . access-rest) . value-rest) accessor-body setter-body)
     (settable-lambda (lambda (access-1 . access-rest) . accessor-body)
                      (lambda (access-1 . access-rest) (lambda value-rest . setter-body))))

    ((settable-lambda accessor-value setter-value)
     (letrec ((accessor accessor-value) (setter setter-value))
       (lambda arguments
         (cond ((null? arguments)
                (accessor))
               ((not (eq? (original-car arguments) (setter-magic)))
                (apply accessor arguments))
               ((null? (original-cdr arguments))
                setter)
               ((null? (original-cdr (original-cdr arguments)))
                (set! setter (cadr arguments)))
               (else
                (settable-lambda-error &quot;Setter magic error&quot;))))))

    ;; This could have problems with improper (access ...).
    ;; Broken up into () and (access-1 . access-rest).
    ;;((settable-lambda (access ...) . accessor-body)
    ;; (settable-lambda (lambda (access ...) . accessor-body) #f))
    ((settable-lambda () . accessor-body)
     (settable-lambda (lambda () . accessor-body) #f))
    ((settable-lambda (access-1 . access-rest) . accessor-body)
     (settable-lambda (lambda (access-1 . access-rest) . accessor-body) #f))))

(define-syntax define-settable
  (syntax-rules ()
    ((define-settable (name . stuff-1) . stuff-2)
     (define name (settable-lambda stuff-1 . stuff-2)))))

(define-syntax define-setter
  (syntax-rules ()
    ((define-setter (name access-rest . value-rest) . body)
     (name (setter-magic) (lambda access-rest (lambda value-rest . body))))))

(define-settable (setter (settable) new-setter)
  ((settable (setter-magic)))
  ((settable (setter-magic) new-setter)))

(define-syntax set
  (syntax-rules ()
    ((set (settable . access-rest) . value-rest)
     (((setter settable) . access-rest) . value-rest))
    ((set variable value)
     (set! variable value))))

;; (define car (let ((original-car car))
;;               (settable-lambda ((x) value) ((original-car x)) ((set-car! x value)))))
;; (define cdr (let ((original-cdr cdr))
;;               (settable-lambda ((x) value) ((original-cdr x)) ((set-cdr! x value)))))
;;
;; Form                        Values
;;
;; (define x (list 'a 'b 'c))
;; (car x)                     a
;; (set (car x) 'aa)
;; x                           (aa b c)
;; (set (cdr x) '())
;; x                           (aa)

;; (define-settable (nth (x i) value)
;;   ((cond ((list?   x) (list-ref   x i))
;;          ((vector? x) (vector-ref x i))
;;          ((string? x) (string-ref x i))))
;;   ((cond ((list?   x) (set-car! (list-tail x i) value))
;;          ((vector? x) (vector-set! x i value))
;;          ((string? x) (string-set! x i value)))))

;; (define *red*   0)
;; (define *green* 0)
;; (define *blue*  0)
;;
;; (define-settable (color () r g b)
;;   ((values *red* *green* *blue*))
;;   ((set *red*   r)
;;    (set *green* g)
;;    (set *blue*  b)))
;;
;; Form                 Values
;;
;; (color)              0 0 0
;; (set (color) 1 2 3)  
;; (color)              1 2 3

;; The same as above, but hiding *red*, *green*, and *blue*.
;;
;; (define color
;;   (let ((red   0)
;;         (green 0)
;;         (blue  0))
;;     (settable-lambda (() r g b)
;;       ((values red green blue))
;;       ((set red   r)
;;        (set green g)
;;        (set blue  b)))))
;;
;; Form                 Values
;;
;; (color)              0 0 0
;; (set (color) 1 2 3)  
;; (color)              1 2 3

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00076.html">Re: where is srfi-17 going?</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00078.html">A better future</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00075.html">Uniqueness of set! and dangers of locations</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00078.html">A better future</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00077"><strong>Date</strong></a></li>
<li><a href="threads.html#00077"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
