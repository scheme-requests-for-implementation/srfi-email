<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: Floating&#45;point formats and standards -->
<!--X-From-R13: Ohoerl Xnssre <ntwNnyhz.zvg.rqh> -->
<!--X-Date: Mon, 17 Jan 2005 06:13:26 +0100 (NFT) -->
<!--X-Message-Id: 20050117051317.500D11B772F@voluntocracy.org -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: Pine.LNX.4.58.0412301550550.3862@bolt.sonic.net -->
<!--X-Reference: 20050105012438.GD6573@ogre.szonye.com -->
<!--X-Reference: 20050105055413.5FA901B7717@voluntocracy.org -->
<!--X-Reference: 20050105114809.GB9007@ogre.szonye.com -->
<!--X-Reference: 20050105122227.GC9007@ogre.szonye.com -->
<!--X-Reference: 20050105170342.348AC1B7719@voluntocracy.org -->
<!--X-Reference: 20050106004956.GB10975@ogre.szonye.com -->
<!--X-Reference: 20050106060805.D2EEC1B7727@voluntocracy.org -->
<!--X-Reference: 20050106104820.GA14471@ogre.szonye.com -->
<!--X-Reference: 20050107041723.207071B7727@voluntocracy.org -->
<!--X-Reference: 20050107125109.GB18722@ogre.szonye.com -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: Floating-point formats and standards</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00108.html">Date Prev</a>][<a href="msg00110.html">Date Next</a>][<a href="msg00105.html">Thread Prev</a>][<a href="msg00110.html">Thread Next</a>][<a href="maillist.html#00109">Date Index</a>][<a href="threads.html#00109">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: Floating-point formats and standards</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-58">SRFI 58</a> from before July 7th, 2015.  The new archives for SRFI 58 are <a href="http://srfi-email.schemers.org/srfi-58/">here</a>.  Eventually, the entire history will be moved there, including any new messages.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: <a href="mailto:bradd%2Bsrfi@DOMAIN.HIDDEN">bradd+srfi@xxxxxxxxxx</a></li>
<li><em>Subject</em>: Re: Floating-point formats and standards</li>
<li><em>From</em>: Aubrey Jaffer &lt;<a href="mailto:agj@DOMAIN.HIDDEN">agj@xxxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Mon, 17 Jan 2005 00:13:17 -0500 (EST)</li>
<li><em>Cc</em>: <a href="mailto:srfi-58@DOMAIN.HIDDEN">srfi-58@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-58@DOMAIN.HIDDEN">srfi-58@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:20050107125109.GB18722@DOMAIN.HIDDEN">20050107125109.GB18722@xxxxxxxxxxxxxxx</a>&gt; (<a href="mailto:bradd%2Bsrfi@DOMAIN.HIDDEN">bradd+srfi@xxxxxxxxxx</a>)</li>
<li><em>References</em>: &lt;<a href="mailto:Pine.LNX.4.58.0412301550550.3862@DOMAIN.HIDDEN">Pine.LNX.4.58.0412301550550.3862@xxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20050105012438.GD6573@DOMAIN.HIDDEN">20050105012438.GD6573@xxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20050105055413.5FA901B7717@DOMAIN.HIDDEN">20050105055413.5FA901B7717@xxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20050105114809.GB9007@DOMAIN.HIDDEN">20050105114809.GB9007@xxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20050105122227.GC9007@DOMAIN.HIDDEN">20050105122227.GC9007@xxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20050105170342.348AC1B7719@DOMAIN.HIDDEN">20050105170342.348AC1B7719@xxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20050106004956.GB10975@DOMAIN.HIDDEN">20050106004956.GB10975@xxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20050106060805.D2EEC1B7727@DOMAIN.HIDDEN">20050106060805.D2EEC1B7727@xxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20050106104820.GA14471@DOMAIN.HIDDEN">20050106104820.GA14471@xxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20050107041723.207071B7727@DOMAIN.HIDDEN">20050107041723.207071B7727@xxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20050107125109.GB18722@DOMAIN.HIDDEN">20050107125109.GB18722@xxxxxxxxxxxxxxx</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre> | Date: Fri, 7 Jan 2005 04:51:09 -0800
 | From: &quot;Bradd W. Szonye&quot; &lt;bradd+srfi@xxxxxxxxxx&gt;
 | 
 | Brief summary: More praise, a few minor suggestions, and one major
 | issue.
 | 
 | I thought of two more items for the syntax examples.
 | 
 | 1. They should include examples of how to write arrays with empty
 |    dimensions. (I hope I got all these right.)
 |    
 |    #A0*2()
 |    #A2*0(() ()).
 |    #A2*0*3(() ()).
 |    #A2*3*0((() () ()) (() () ())).

Yes; I added these.

 | 2. It should be an error to write any array with inconsistent or
 |    ambiguous rank or dimension specifiers.
 | 
 |    #3A()           array shape is ambiguous
 |    #2A((1 2) (1))  column widths are inconsistent
 |    #3A1*1((1))     rank is inconsistent with dimension specifier

I have added a sentence to that effect.

 | &gt;&gt; ... but it also unifies the dimension syntax with the #n(...)
 | &gt;&gt; vector syntax of Common Lisp and PLT Scheme.
 | 
 | &gt; Can you describe the PLT compatibility?
 | 
 | PLT Scheme implements the Common Lisp #n(...) syntax with two extensions.
 | 
 | In Common Lisp, #n(v.1 v.2 ... v.k) creates a vector of size N, with the
 | final value, v.k, repeated (N - K) times. It's an error if (K &gt; N) or if
 | (K = 0 and N &gt; 0). Examples:
 | 
 |     #5(1 2) ==&gt; #(1 2 2 2 2)
 |     #2(1 2) ==&gt; #(1 2)
 |     #0()    ==&gt; #()
 |     #1(1 2) ==&gt; error: too many values
 |     #5()    ==&gt; error: no values for non-empty array
 | 
 | PLT Scheme adds two extensions: If (K = 0), the vector is filled with 0,
 | and if (K &gt; N) the reader raises a specific exception. If &quot;it is an
 | error&quot; means the same thing in Common Lisp as it does in Scheme, these
 | are pure extensions of the CL feature.

Thanks; I have added your descriptions.

 | With the &quot;A&quot; optional, the array literal syntax is consistent with
 | CL/PLT: #3(1 2 3) == #A3(1 2 3) == #1A3(1 2 3) == #1A(1 2 3).
 | 
 | &gt;&gt; Don't forget to give semantics and examples for the shaped-array
 | &gt;&gt; syntax.  I don't particularly care whether you define the repeat-fill
 | &gt;&gt; rule; feel free to leave it for a later SRFI if you don't want to
 | &gt;&gt; write it up.

SRFI-58 will pass.

 | &gt;&gt; That covers all of the basic types.  Only binaryx [x86] is missing ....
 | 
 | &gt; I think you will find that vectorized instructions don't pack
 | &gt; non-power-of-2 bit widths.  Breaking operands over cache-line
 | &gt; boundaries is a huge hassle for hardware.
 | &gt; 
 | &gt; So the 80-bit and 96-bit are likely stored into 128 bits.  We might as
 | &gt; well call them 128b.
 | 
 | Ah, OK.  That's good enough for now, since I know of no
 | implementations with both x86 and quad flonums.  I suppose it could
 | happen in the future, if Intel keeps binaryx and adds binary128,

If a CPU had both 96.bit and 128.bit formats, which would both occupy
128.bits in memory, why would one want to use the 96.bit format?

 | but that's probably 5 to 10 years off, if it happens at all.  If it
 | ever becomes a problem, it wouldn't be hard to add flox96b
 | specifiers.
 | 
 | &gt; This text I added describes how sizes are chosen:
 | &gt;
 | &gt;   Implementations are required to accept all of the type denotations.
 | &gt;   Uniform types of matching sizes which the platform supports will be
 | &gt;   used; the others will be represented as the next larger format of
 | &gt;   the same type implemented.  If there is no larger format of the same
 | &gt;   type and there is a bignum format for that element type, then the
 | &gt;   array format defaults to vector; otherwise the largest uniform
 | &gt;   format of that type is used.
 | 
 | I'll try an example to make sure I understand the intent correctly.
 | Suppose that I'm targeting all the machines in an HP data center
 | (a mix of x86, Itanium, and PA-RISC).
 | 
 |     flor128b =&gt; x86 extended (binaryx) on x86 and Itanium
 |     flor16b  =&gt; IEEE single (binary32) on all three systems
 |     fixz64b  =&gt; bignum on x86, or signed32 if there are no bignums
 | 
 | I have one major issues with the rule as written above: It's not clear
 | what to do if the system lacks a flonum format altogehter.

Implementations which don't have inexacts can't do inexact
computations.  SRFI-58 doesn't try to remedy that.

 | For example, if you have no decimal flonums at all, you should
 | probably use rational bignums instead (because binary flonums are
 | unacceptable for the major decnum applications).  However, if
 | rational bignums are allowed as a &quot;flonum&quot; format, then the rule
 | above would prefer them over binaryx.

Bignums are not fixed size.  Uniform arrays are for fixed-size number
formats only.

 | The essential problem here is that flonum, decnum, and fixnum
 | typically have different requirements.  In general, precision and
 | range are non-negotiable for fixnums and decnums: Users only
 | specify the large types when the data requires it.  However, speed
 | is usually more important than precision for binary flonums.
 | 
 | It might be best to specify each major element type separately.
 | Here are my recommendations for defaults when there's format large
 | enough.  Each offers a list of acceptable possibilities, roughly in
 | order from most to least desirable.  An implementation should
 | document its behavior (and should allow users to reconfigure that
 | behavior).
 | 
 | Binary flonum (floTWb)
 | a. largest available binary flonum
 | b. arbitrary-precision floating-point number (a &quot;floating-point bignum&quot;)
 | c. rational bignum
 | d. none (signal an error)
 | 
 | Decimal flonum (floTWd)
 | a. arbitrary-precision floating-point number
 | b. rational bignum
 | c. binary flonum with at least 2W precision
 | d. none (signal an error)
 | e. largest available decimal flonum
 | 
 | Fixnum (fixTWb)
 | a. flonum with at least W bits precision in the significand
 | b. bignum
 | c. none (signal an error)

SRFI-47 is about fixed-size number representations, not about type
declaration.  Here are the defaulting rules from SRFI-47's replacement
(submitted today).  An assumption of this SRFI is that no uniform
types are larger than the Scheme implementation supports as numbers.
The decimal rules probably need further development, which is
difficult without experience using decimal formats.

     Prototype Procedures

 Implementations are required to define all of the prototype procedures.
 Uniform types of matching format and sizes which the platform supports
 will be used; the others will be represented as follows:

 For inexact flonum complex arrays:

     * the next larger complex format is used;
     * if there is no larger format,
	   o then if the implementation supports complex floating-point
	     numbers of unbounded precision,
		 + then a heterogeneous array;
		 + else the largest inexact flonum complex array. 

 For inexact flonum real arrays:

     * the next larger real format is used;
     * if there is no larger real format, then the next larger complex
       format is used.
     * If there is no larger complex format,
	   o then if the implementation supports floating-point real
	     numbers of unbounded precision,
		 + then a heterogeneous array;
		 + else the largest inexact flonum real or complex array. 

 For exact decimal flonum arrays:

     * the next larger decimal flonum format array is used;
     * If there is no larger decimal flonum format, then a heterogeneous
       array is used. 

 For exact bipolar fixnum arrays:

     * the next larger bipolar fixnum format array is used;
     * If there is no larger bipolar fixnum format,
	   o then if the implementation supports exact integers of
	     unbounded precision,
		 + then a heterogeneous array;
		 + else the largest bipolar fixnum array. 

 For exact nonnegative fixnum arrays:

     * the next larger nonnegative fixnum format array is used;
     * If there is no larger nonnegative fixnum format,
	   o then the next larger bipolar fixnum format is used.
	   o If there is no larger bipolar fixnum format,
		 + then if the implementation supports exact integers of
		   unbounded precision,
		       # then a heterogeneous array;
		       # else the largest nonnegative or bipolar fixnum
			 array. 

 This arrangement has platforms which support uniform array types
 employing them, with less capable platforms using vectors; but all
 working compatibly from the same source code.

 | &gt;&gt; No fixq arrays for rational numbers?  C'mon, you know you want to!
 | 
 | &gt; Although the syntax could easily specify arbitrary precisions, the
 | &gt; prototype functions would need to take extra arguments.  Should the
 | &gt; precision be specified as total bits and fractional bits; or integral
 | &gt; bits and fractional bits?
 | 
 | Oh, I figured they'd work like complex numbers, e.g., a fixq32b would
 | have a 32-bit numerator and a 32-bit denominator. (That is how complex
 | numbers work, right?)

I think rationals composed of fixed-width integers don't behave well
with regard to error bands and rounding.  They certainly waste a large
portion of the integer pairs.

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00110" href="msg00110.html">Re: Floating-point formats and standards</a></strong>
<ul><li><em>From:</em> Bradd W. Szonye</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00007" href="msg00007.html">Re: #\a octothorpe syntax vs SRFI 10</a></strong>
<ul><li><em>From:</em> bear</li></ul></li>
<li><strong><a name="00068" href="msg00068.html">Re: #\a octothorpe syntax vs SRFI 10</a></strong>
<ul><li><em>From:</em> Bradd W. Szonye</li></ul></li>
<li><strong><a name="00084" href="msg00084.html">Re: #\a octothorpe syntax vs SRFI 10</a></strong>
<ul><li><em>From:</em> Aubrey Jaffer</li></ul></li>
<li><strong><a name="00087" href="msg00087.html">Floating-point formats and standards</a></strong>
<ul><li><em>From:</em> Bradd W. Szonye</li></ul></li>
<li><strong><a name="00088" href="msg00088.html">Re: Floating-point formats and standards</a></strong>
<ul><li><em>From:</em> Bradd W. Szonye</li></ul></li>
<li><strong><a name="00096" href="msg00096.html">Re: Floating-point formats and standards</a></strong>
<ul><li><em>From:</em> Aubrey Jaffer</li></ul></li>
<li><strong><a name="00098" href="msg00098.html">Re: Floating-point formats and standards</a></strong>
<ul><li><em>From:</em> Bradd W. Szonye</li></ul></li>
<li><strong><a name="00101" href="msg00101.html">Re: Floating-point formats and standards</a></strong>
<ul><li><em>From:</em> Aubrey Jaffer</li></ul></li>
<li><strong><a name="00102" href="msg00102.html">Re: Floating-point formats and standards</a></strong>
<ul><li><em>From:</em> Bradd W. Szonye</li></ul></li>
<li><strong><a name="00103" href="msg00103.html">Re: Floating-point formats and standards</a></strong>
<ul><li><em>From:</em> Aubrey Jaffer</li></ul></li>
<li><strong><a name="00105" href="msg00105.html">Re: Floating-point formats and standards</a></strong>
<ul><li><em>From:</em> Bradd W. Szonye</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00108.html">Re: Scheme flonum literals</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00110.html">Re: Floating-point formats and standards</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00105.html">Re: Floating-point formats and standards</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00110.html">Re: Floating-point formats and standards</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00109"><strong>Date</strong></a></li>
<li><a href="threads.html#00109"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
