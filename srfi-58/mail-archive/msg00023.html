<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: #\a octothorpe syntax vs SRFI 10 -->
<!--X-From-R13: pnzcoryyNnhgbqevc.oybbqnaqpbssrr.arg -->
<!--X-Date: Sat,  1 Jan 2005 07:44:45 +0100 (NFT) -->
<!--X-Message-Id: Pine.LNX.4.44.0412311233180.20835&#45;100000@autodrip.bloodandcoffee.net -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 41D5A36E.30205@bothner.com -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: #\a octothorpe syntax vs SRFI 10</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00022.html">Date Prev</a>][<a href="msg00024.html">Date Next</a>][<a href="msg00063.html">Thread Prev</a>][<a href="msg00025.html">Thread Next</a>][<a href="maillist.html#00023">Date Index</a>][<a href="threads.html#00023">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: #\a octothorpe syntax vs SRFI 10</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-58">SRFI 58</a> from before July 7th, 2015.  The <a href="http://srfi-email.schemers.org/srfi-58">new archives</a> for SRFI 58 contain all messages, not just those from before July 7th, 2015.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: Per Bothner &lt;<a href="mailto:per@DOMAIN.HIDDEN">per@xxxxxxxxxxx</a>&gt;</li>
<li><em>Subject</em>: Re: #\a octothorpe syntax vs SRFI 10</li>
<li><em>From</em>: <a href="mailto:campbell@DOMAIN.HIDDEN">campbell@xxxxxxxxxxxxxxxxxxxxxxxxxxx</a></li>
<li><em>Date</em>: Fri, 31 Dec 2004 23:26:25 -0800 (PST)</li>
<li><em>Cc</em>: Aubrey Jaffer &lt;<a href="mailto:agj@DOMAIN.HIDDEN">agj@xxxxxxxxxxxx</a>&gt;, &lt;<a href="mailto:srfi-58@DOMAIN.HIDDEN">srfi-58@xxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-58@DOMAIN.HIDDEN">srfi-58@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:41D5A36E.30205@DOMAIN.HIDDEN">41D5A36E.30205@xxxxxxxxxxx</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>On Fri, 31 Dec 2004, Per Bothner wrote:

&gt; campbell@xxxxxxxxxxxxxxxxxxxxxxxxxxx wrote:
&gt; 
&gt; &gt; Why doesn't Common Lisp's notation require just as strong of a
&gt; &gt; justification?
&gt; 
&gt; Scheme's syntax is in general very close to Common Lisp's.  This
&gt; includes the notation for vectors.  The Common Lisp vector and
&gt; array notations are related, which makes sense since a vector
&gt; is a special case of an array.  The Scheme vector notation is
&gt; the same as the Common Lisp vector notation.  Having a completely
&gt; different array notation would reduce interoperability and
&gt; skill transferability for no good reason.

Interoperability is impossible anyway.  How do you deal with Common
Lisp's package system?  However, arrays are arrays, regardless of how
you write them.  There is no significant difference in 'skills' between
Common Lisp arrays and SRFI 47 arrays with a #,(ARRAY ...) syntax.
Moreover, there _is_ a good reason for having a SRFI-10-bases syntax as
opposed to Common Lisp's #\a octothorpe reader syntax: to make Scheme's
syntax simpler &amp; more consistent.  This is not just simply a nice thing
to have, but one of the hallmarks of Scheme in the first place.  It is
_not_ a good idea to complicate it totally unnecessarily, just to
retain a vague notion of compatibility with old, crufty Lisps.

&gt; I'm also concerned about stylistic compatibility within Scheme itself,
&gt; regardless of Common Lisp.  Requiring SRFI-10 notation for arrays but
&gt; not for vectors, is really ugly and makes arrays into second-class
&gt; constructs, which is unfortunate given that vectors are just a special
&gt; case of arrays.

I think it would be perfectly fine, except for backwards compatibility
problems, to flush the #(...) vector syntax in favour of a more general
array syntax.  I'm confused as to why using SRFI 10 makes things
'second-class,' however.  What makes SRFI 10 degrade the class of what
it is used to represent?  There seems to be a great deal of aversion to
SRFI 10 here that I don't understand.

&gt; Some Scheme implementations may already support Common Lisp's #A syntax.

So they can keep doing so.  Making the #,(ARRAY ...) syntax standard
wouldn't hurt them.  Making the #nA...(...) syntax standard, however,
_would_ hurt simplicity &amp; consistency in Scheme's syntax.

&gt; &gt; Unless you can point to a very good justification of
&gt; &gt; the notation in Common Lisp, this assertion is rather useless.  This
&gt; &gt; could, after all, be carried out to the extreme, in which case I might
&gt; &gt; ask: why aren't you using Common Lisp?
&gt; 
&gt; Actually, I'm more of a Scheme implementor than a Scheme user.
&gt; There are things I prefer in Common Lisp, and things I prefer
&gt; in Scheme.  The former includes the array/sequence model, and
&gt; the concept (but not the syntax) of optional type declarations.

OK, but you still haven't given a decent justification of Common Lisp's
array syntax.  All you've said is that you like a couple of features
that Common Lisp supports.

&gt; &gt; No: type specifiers are a fundamentally different thing from what I've
&gt; &gt; been calling somewhat misleadingly 'array element type specifiers.'
&gt; &gt; What arrays require is a _representation_ specifier: it needs to know
&gt; &gt; what each element will represent &amp; how much space is needed to do so.
&gt; &gt; Type specifiers are an entirely different matter altogether.
&gt; 
&gt; They're not that different at all.  Type spcifiers in Kawa also
&gt; affect representation.  For example in Kawa:
&gt;    (let ((i :: &lt;int&gt; init-expr)) ...)
&gt; The variable i is represented as an immediate (unboxed) 32-bit integer.
&gt; In:
&gt;    (let ((j :: &lt;integer&gt; init-expr)) ...)
&gt; The variable j is an object reference (boxed), but it is required to
&gt; be a reference to a gnu.math.IntNum object.  This is not just a
&gt; specification, since it goes all the way down to the bytecode verifier.

Perhaps I'm missing the point you were trying to make here, but I don't
see how this is a good example of how type specifiers could work in
standard Scheme: you've demonstrated that Kawa has a syntax capable of
assigning Java classes/types to Scheme variables, which affects the
Java byte code that is generated.  This does not seem very useful for
other Scheme type systems or for array element representations.

&gt; I'm not proposing a &quot;comprehensive static type system&quot;, but optional
&gt; static typing has quite useful, if nothing else as documentation
&gt; checked by compiler and/or run-time.  I don't like some aspects of
&gt; the Common Lisp type declaration facility, but I think it's a mistake
&gt; for any serious programming language not have them.  Type specifiers
&gt; don't have to be &quot;complete&quot; to be useful.

I agree that optional static type annotations can be useful.  However,
they are not only _far_ outside the scope of this SRFI but also ill-
suited to the matter of describing array element representations.

&gt; I'm not suggesting type specifiers, at least not for this srfi.  What I
&gt; am requesting is that &quot;array type specifiers&quot; should be written to
&gt; use &quot;element type names&quot;, not &quot;array type names&quot;, and that element
&gt; type names should be identifiers that would make sense it somebody
&gt; *does* do type specifiers.  I.e. instead of &quot;aint32&quot; or &quot;as32&quot;
&gt; use &quot;int32&quot; or (for example) &quot;array:int32&quot; (depending on context).

OK, it seems we violently agree here that the element representation
specifier should be cleanly separated from the ARRAY token, although I
don't consider ARRAY:INT32 to have a clean separation: it would read as
an atomic symbol to Scheme.

&gt; Some Scheme implementations *do* support type specifiers, and of those
&gt; specifiers some are also representation specifiers; please don't invent
&gt; an array type syntax incompatible with type specifiers for declarations.

Since the static type systems of those Schemes that support them tend
to differ incompatibly anyway, I'm not sure how this could be avoided;
however, I don't see how my proposed SRFI-10-based syntax, #,(ARRAY
&lt;rank&gt; &lt;elt-rep&gt; &lt;contents&gt;), is intrinsically incompatible with all of
those systems.  Or perhaps I misunderstood and you were referring to
the current #&lt;rank&gt;A&lt;abbreviated-element-representation&gt;(&lt;contents&gt;)
syntax?

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00025" href="msg00025.html">Re: #\a octothorpe syntax vs SRFI 10</a></strong>
<ul><li><em>From:</em> Per Bothner</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00015" href="msg00015.html">Re: #\a octothorpe syntax vs SRFI 10</a></strong>
<ul><li><em>From:</em> Per Bothner</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00022.html">Re: #\a octothorpe syntax vs SRFI 10</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00024.html">Re: #\a octothorpe syntax vs SRFI 10</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00063.html">Re: #\a octothorpe syntax vs SRFI 10</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00025.html">Re: #\a octothorpe syntax vs SRFI 10</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00023"><strong>Date</strong></a></li>
<li><a href="threads.html#00023"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
