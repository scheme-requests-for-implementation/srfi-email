<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: SRFI&#45;10 syntax vs. #nA syntax -->
<!--X-From-R13: Fnlybe Qnzcoryy <pnzcoryyNoybbqnaqpbssrr.arg> -->
<!--X-Date: Wed,  5 Jan 2005 03:52:12 +0100 (NFT) -->
<!--X-Message-Id: Pine.LNX.4.44.0501041728150.3784&#45;100000@autodrip.bloodandcoffee.net -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20050105000739.GC6573@ogre.szonye.com -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: SRFI-10 syntax vs. #nA syntax</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00075.html">Date Prev</a>][<a href="msg00077.html">Date Next</a>][<a href="msg00074.html">Thread Prev</a>][<a href="msg00086.html">Thread Next</a>][<a href="maillist.html#00076">Date Index</a>][<a href="threads.html#00076">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: SRFI-10 syntax vs. #nA syntax</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-58">SRFI 58</a> from before July 7th, 2015.  The <a href="http://srfi-email.schemers.org/srfi-58">new archives</a> for SRFI 58 contain all messages, not just those from before July 7th, 2015.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: &quot;Bradd W. Szonye&quot; &lt;<a href="mailto:bradd%2Bsrfi@DOMAIN.HIDDEN">bradd+srfi@xxxxxxxxxx</a>&gt;</li>
<li><em>Subject</em>: Re: SRFI-10 syntax vs. #nA syntax</li>
<li><em>From</em>: Taylor Campbell &lt;<a href="mailto:campbell@DOMAIN.HIDDEN">campbell@xxxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Tue, 4 Jan 2005 19:34:47 -0800 (PST)</li>
<li><em>Cc</em>: <a href="mailto:srfi-58@DOMAIN.HIDDEN">srfi-58@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-58@DOMAIN.HIDDEN">srfi-58@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:20050105000739.GC6573@DOMAIN.HIDDEN">20050105000739.GC6573@xxxxxxxxxxxxxxx</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>On Tue, 4 Jan 2005, Bradd W. Szonye wrote:

&gt; For what it's worth, I don't like the new names. I agree with Per
&gt; Bothner that using &quot;integer+&lt;bits&gt;&quot; to mean &quot;unsigned fixnum&quot; is
&gt; counterintuitive. Also, there's very little visual distinction between
&gt; that and &quot;integer-&lt;bits&gt;,&quot; which breaks an important guideline for
&gt; identifier naming. The alternate suggestion of &quot;integer-&lt;bits&gt;+&quot; is no
&gt; better.

I don't disagree here; my original beef was just with the excessive
abbreviation.  My suggestion of INTEGER&lt;bits&gt;+ was only a very minor
one that I'm not set on: it was only a suggestion as a better way to
use + to indicate the sign, as opposed to what the current draft uses
(the INTEGER{+,-}&lt;bits&gt; device).  I have no objections to using some
other convention for indicating an implicit positive sign (/absence of
sign), as long as it is not unreadably obscure like AU32.

&gt; Furthermore, the &quot;long&quot; names don't correlate well to the array
&gt; prototyping functions defined in SRFI 47. While AC32 and :complex-32
&gt; have a reasonable mnemonic connection, the same pattern doesn't apply to
&gt; AU32 and :integer+32 or to AT1 and :boolean.

I did mention when I first suggested longer names that I thought SRFI
47's naming scheme was awful but also that it may not be a good idea to
break consistency with it.  (I have no idea where AT1 came from,
though, which is why I suggested BOOLEAN.)

&gt; Finally, I dislike the mixture of math and hardware terminology. If the
&gt; goal of heterogeneous arrays is to match the hardware, use hardware-
&gt; speak consistently. The floating-point arrays are especially bad: If you
&gt; mean &quot;IEEE 754 single-precision floating-point number,&quot; then call it
&gt; that (or some reasonable abbreviation, like &quot;single&quot; or even &quot;s&quot;).
&gt; Calling it a &quot;real-32&quot; is less descriptive.

This sounds quite reasonable.  I support this naming change (and the
other suggestions for changes in your more extensive discussion of the
floating-point-related names), though I have nothing more to say on the
matter.  (I suggested REAL-32 only because it was already called AR32
or something.)

&gt; &gt; [Now] the syntax is still as complicated -- perhaps even slightly more
&gt; &gt; so --, not possible to implement based on SRFI 10, and even
&gt; &gt; incompatible with Common Lisp &amp; SLIB!
&gt; 
&gt; I don't get this. It looks like a purely cosmetic change to me, no more
&gt; incompatible with other formats than the original was.

The only matter at hand _is_ cosmetics: that's what the whole debate of
syntax is!  The original format, however, was, I believe, compatible
with both Common Lisp &amp; SLIB, for the subsets where there was semantic
intersection (with heterogeneous arrays).

&gt; &gt; This [elided] is an argument that has been repeatedly cited in the
&gt; &gt; totally wrong context.  This is an argument for having arrays at all.
&gt; &gt; What is in question here is the _syntax_ for arrays.  SRFI 10 is for
&gt; &gt; consistent &amp; simple extension of Scheme's syntax, which is
&gt; &gt; fundamentally centred around lists &amp; symbols, but which has nothing to
&gt; &gt; do with arrays at all.
&gt; 
&gt; You say that like it's a good thing. I disagree; like Bear and Aubrey, I
&gt; believe that the lack of a terse array syntax is a weakness in the
&gt; language.

This claim has not been defended.  What is important is not the way one
can write a literal array but the ease with which one can _operate_ on
arrays.  As I have suggested already, if you want this to be improved,
work on a comprehensive array library; it is unrelated to the
complication of Scheme's syntax.

&gt; ...nor do I like the use of rank instead of shape in the array token.

Using shape instead of rank deserves a different discussion: it might
be better to bring it up in a new thread, so that it doesn't get bogged
down by the discussion of the base syntax.  I think it would probably
be a good idea, too, though I, again, don't passionately care one way,
and I also haven't thought it through very carefully yet.

&gt; &gt; I do not deny that arrays are a very important thing to have.  They
&gt; &gt; should not, however, completely unnecessarily complicate an otherwise
&gt; &gt; almost unmarred syntax that is one of the hallmarks of Scheme.
&gt; 
&gt; I think SRFI 10 itself unnecessarily complicates the language. The
&gt; syntax is cumbersome and verbose, and the specification has some bugs.

Cumbersome &amp; verbose as compared to what equally general syntactic
extension, and what bugs do you refer to aside from what you allege to
be problems with how SRFI 10 relates to quasiquotation?

&gt; Worse, it does not (as written) permit quasiquotation, which is
&gt; important for describing arrays with fixed shape but variable elements.
&gt; The current version of SRFI 58 doesn't describe quasiquotation either,
&gt; but at least it's possible to extend it that way. SRFI 10 seems to
&gt; forbid quasiquotation entirely. (See my comments on the
&gt; post-finalization mailing list for SRFI 10.)

The facts you discovered concerning the allowed placement of SRFI 10
#,(...) forms are correct.  The conclusions drawn are not.  It does not
always make sense that quasiquotation should apply to all SRFI 10
constructors, such as homogeneous arrays, which _can't_ hold list
structures (the structures that, for example, the #\, syntax expands
to, (UNQUOTE ...)).  On the other hand, there is nothing that SRFI 10
instated to _prevent_ new SRFIs from defining constructor tags such
that the surrounding #,(...) may be used within a quasiquotation.  The
more significant issue, however, is whether or not the unquoting within
the #,(...) will be processed by the macro transformer for QUASIQUOTE,
which must be extended for every new data type given a new #,(...) tag
that one wishes to allow to be used as lists &amp; vectors may be in
quasiquotations.

Note, by the way, that your `,'#,(...) example -- (QUASIQUOTE (UNQUOTE
(QUOTE #,(...)))) -- would not have the same effect as simply `#,(...),
even assuming all SRFI 10 data were allowed in quasiquotations.  The
SRFI 10 datum is simply embedded in a quote; it is the same as writing
'#,(...) -- (QUOTE #,(...)) -- in the first place.  This is consistent
with the rest of SRFI 10, which does not specify how the #,(...) form
operates with quasiquotation.

&gt; &gt; Arrays are fundamental to computing, yes, but not fundamental to
&gt; &gt; Scheme's syntax.
&gt; 
&gt; The SRFI is no good unless the array syntax is usable, and SRFI 10 isn't
&gt; good enough, technically or aesthetically.

This has not been substantiated technically, and it is worthless to
repeatedly argue of aesthetics when neither side has any clear
advantage.

&gt; &gt;&gt; [snipped long list of applications for arrays]
&gt; 
&gt; &gt; I have responded to this already: these are all uses for arrays, but
&gt; &gt; they have very little to do with _hand-written_ literal arrays ....
&gt; 
&gt; I don't know how you came to this conclusion, and I don't know why
&gt; you're repeating this false claim even after Bear's extended example
&gt; (literal matrices for coordinate transformations in graphics
&gt; programming).

I came to this conclusion after bear mentioned such programs _dumping_
_S-expressions_.  The part of the sentence that you deleted had
significance as well: '...and a lot of them will involve large data
sets that will completely dwarf the size of the initial few characters
of the literal array.'  Furthermore, I showed that bear's example is
_hardly_ more verbose or column-consuming than his original vectors;
it would not be much different with the current proposed array syntax,
either.  And this is for a fairly _small_ matrix.

&gt; Vector and array literals are extremely important in some application
&gt; areas, especially graphics programming.

I don't deny that.  I deny, however, that it is worthwhile to
unnecessarily complicate Scheme's syntax just so that it is made almost
the _tiniest_ bit more convenient to write a literal array.

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00086" href="msg00086.html">Re: SRFI-10 syntax vs. #nA syntax</a></strong>
<ul><li><em>From:</em> Bradd W. Szonye</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00067" href="msg00067.html">Re: SRFI-10 syntax vs. #nA syntax</a></strong>
<ul><li><em>From:</em> Bradd W. Szonye</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00075.html">Re: SRFI-10 syntax vs. #nA syntax</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00077.html">Re: SRFI-10 syntax vs. #nA syntax</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00074.html">Re: SRFI-10 syntax vs. #nA syntax</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00086.html">Re: SRFI-10 syntax vs. #nA syntax</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00076"><strong>Date</strong></a></li>
<li><a href="threads.html#00076"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
