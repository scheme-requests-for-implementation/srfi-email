<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: SRFI&#45;10 syntax vs. #nA syntax -->
<!--X-From-R13: "Penqq I. Embalr" <oenqq+fesvNfmbalr.pbz> -->
<!--X-Date: Wed,  5 Jan 2005 08:55:34 +0100 (NFT) -->
<!--X-Message-Id: 20050105075527.GA9007@ogre.szonye.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20050105000739.GC6573@ogre.szonye.com -->
<!--X-Reference: Pine.LNX.4.44.0501041728150.3784&#45;100000@autodrip.bloodandcoffee.net -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: SRFI-10 syntax vs. #nA syntax</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00085.html">Date Prev</a>][<a href="msg00087.html">Date Next</a>][<a href="msg00076.html">Thread Prev</a>][<a href="msg00078.html">Thread Next</a>][<a href="maillist.html#00086">Date Index</a>][<a href="threads.html#00086">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: SRFI-10 syntax vs. #nA syntax</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-58">SRFI 58</a> from before July 7th, 2015.  The <a href="http://srfi-email.schemers.org/srfi-58">new archives</a> for SRFI 58 contain all messages, not just those from before July 7th, 2015.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: <a href="mailto:srfi-58@DOMAIN.HIDDEN">srfi-58@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Subject</em>: Re: SRFI-10 syntax vs. #nA syntax</li>
<li><em>From</em>: &quot;Bradd W. Szonye&quot; &lt;<a href="mailto:bradd%2Bsrfi@DOMAIN.HIDDEN">bradd+srfi@xxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Tue, 4 Jan 2005 23:55:27 -0800</li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-58@DOMAIN.HIDDEN">srfi-58@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:Pine.LNX.4.44.0501041728150.3784-100000@DOMAIN.HIDDEN">Pine.LNX.4.44.0501041728150.3784-100000@xxxxxxxxxxxxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Mail-followup-to</em>: <a href="mailto:srfi-58@DOMAIN.HIDDEN">srfi-58@xxxxxxxxxxxxxxxxx</a></li>
<li><em>References</em>: &lt;<a href="mailto:20050105000739.GC6573@DOMAIN.HIDDEN">20050105000739.GC6573@xxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:Pine.LNX.4.44.0501041728150.3784-100000@DOMAIN.HIDDEN">Pine.LNX.4.44.0501041728150.3784-100000@xxxxxxxxxxxxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>User-agent</em>: Mutt/1.4.1i</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>Taylor Campbell wrote:
&gt;&gt;&gt; [Now] the syntax is still as complicated -- perhaps even slightly
&gt;&gt;&gt; more so --, not possible to implement based on SRFI 10, and even
&gt;&gt;&gt; incompatible with Common Lisp &amp; SLIB!

Bradd wrote:
&gt;&gt; I don't get this. It looks like a purely cosmetic change to me, no
&gt;&gt; more incompatible with other formats than the original was.

&gt; The only matter at hand _is_ cosmetics: that's what the whole debate
&gt; of syntax is!

By &quot;purely cosmetic,&quot; I meant that nothing changed but the names of the
heterogeneous array types. The only syntactic change was making the rank
mandatory: #[n]A[tag] became #nA[tag]. How can you possibly portray this
as &quot;slightly more complicated&quot;? Making the rank mandatory simplifies
parsing somewhat.

&gt; The original format, however, was, I believe, compatible with both
&gt; Common Lisp &amp; SLIB, for the subsets where there was semantic
&gt; intersection (with heterogeneous arrays).

How has this changed? You still write #5A(...) for a rank-5 array, just
like the original proposal, and just like Common Lisp.

&gt;&gt;&gt; ... Scheme's syntax ... is fundamentally centred around lists &amp;
&gt;&gt;&gt; symbols, but which has nothing to do with arrays at all.

&gt;&gt; You say that like it's a good thing. I disagree; like Bear and
&gt;&gt; Aubrey, I believe that the lack of a terse array syntax is a weakness
&gt;&gt; in the language.

&gt; This claim has not been defended. What is important is not the way one
&gt; can write a literal array but the ease with which one can _operate_ on
&gt; arrays ....

Sorry, you keep saying this, and it simply isn't true. Bear did defend
the claim, with a list of applications that demand terse syntax (because
array literals are very common) /and/ a good library (because they
perform non-trivial array manipulation).

&gt;&gt; I don't know how you came to this conclusion, and I don't know why
&gt;&gt; you're repeating this false claim even after Bear's extended example
&gt;&gt; (literal matrices for coordinate transformations in graphics
&gt;&gt; programming).

&gt; I came to this conclusion after bear mentioned such programs _dumping_
&gt; _S-expressions_. Furthermore, I showed that bear's example is _hardly_
&gt; more verbose or column-consuming than his original vectors ....

Hang on, there's something fishy here.

You objected to Bear's original list of array-heavy applications,
asking: &quot;How often do you find yourself in Scheme code wanting to write
literal arrays /by hand/?&quot; (emphasis mine).

He replied, &quot;Look again at the list.  Those are precisely what you asked
for: all are applications of STATIC arrays .... My source code in some
cases is almost five percent literal vectors. A recent example ....&quot;

Later, when Aubrey quoted Bear, you objected again, saying, &quot;I have
responded to this already: these are all uses for arrays, but they have
very little to do with _hand-written_ literal arrays ....&quot; You wrote
this /after/ having read and replied to Bear's quote above.

Here's the sequence:

1. Bear gave a list of applications that use arrays heavily.
2. You doubted the relevance of the list, asking whether they use array
   /literals/ heavily.
3. Bear confirmed that they do, in fact, use literals heavily, sometimes
   up to 5% of the source code.
4. You read and replied to Bear's followup.
5. Later, you claimed that the applications &quot;have very little to do with
   hand-written literal arrays.&quot;

After reading Bear's followup, how can you honestly make that claim? He
demonstrated knowledge and experience in those application areas, as
confirmed by his code example and the agreement of other practitioners.
Despite this, you've gone from doubt to denial to vehement denial. What
is the basis for your claim? You insist that we haven't defended our
claim, while you make increasingly hostile claims of your own about
application areas that you seem to have little experience with.

I suggest that you step back and reconsider the arguments against you,
to make sure that you've understood them and evaluated them fairly.

&gt; The part of the sentence that you deleted had significance as well:
&gt; '...and a lot of them will involve large data sets that will
&gt; completely dwarf the size of the initial few characters of the literal
&gt; array.' 

No, that's not significant. You've attempted this line of argument
several times now: &quot;X is insignificant to a lot of Foo. Therefore, X is
insignificant in general.&quot; That doesn't stand up to scrutiny.

&gt;&gt; I think SRFI 10 itself unnecessarily complicates the language. The
&gt;&gt; syntax is cumbersome and verbose, and the specification has some
&gt;&gt; bugs.

&gt; Cumbersome &amp; verbose as compared to what equally general syntactic
&gt; extension ....

We don't want an &quot;equally general syntactic extension.&quot; The generality
is exactly what makes it cumbersome and verbose. Like all things that
try to please everyone equally well, it pleases them equally poorly.

&gt; ... and what bugs do you refer to aside from what you allege to be
&gt; problems with how SRFI 10 relates to quasiquotation?

Aside from? That isn't enough on its own?

&gt;&gt; Worse, [SRFI 10] does not (as written) permit quasiquotation, which
&gt;&gt; is important for describing arrays with fixed shape but variable
&gt;&gt; elements ....

&gt; The facts you discovered concerning the allowed placement of SRFI 10
&gt; #,(...) forms are correct.  The conclusions drawn are not.  It does
&gt; not always make sense that quasiquotation should apply to all SRFI 10
&gt; constructors, such as homogeneous arrays, which _can't_ hold list
&gt; structures (the structures that, for example, the #\, syntax expands
&gt; to, (UNQUOTE ...)) ....

Huh? Your examples don't make sense. Suppose that INTEGER-VECTOR is a #,
constructor for constructing homogeneous vectors of integers. This
quasiquotation makes perfect sense:

    `#,(integer-vector 1 2 ,a 4 5)

If a is 3, that's a reasonable expression (assuming a quasiquote
implementation that does the right thing). If a is (list 3 3 3), it's an
error, but it's exactly the same error as writing

    '#,(integer-vector 1 2 (3 3 3) 4 5)

which is already allowed by the #, syntax. How exactly does
quasiquotation &quot;not make sense&quot; here? How does it fail in a way that
doesn't also fail in the equivalent QUOTE form?

&gt; On the other hand, there is nothing that SRFI 10 instated to _prevent_
&gt; new SRFIs from defining constructor tags such that the surrounding
&gt; #,(...) may be used within a quasiquotation.

On the contrary, the rationale, the specification, and the recommended
implementation strategy all strongly emphasize read-time evaluation,
which precludes quasiquotation (a run-time feature).

&gt; The more significant issue, however, is whether or not the unquoting
&gt; within the #,(...) will be processed by the macro transformer for
&gt; QUASIQUOTE, which must be extended for every new data type given a new
&gt; #,(...) tag that one wishes to allow to be used as lists &amp; vectors may
&gt; be in quasiquotations.

I think that's correct, and it doesn't play well with the
&quot;define-reader-ctor&quot; implementation offered in SRFI 10 and actually used
by the implementations that support it.

&gt; Note, by the way, that your `,'#,(...) example -- (QUASIQUOTE (UNQUOTE
&gt; (QUOTE #,(...)))) -- would not have the same effect as simply
&gt; `#,(...), even assuming all SRFI 10 data were allowed in
&gt; quasiquotations. The SRFI 10 datum is simply embedded in a quote; it
&gt; is the same as writing '#,(...) -- (QUOTE #,(...)) -- in the first
&gt; place.  This is consistent with the rest of SRFI 10, which does not
&gt; specify how the #,(...) form operates with quasiquotation.

Again: Huh? I think you misunderstood me. I don't expect `,'#,(...) to
work like `#,(...) -- that is, I wasn't looking for a way to trick the
reader into doing quasiquotation inside a #, form. Instead, I was
complaining that you can't even use #,(...) as a literal in a
quasiquotation.

Even if you can't unquote inside a #, form, you should be able to write:

    `(1 ,foo #,(bar)) ==&gt; (1 &lt;foo-thingy&gt; &lt;bar-thingy&gt;)

However, the SRFI syntax does not allow this. Instead, one must write:

    `(1 ,foo ,'#,(bar))

Which is silly.

&gt;&gt; The SRFI is no good unless the array syntax is usable, and SRFI 10
&gt;&gt; isn't good enough, technically or aesthetically.

&gt; This has not been substantiated technically, and it is worthless to
&gt; repeatedly argue of aesthetics when neither side has any clear
&gt; advantage.

As written, it doesn't work with quasiquotation, and I doubt that it
ever will work well with quasiquotation, because it doesn't play nicely
with the define-reader-ctor approach recommended in the SRFI. Making it
a datum instead of a self-evaluating value adds insult to injury, since
you can't even use it in the literal part of a quasiquotation. That
makes it a poor choice for literal syntax, especially for a general-
purpose structure like arrays.

As for aesthetics, just typing #,(...) is horrible, on a US keyboard.
While my &quot;whimsical note&quot; was half-joking, that's only /half/ joking.
It'd take some effort to come up with a worse combination of keystrokes!

&gt; I deny ... that it is worthwhile to unnecessarily complicate Scheme's
&gt; syntax just so that it is made almost the _tiniest_ bit more
&gt; convenient to write a literal array.

I don't think you've demonstrated &quot;complicated&quot; yet, let alone
&quot;unnecessarily.&quot; And SRFI 10 vs Common Lisp syntax is more than a &quot;tiny&quot;
bit less convenient.
-- 
Bradd W. Szonye
<a  rel="nofollow" href="http://www.szonye.com/bradd">http://www.szonye.com/bradd</a>

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00067" href="msg00067.html">Re: SRFI-10 syntax vs. #nA syntax</a></strong>
<ul><li><em>From:</em> Bradd W. Szonye</li></ul></li>
<li><strong><a name="00076" href="msg00076.html">Re: SRFI-10 syntax vs. #nA syntax</a></strong>
<ul><li><em>From:</em> Taylor Campbell</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00085.html">Re: #\a octothorpe syntax vs SRFI 10</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00087.html">Floating-point formats and standards</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00076.html">Re: SRFI-10 syntax vs. #nA syntax</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00078.html">Re: SRFI-10 syntax vs. #nA syntax</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00086"><strong>Date</strong></a></li>
<li><a href="threads.html#00086"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
