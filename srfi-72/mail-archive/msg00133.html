<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: Update to SRFI 72 (Sorry I'm lost) -->
<!--X-From-R13: Oaqer ina Fbaqre <naqerNabj.urg.oebja.rqh> -->
<!--X-Date: Wed, 31 Aug 2005 17:22:26 +0200 (MST) -->
<!--X-Message-Id: Pine.GSO.4.60.0508311017060.1516@now.het.brown.edu -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: Pine.GSO.4.60.0508291448520.27669@now.het.brown.edu -->
<!--X-Reference: 200508310400.j7V40fvg003686@fcs12.free&#45;comp&#45;shop.com -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: Update to SRFI 72 (Sorry I'm lost)</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00132.html">Date Prev</a>][<a href="msg00134.html">Date Next</a>][<a href="msg00132.html">Thread Prev</a>][<a href="msg00134.html">Thread Next</a>][<a href="maillist.html#00133">Date Index</a>][<a href="threads.html#00133">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: Update to SRFI 72 (Sorry I'm lost)</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: Keith Wright &lt;<a href="mailto:kwright@DOMAIN.HIDDEN">kwright@xxxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Subject</em>: Re: Update to SRFI 72 (Sorry I'm lost)</li>
<li><em>From</em>: Andre van Tonder &lt;<a href="mailto:andre@DOMAIN.HIDDEN">andre@xxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Wed, 31 Aug 2005 11:22:11 -0400 (EDT)</li>
<li><em>Cc</em>: <a href="mailto:srfi-72@DOMAIN.HIDDEN">srfi-72@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-72@DOMAIN.HIDDEN">srfi-72@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:200508310400.j7V40fvg003686@DOMAIN.HIDDEN">200508310400.j7V40fvg003686@xxxxxxxxxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>References</em>: &lt;<a href="mailto:Pine.GSO.4.60.0508291448520.27669@DOMAIN.HIDDEN">Pine.GSO.4.60.0508291448520.27669@xxxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:200508310400.j7V40fvg003686@DOMAIN.HIDDEN">200508310400.j7V40fvg003686@xxxxxxxxxxxxxxxxxxxxxxxx</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre style="margin: 0em;">
On Wed, 31 Aug 2005, Keith Wright wrote:

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
Although the above quotation occurs three times almost verbatim,
in the abstract, the introduction, and the specification, it does
not get any clearer with repetition.  As Brian Smith used the term
&quot;reflective tower&quot; it referred to an interpreter for a language
that could express modifications to its own interpreter.  I don't
think that's what you are after, is it?
</pre></blockquote><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
The second mention of the &quot;infinite reflective tower&quot; is followed
by a reference [11] to Richard Kelsey and Jonathan Rees
- The Scheme 48 implementation  <a  rel="nofollow" href="http://s48.org/">http://s48.org/</a>
but a couple hours searching the Scheme 48 manual at that
web site turned up no mention of reflective towers, and not much
about macro expansion.
</pre></blockquote><pre style="margin: 0em;">

</pre><tt>I'll try to rewrite this more clearly.  I mean a reflective tower in the Scheme 
</tt><tt>48 sense, also called a syntactic tower by the authors, who indeed criticise 
</tt><tt>the word &quot;reflective&quot; as a misnomer, though it seems to be widespread in the 
</tt><tt>Scheme folklore.  The Scheme 48 manual is notoriously cryptic, to the point of 
</tt><tt>unusability, but there is a mention on the page:
</tt><pre style="margin: 0em;">

  <a  rel="nofollow" href="http://s48.org/1.2/manual/s48manual_33.html">http://s48.org/1.2/manual/s48manual_33.html</a>

</pre><tt>If someone else has a better reference to the Scheme 48 tower, I'd be grateful 
</tt><tt>for it.
</tt><pre style="margin: 0em;">


</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
Perhaps a better reference would be
&lt;a href=&quot;<a  rel="nofollow" href="http://www2.parc.com/csl/groups/sda/projects/reflection96/abstracts/queinnec.html&quot">http://www2.parc.com/csl/groups/sda/projects/reflection96/abstracts/queinnec.html&quot</a>;&gt;
Queinnec - Macroexpansion Reflective Tower&lt;/a&gt;
</pre></blockquote><pre style="margin: 0em;">

I'll add the reference.

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
A couple of examples of odd scope rules just isn't enough for me
to figure out the plan.  This seems to be a very big change from
the previous proposal, and not like anything that I understand well.

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
* Added BEGIN-FOR-SYNTAX.
</pre></blockquote></blockquote><pre style="margin: 0em;">


Maybe this will help:  In the example

  (define x 1)

  (begin-for-syntax (define x 2))

  (let-syntax ((m (lambda (form)
                    (quasisyntax (list x ,x)))))
    (m))  ==&gt; (1 2)

</pre><tt>one would get different answers depending on whether you evaluate the 
</tt><tt>sequence of expressions one by one in the REPL, or compile the whole thing and 
</tt><tt>then run it, *unless* the runtime x and the expand-time x live in separate 
</tt><tt>namespaces or, equivalently, runtime and expand-time variables have separate 
</tt><tt>lexical scopes.
</tt><pre style="margin: 0em;">

</pre><tt>It is still lexical scoping.  Any programmer worth her salt will know that the 
</tt><tt>first x in (list x ,x) denotes a runtime variable and the second x an 
</tt><tt>expand-time variable, and be able to look up the appropriate lexically preceding 
</tt><tt>binding for each.
</tt><pre style="margin: 0em;">

I consider this &quot;invariance under compilation&quot; property the right thing to do.


</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
The phrase:
</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
... the hygiene algorithm of this SRFI implements a refinement of
lexical scoping that takes into account the level of use of an
identifier in determining its meaning.
</pre></blockquote><pre style="margin: 0em;">

might be better worded as: the algorithm of this SRFI totally ignores
lexical scoping by making the meaning of an identifier depend upon
an invisible property called its &quot;level&quot; rather than its position
in the source code. ...but I have already stated my objections
when you first brought up this idea.
</pre></blockquote><pre style="margin: 0em;">


</pre><tt>I think it is clear that one has different environment bindings at expansion 
</tt><tt>time and at runtime.  In fact, there is no reason that the expansion-time 
</tt><tt>bindings have to implement standard Scheme.  For example, the compile-time CAR 
</tt><tt>can be different from the runtim CAR.  So the compile-time language can be 
</tt><tt>different from the runtim language.
</tt><pre style="margin: 0em;">

</pre><tt>For argument's sake, let's call the runtime-language Scheme and the 
</tt><tt>compile-time language Pascal.  Now Pascal binding forms and Scheme 
</tt><tt>binding forms a priori have nothing to do with each other, so I would be very 
</tt><tt>surprised if the inner Pascal LET were to affect the x in (syntax x) at all in 
</tt><tt>the following.
</tt><pre style="margin: 0em;">

  (let ((x 1))
    (let-syntax ((m (lambda (form)
                      (let ((x 2))
                        (syntax x)))))
      (m)))  ==&gt; 1

</pre><tt>Indeed, the x in (syntax x) represents a Scheme variable, not a Pascal variable. 
</tt><tt>It should therefore be bound by the enclosing outer Scheme LET.   In other 
</tt><tt>words, Scheme code and Pascal code should have separate lexical scopes.
</tt><pre style="margin: 0em;">


</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
* Added SYNTACTIC-WIND.
</pre></blockquote><pre style="margin: 0em;">

Oy.
</pre></blockquote><pre style="margin: 0em;">


</pre><tt>This allows one to do a computation before and after expanding a block of code. 
</tt><tt>It is useful for maintaining environments at expansion time when implementing 
</tt><tt>things like syntax-case and pattern matchers.  For example, in the syntax-case 
</tt><tt>macros I used it for maintaining the environment of pattern variables.
</tt><pre style="margin: 0em;">

</pre><tt>I included it because without it I do not know how to write syntax-case as a 
</tt><tt>library macro.  I do not wish to specify syntax-case as a primitive.
</tt><pre style="margin: 0em;">


</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
* Removed EXPAND.
</pre></blockquote><pre style="margin: 0em;">

Why?
</pre></blockquote><pre style="margin: 0em;">


</pre><tt>Because just like EVAL, EXPAND really does not make sense without a second 
</tt><tt>argument specifying the environment.  I did not wish to overcomplicate the SRFI 
</tt><tt>with a complicated explanation (and implementation) of a primitive that is used 
</tt><tt>mainly for debugging.
</tt><pre style="margin: 0em;">


</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
...and if it is gone, why is this code in the section
on the reflective tower?

    (for-each (lambda (form) (eval (expand form))) sequence)
      == (for-each eval (map-in-order expand sequence))
</pre></blockquote><pre style="margin: 0em;">


</pre><tt>The &quot;schematically&quot; was meant to indicate that it is just a pseudocode 
</tt><tt>expression of the previous verbal phrase.
</tt><pre style="margin: 0em;">


</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
In other words, would the old srfi be compatible
with the reflective tower, except that it would give errors
(identifer used outside its scope of definition) in some cases
where the tower would find and use a binding occurrence that
would appear to be shadowed?
</pre></blockquote><pre style="margin: 0em;">


</pre><tt>My view is that it is just wrong for a binding form in one phase to affect 
</tt><tt>variables in another phase at all.  I consider the out-of-scope errors in 
</tt><tt>comparable macro systems a bug.
</tt><pre style="margin: 0em;">

Cheers
Andre

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00130" href="msg00130.html">Update to SRFI 72</a></strong>
<ul><li><em>From:</em> Andre van Tonder</li></ul></li>
<li><strong><a name="00131" href="msg00131.html">Re: Update to SRFI 72 (Sorry I'm lost)</a></strong>
<ul><li><em>From:</em> Keith Wright</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00132.html">Re: Update to SRFI 72 (Sorry I'm lost)</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00134.html">DrScheme version with source location tracking</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00132.html">Re: Update to SRFI 72 (Sorry I'm lost)</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00134.html">DrScheme version with source location tracking</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00133"><strong>Date</strong></a></li>
<li><a href="threads.html#00133"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
