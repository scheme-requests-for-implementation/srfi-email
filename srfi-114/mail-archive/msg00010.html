<!-- MHonArc v2.6.16 -->
<!--X-Subject: Re: [Scheme&#45;reports] R7RS&#45;large comparators -->
<!--X-From-R13: Oyrkrl Dnqhy <nkbspuNtznvy.pbz> -->
<!--X-Date: Sat, 13 Jul 2013 04:55:56 +0200 (MST) -->
<!--X-Message-Id: CAPKQtS9LR4+8NWckzH1gk3cHbsZRFhzhKMVsrC+ENsKt96KEoA@mail.gmail.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: CAAMbixKpsjMJ0SuDHaO19QsDR0Xor91xNQbeRfd6rKxXnbACAw@mail.gmail.com -->
<!--X-Reference: 20130712145855.GB29600@mercury.ccil.org -->
<!--X-Reference: CAF+kUQXVa2MRCAVi8ytPTQrhx=0_PysorXR+_jjLX4r2TejbqA@mail.gmail.com -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: [Scheme-reports] R7RS-large comparators</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00009.html">Date Prev</a>][<a href="msg00011.html">Date Next</a>][<a href="msg00009.html">Thread Prev</a>][<a href="msg00008.html">Thread Next</a>][<a href="maillist.html#00010">Date Index</a>][<a href="threads.html#00010">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: [Scheme-reports] R7RS-large comparators</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-114">SRFI 114</a> from before July 7th, 2015.  The <a href="http://srfi-email.schemers.org/srfi-114">new archives</a> for SRFI 114 contain all messages, not just those from before July 7th, 2015.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: Alan Manuel Gloria &lt;<a href="mailto:almkglor@DOMAIN.HIDDEN">almkglor@xxxxxxxxx</a>&gt;</li>
<li><em>Subject</em>: Re: [Scheme-reports] R7RS-large comparators</li>
<li><em>From</em>: Alexey Radul &lt;<a href="mailto:axofch@DOMAIN.HIDDEN">axofch@xxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Fri, 12 Jul 2013 22:48:37 -0400</li>
<li><em>Cc</em>: John Cowan &lt;<a href="mailto:cowan@DOMAIN.HIDDEN">cowan@xxxxxxxxxxxxxxxx</a>&gt;, Andrew Robbins &lt;<a href="mailto:andjrob@DOMAIN.HIDDEN">andjrob@xxxxxxxxx</a>&gt;, 	<a href="mailto:srfi-114@DOMAIN.HIDDEN">srfi-114@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-114@DOMAIN.HIDDEN">srfi-114@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Dkim-signature</em>: v=1; a=rsa-sha256; c=relaxed/relaxed;        d=gmail.com; s=20120113;        h=mime-version:in-reply-to:references:date:message-id:subject:from:to         :cc:content-type;        bh=gVzTgleT3YQU6ZTgHuvs6vXETuKFS2LwoifvYEYMmhA=;        b=VlxHcPFn1b/fuXlwB3EUyZDA2gY+wtPWZM+qM9QM/yASydMx4KqO6aUKghIiBer59G         HmI2bQL1hdsXpTqVql+JKFRh3Ov7gREOFaRAXv7cIhcMtOZuJHb5Yw/Qh1Q2i/TmH+9q         2z0QVNrc1rNOyiv779gw4KOkjzxPsLxHopQABBUvkdfVl7u3o4noE5qOPzyUy6TeSWuc         sB3DdN3b5itD0vHQOLehfEv/z4vq3Yjb5O7zgfljeup0rkc/Nnon1Sg0wlW0GBFXRklJ         0Eb/+CQWVxGSZlQtG8oeQT2LGsjFw/zw5Pe0Fxs1xRynedJ4rGZgGjGXeFPvpxSR0UB6         odWQ==</li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:CAF%2BkUQXVa2MRCAVi8ytPTQrhx%3D0_PysorXR%2B_jjLX4r2TejbqA@DOMAIN.HIDDEN">CAF+kUQXVa2MRCAVi8ytPTQrhx=0_PysorXR+_jjLX4r2TejbqA@xxxxxxxxxxxxxx</a>&gt;</li>
<li><em>References</em>: &lt;<a href="mailto:CAAMbixKpsjMJ0SuDHaO19QsDR0Xor91xNQbeRfd6rKxXnbACAw@DOMAIN.HIDDEN">CAAMbixKpsjMJ0SuDHaO19QsDR0Xor91xNQbeRfd6rKxXnbACAw@xxxxxxxxxxxxxx</a>&gt;	&lt;<a href="mailto:20130712145855.GB29600@DOMAIN.HIDDEN">20130712145855.GB29600@xxxxxxxxxxxxxxxx</a>&gt;	&lt;<a href="mailto:CAF%2BkUQXVa2MRCAVi8ytPTQrhx%3D0_PysorXR%2B_jjLX4r2TejbqA@DOMAIN.HIDDEN">CAF+kUQXVa2MRCAVi8ytPTQrhx=0_PysorXR+_jjLX4r2TejbqA@xxxxxxxxxxxxxx</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>The world has many useful partial orders.  However, clarity is greatly
aided by the programmer being able to express their expectation that a
particular set of interest in fact forms a total order.  I therefore
think it is not unreasonable for a programming language to have two
different operations that are like &quot;less than&quot; -- one for total order
comparison, which signals a condition or otherwise does something
extraordinary if given two incomparable objects, and another for
partial order comparison, which always returns normally but is free to
return one of four objects (which themselves form a natural partial
order) to indicate &quot;equal&quot;, &quot;less&quot;, &quot;greater&quot;, or &quot;incomparable&quot;.

Under this view, I suggest that SRFI 114 concern itself with total
orders only; perhaps it would be appropriate to propose another SRFI
for partial orders.  Doing so should be very interesting: Among other
subtleties, in general partial orders meet and join are not max and
min; and in particular, may not always exist, or may exist but not be
unique, or may exist and be unique but be considerably more expensive
to compute than comparison.  So it becomes reasonable to make a
distinction between partial orders and lattices (and also
semi-lattices, which have one of meet or join but not the other);
whereas every total order is a lattice.

~Alexey

P.S.  Unfortunately, the mathematical tradition uses the same symbol
for both total and partial comparison, and Scheme has not yet
standardized a generic dispatch facility that could be used to
disambiguate by the types of the arguments.  So the putative partial
order comparisons SRFI would have to choose whether to use an ugly
notation right off, or walk right into naming collisions and rely on
(programmers and) the module system to fix them.


On Fri, Jul 12, 2013 at 7:52 PM, Alan Manuel Gloria &lt;almkglor@xxxxxxxxx&gt; wrote:
&gt;
&gt;
&gt;&gt; &gt; General Issues:
&gt;&gt; &gt; It is my personal opinion that this module should be helpful to anyone
&gt;&gt; &gt; involved in either total orders or partial orders, such as
&gt;&gt; &gt; floating-point
&gt;&gt; &gt; numbers (which form a total order if you ignore NaNs and -0.0). One way
&gt;&gt; &gt; of
&gt;&gt; &gt; doing this would be to use an exception/condition to express a lack of
&gt;&gt; &gt; total order, another would be to return something other than -1, 0, 1
&gt;&gt; &gt; from
&gt;&gt; &gt; the compare procedure (perhaps return +nan.0), which would violate the
&gt;&gt; &gt; conditions for a compare procedure according to this module as specified
&gt;&gt; &gt; so
&gt;&gt; &gt; far. I'm not sure what the best way to do this is, except to provide
&gt;&gt; &gt; additional procedures for floating-point numbers, and not handle partial
&gt;&gt; &gt; orders in a general way. My intuition tells me that a general approach
&gt;&gt; &gt; would be more valuable in the long term, than to special case floats.
&gt;&gt; &gt; Treating any and all partial orders that come along as special cases,
&gt;&gt; &gt; just
&gt;&gt; &gt; seems wrong to me.
&gt;&gt;
&gt;&gt; SRFI 114 does provide a special case for floats.  What would be other
&gt;&gt; use cases for partial orders in general?
&gt;
&gt;
&gt; Subtyping relations are a partial ordering.
&gt;
&gt; Consider:
&gt;
&gt; Numbers &gt;= Complex &gt;= Reals &gt;= Rationals &gt;= Integers &gt;= Naturals
&gt;
&gt; However, consider also:
&gt;
&gt; Numbers &gt;= Complex &gt;= Imaginaries
&gt;
&gt; The Imaginaries type is &quot;incomparable&quot; to the Reals, Rationals, Integers, or
&gt; Naturals type, because it follows a different branch of subtyping.  This
&gt; forms a partial ordering.
&gt;
&gt; It would be nice to be able to &quot;compare&quot; two type objects and learn if one
&gt; is a sub-type of the other, is the same type, or are incomparable.
&gt;
&gt; Sets may also be compared (basically, if you consider that subtype ==
&gt; subset, so that &quot;the set of Numbers is a superset of Reals&quot;), and the result
&gt; may also be &quot;incomparable&quot;, i.e. one is not a strict subset of or equal to
&gt; the other.
&gt;
&gt; For floats, perhaps NaN should return &quot;incomparable&quot; if one side is a NaN
&gt; and the other is not, or &quot;equal&quot; if both are NaN (this would simplify some
&gt; uses of hash tables).  As for -0.0, perhaps we can consider it as actually
&gt; being -(epsilon/2), so that it is less than 0.0 but greater than -epsilon,
&gt; where epsilon is the tiniest representable non-zero float.
&gt;
&gt; Personally, I'd like the &quot;incomparable&quot; case to return &quot;a unique,
&gt; non-numeric object of unspecified type, which may be compared by eq? to the
&gt; exported binding INCOMPARABLE, e.g. (eq? (compare a b) INCOMPARABLE).&quot; but
&gt; that's just me.

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00007" href="msg00007.html">Re: [Scheme-reports] R7RS-large comparators</a></strong>
<ul><li><em>From:</em> John Cowan</li></ul></li>
<li><strong><a name="00009" href="msg00009.html">Re: [Scheme-reports] R7RS-large comparators</a></strong>
<ul><li><em>From:</em> Alan Manuel Gloria</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00009.html">Re: [Scheme-reports] R7RS-large comparators</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00011.html">Subscribe</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00009.html">Re: [Scheme-reports] R7RS-large comparators</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00008.html">Subscribe</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00010"><strong>Date</strong></a></li>
<li><a href="threads.html#00010"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
