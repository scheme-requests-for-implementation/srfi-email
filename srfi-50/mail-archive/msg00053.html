<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: Couple things... -->
<!--X-From-R13: sryvk <sryvkNpnyy&#45;jvgu&#45;pheerag&#45;pbagvahngvba.bet> -->
<!--X-Date: Wed, 24 Dec 2003 13:40:12 +0100 (NFT) -->
<!--X-Message-Id: opr0oqxxx7w2xcd0@mx.freenet.de -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: opr0lf0hi7w2xcd0@mx.freenet.de -->
<!--X-Reference: y9lvfo7lwhn.fsf@informatik.uni&#45;tuebingen.de -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: Couple things...</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00052.html">Date Prev</a>][<a href="msg00054.html">Date Next</a>][<a href="msg00116.html">Thread Prev</a>][<a href="msg00070.html">Thread Next</a>][<a href="maillist.html#00053">Date Index</a>][<a href="threads.html#00053">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: Couple things...</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-50">SRFI 50</a> from before July 7th, 2015.  The new archives for SRFI 50 are <a href="http://srfi-email.schemers.org/srfi-50/">here</a>.  Eventually, the entire history will be moved there, including any new messages.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: Michael Sperber &lt;<a href="mailto:sperber@DOMAIN.HIDDEN">sperber@xxxxxxxxxxxxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Subject</em>: Re: Couple things...</li>
<li><em>From</em>: felix &lt;<a href="mailto:felix@DOMAIN.HIDDEN">felix@xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Wed, 24 Dec 2003 13:42:59 +0100</li>
<li><em>Cc</em>: <a href="mailto:srfi-50@DOMAIN.HIDDEN">srfi-50@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-50@DOMAIN.HIDDEN">srfi-50@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:y9lvfo7lwhn.fsf@DOMAIN.HIDDEN">y9lvfo7lwhn.fsf@xxxxxxxxxxxxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>References</em>: &lt;<a href="mailto:opr0lf0hi7w2xcd0@DOMAIN.HIDDEN">opr0lf0hi7w2xcd0@xxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:y9lvfo7lwhn.fsf@DOMAIN.HIDDEN">y9lvfo7lwhn.fsf@xxxxxxxxxxxxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>User-agent</em>: Opera7.11/Linux M2 build 406</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<tt>On Tue, 23 Dec 2003 10:22:12 +0100, Michael Sperber 
</tt><tt>&lt;sperber@xxxxxxxxxxxxxxxxxxxxxxxxxxx&gt; wrote:
</tt><pre style="margin: 0em;">

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
&quot;felix&quot; == felix  &lt;felix@xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&gt; writes:
</pre></blockquote></blockquote></blockquote></blockquote></blockquote><pre style="margin: 0em;">

</pre><tt>felix&gt; It's absolutely unnecessary to specify which C-level forms are 
</tt><tt>macros,
</tt><tt>felix&gt; or which are functions. Leave that to the implementors, and allow 
</tt><tt>all
</tt><pre style="margin: 0em;">
felix&gt; the forms to be macros instead.

That certainly was our intention.  Do we overspecify anything by
saying &quot;Note that most functionality on the C side is implemented by
macros.&quot;?
</pre></blockquote><pre style="margin: 0em;">

Well, it's _all_ functionality, so I don't see a reason for being
vague.

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
felix&gt; Defining bindings from C is allowed, and the SRFI-document
felix&gt; specifically points out the C init-code may run before Scheme
felix&gt; init-code. Yet, SCHEME_DEFINE_EXPORTED_BINDING may GC, even
felix&gt; before Scheme init-code has run?  Weird.

Sure.  Could you specify where this is causing problems for you?
</pre></blockquote><pre style="margin: 0em;">

I'm probably misunderstanding this, but do you mean that &quot;Scheme init-code&quot;
does include setting up the garbage collector? If it does, then no GC
can run, unless it has been initialized, right? Specifically, is
the Scheme runtime-system already set up, before the bindings are defined
from C? Or does the binding-registration from C init the Scheme world
for me?

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">

felix&gt; I find it a bit tricky to exactly specify what may GC and what
felix&gt; not.

Yeah, me too. :-)
</pre></blockquote><pre style="margin: 0em;">

Exactly, in fact it's getting so tricky, that it's likely that not
all cases can be covered.

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">

felix&gt; For example: mutations (a la &quot;SCHEME_RECORD_SET&quot;) may very well
</pre><tt>felix&gt; allocate storage (if the write-barrier involves allocating 
</tt><tt>something
</tt><tt>felix&gt; on the heap, that describes the mutated slot). The life-time of 
</tt><tt>data
</tt><tt>felix&gt; on the heap may be extremely short - what happens if GC or 
</tt><tt>finalizers
</tt><tt>felix&gt; run in a different OS-level thread?  The authors would do good by 
</tt><tt>not
</tt><pre style="margin: 0em;">
felix&gt; assuming every Scheme implementation does it like S48 or PLT.

It certainly wasn't our intention---we looked at a lot more Scheme
implementations than just those two.  However, even writing up the
current draft was difficult enough.  I'm happy to hear suggestions on
how to improve it.
</pre></blockquote><pre style="margin: 0em;">

And I'm not trying to be rude here, I want add. I appreciate already that
someone has the courage to think about a (somewhat) portable FFI,
even considering that I think the current draft isn't any good. ;-)

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">

felix&gt; Alternative approaches would be:

felix&gt; 1) Selectively switch GC on/off in sections of C code (just like
felix&gt;    critical sections, really).

Is this really practical in all conceivable environments?
</pre></blockquote><pre style="margin: 0em;">

It's safer at least. But not completely satisfying, I admit.

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">

felx&gt; 2) Allocate *once* a complete chunk that will be
felix&gt;   able to hold all
felix&gt;   data needed subsequently without triggering a GC.

That certainly seems impractical to me if you need to limit space usage.
</pre></blockquote><pre style="margin: 0em;">

Yes, it's not overly convenient, especially if one takes into account
that different objects may be allocated in different memory
arenas. But the problem is that we have to constrain GC, if all
possible scenarious have to be taken care of.

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
felix&gt; SCHEME_CALL: &quot;For example, suppose Scheme procedure s0 captures
felix&gt; continuation a and then calls C procedure c0, which in turn calls
</pre><tt>felix&gt; Scheme procedure s1. Procedure s1 can safely call the continuation 
</tt><tt>a,
</tt><tt>felix&gt; because that is a downward use. When a is called Scheme will 
</tt><tt>remove
</tt><pre style="margin: 0em;">
felix&gt; the portion of the C stack used by the call to c0.&quot;

</pre><tt>felix&gt; How do you know that? Why do you specify this? Does this mean a is 
</tt><tt>a
</tt><pre style="margin: 0em;">
felix&gt; special kind of continuation, one that uses longjmp()? What if
felix&gt; continuations are explicit (in a CPS manner)?

Those aren't continuations in the sense of the SRFI.  (How you you
tell from looking at one?)
</pre></blockquote><pre style="margin: 0em;">

Hm. I have to think more about this... I just feel uncomfortable
with the fact that `a' has to perform some explicit action that might
interact badly with the underlying execution model.

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
It *is* the stated intention of this SRFI to be
Scheme-implementation-agnostic.  However, of course our take on the
matter is limited by what we know.  So I suggest that, whenever you
say that we're being overly Scheme-48-specific, you make a concrete
suggestion on how to be more general.  We've put significant thought
into most of the issues you mention, so any lack of generality above
that probably reflects more a limit of our abilities than a limit of
our willingness to improve things.

felix&gt; Why have countless macros that access and create Scheme data? Some
</pre><tt>felix&gt; basic forms for defining code callable from Scheme (and vice 
</tt><tt>versa)
</tt><tt>felix&gt; would be more than enough, together with a simple system of 
</tt><tt>specifying
</tt><tt>felix&gt; Scheme-&gt;C-&gt;Scheme type mappings. This would also remove the GC- 
</tt><tt>related
</tt><pre style="margin: 0em;">
felix&gt; problems (mostly).

I'll be glad to see a concrete writeup of this idea. :-)

</pre></blockquote><pre style="margin: 0em;">

My idea is simpler, more safe, more portable and does away with most GC
and character-representation issues (as far as I'm able to understand
</pre><tt>Unicode-related problems): define blocks of code externally, with a 
</tt><tt>properly defined set of arguments/results and their types. The foreign
</tt><pre style="margin: 0em;">
bindings could be defined in a &quot;binding&quot;-language, perhaps even by taking
ideas from SRFI-7:

;;; foo-n-bar.spec

(define-foreign (foo (x int) (y (string ascii)))
 (callback)
 (values (r1 float32) (r2 (vector int32)))
 (language c)
 (file &quot;foo.c&quot;) )

(define-foreign (bar) (values (x (char latin-1)))
 (language c++)
 (code &quot;x = yomama.foobar();&quot;) )

This (perhaps processed with an external tool that creates the proper
</pre><tt>makefiles) would generate something that can be linked statically or 
</tt><tt>dynamically with a Scheme system:
</tt><pre style="margin: 0em;">

(define b (load-foreign-bindings &quot;foo-n-bar&quot;))

(define foo (foreign-binding-ref b &quot;foo&quot;))
(define bar (foreign-binding-ref b &quot;bar&quot;))

Or with some syntactic sugar:

(define-foreign-bindings &quot;foo-n-bar&quot;
 (foo &quot;foo&quot;)
 (my-bar &quot;bar&quot;) )

(define-values (x y) (foo 99 #\X))
(write (my-bar #\space))

Inside the foreign code, no GC may occur, unless the `callback' clause
</pre><tt>is given (how exactly the callback takes place, is another issue). 
</tt><tt>Arguments and return-values can be transformed to one (of several)
</tt><tt>representation that the foreign language can handle. Several target- 
</tt><tt>languages
</tt><tt>could be supported (Java, C, C++, Objective-C). Multiple return values 
</tt><tt>would be handled, with named output parameters. I admit that the 
</tt><tt>representation-transformation may incur performance costs, but we get 
</tt><tt>something much safer and easier to use for paying this price. We can reduce 
</tt><tt>the number
</tt><tt>of needed accessors, if the arguments are available as natively known 
</tt><tt>types.
</tt><tt>For handling Scheme data directly (which is in my experience not very often 
</tt><tt>the case), we can pass the arguments as C-unions (or something that the
</tt><pre style="margin: 0em;">
target language understands easily).
</pre><tt>Arguments may or may not be mutable (this could be specified with 
</tt><tt>additional type-qualifiers). Arguments may or may not share data with 
</tt><tt>Scheme values, this could either be optionally specified or the 
</tt><tt>implementation may chose to pass the data unconverted, if it matches the 
</tt><tt>argument type for the foreign code.
</tt><tt>There is a lot of room for blowing up the binding language and its 
</tt><tt>supported
</tt><pre style="margin: 0em;">
types, but at first it could just support basic things, with future
SRFIs extending the language to support more facilities.


cheers,
felix

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00070" href="msg00070.html">Re: Couple things...</a></strong>
<ul><li><em>From:</em> Michael Sperber</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00004" href="msg00004.html">Couple things...</a></strong>
<ul><li><em>From:</em> felix</li></ul></li>
<li><strong><a name="00025" href="msg00025.html">Re: Couple things...</a></strong>
<ul><li><em>From:</em> Michael Sperber</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00052.html">Re: Couple things...</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00054.html">Re: Couple things...</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00116.html">Re: Couple things...</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00070.html">Re: Couple things...</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00053"><strong>Date</strong></a></li>
<li><a href="threads.html#00053"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
