<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: Comparing Pika&#45;syle and JNI&#45;style -->
<!--X-From-R13: Fbz Zbeq <ybeqNrzs.arg> -->
<!--X-Date: Thu, 15 Jan 2004 02:31:40 +0100 (NFT) -->
<!--X-Message-Id: 200401150159.RAA09223@morrowfield.regexps.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: E1AfQRd&#45;0000Qa&#45;00@mail.mumble.net -->
<!--X-Reference: vt2y8scua4h.fsf@zenia.home -->
<!--X-Reference: 877jzwtzaz.fsf@becket.becket.net -->
<!--X-Reference: vt2ptdn2bqq.fsf@zenia.home -->
<!--X-Reference: vt2isje3nna.fsf_&#45;_@zenia.home -->
<!--X-Reference: 200401141840.KAA07050@morrowfield.regexps.com -->
<!--X-Reference: vt265fecl8l.fsf@zenia.home -->
<!--X-Reference: 200401142141.NAA07967@morrowfield.regexps.com -->
<!--X-Reference: 4005C01C.6000604@bothner.com -->
<!--X-Reference: Pine.LNX.4.58.0401141548080.21059@bolt.sonic.net -->
<!--X-Reference: 4005DF13.8030706@bothner.com -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: Comparing Pika-syle and JNI-style</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00321.html">Date Prev</a>][<a href="msg00323.html">Date Next</a>][<a href="msg00323.html">Thread Prev</a>][<a href="msg00324.html">Thread Next</a>][<a href="maillist.html#00322">Date Index</a>][<a href="threads.html#00322">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: Comparing Pika-syle and JNI-style</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-50">SRFI 50</a> from before July 7th, 2015.  The <a href="http://srfi-email.schemers.org/srfi-50">new archives</a> for SRFI 50 contain all messages, not just those from before July 7th, 2015.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: <a href="mailto:per@DOMAIN.HIDDEN">per@xxxxxxxxxxx</a></li>
<li><em>Subject</em>: Re: Comparing Pika-syle and JNI-style</li>
<li><em>From</em>: Tom Lord &lt;<a href="mailto:lord@DOMAIN.HIDDEN">lord@xxxxxxx</a>&gt;</li>
<li><em>Date</em>: Wed, 14 Jan 2004 17:59:10 -0800 (PST)</li>
<li><em>Cc</em>: <a href="mailto:bear@DOMAIN.HIDDEN">bear@xxxxxxxxx</a>, <a href="mailto:srfi-50@DOMAIN.HIDDEN">srfi-50@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-50@DOMAIN.HIDDEN">srfi-50@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:4005DF13.8030706@DOMAIN.HIDDEN">4005DF13.8030706@xxxxxxxxxxx</a>&gt; (message from Per Bothner on Wed,        14 Jan 2004 16:30:11 -0800)</li>
<li><em>References</em>: &lt;<a href="mailto:E1AfQRd-0000Qa-00@DOMAIN.HIDDEN">E1AfQRd-0000Qa-00@xxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:vt2y8scua4h.fsf@DOMAIN.HIDDEN">vt2y8scua4h.fsf@xxxxxxxxxx</a>&gt; &lt;<a href="mailto:877jzwtzaz.fsf@DOMAIN.HIDDEN">877jzwtzaz.fsf@xxxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:vt2ptdn2bqq.fsf@DOMAIN.HIDDEN">vt2ptdn2bqq.fsf@xxxxxxxxxx</a>&gt; &lt;<a href="mailto:vt2isje3nna.fsf_-_@DOMAIN.HIDDEN">vt2isje3nna.fsf_-_@xxxxxxxxxx</a>&gt; &lt;<a href="mailto:200401141840.KAA07050@DOMAIN.HIDDEN">200401141840.KAA07050@xxxxxxxxxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:vt265fecl8l.fsf@DOMAIN.HIDDEN">vt265fecl8l.fsf@xxxxxxxxxx</a>&gt; &lt;<a href="mailto:200401142141.NAA07967@DOMAIN.HIDDEN">200401142141.NAA07967@xxxxxxxxxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:4005C01C.6000604@DOMAIN.HIDDEN">4005C01C.6000604@xxxxxxxxxxx</a>&gt; &lt;<a href="mailto:Pine.LNX.4.58.0401141548080.21059@DOMAIN.HIDDEN">Pine.LNX.4.58.0401141548080.21059@xxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:4005DF13.8030706@DOMAIN.HIDDEN">4005DF13.8030706@xxxxxxxxxxx</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>

    &gt; From: Per Bothner &lt;per@xxxxxxxxxxx&gt;

    &gt; The problem Tom is referring to is (I assume) misidentifying a pointer
    &gt; as a non-pointer.  That can happen if:
    &gt; (a) You didn't tell the collector to scan the area containing the
    &gt; pointer (most common problem).
    &gt; (b) the pointer is &quot;mangled&quot;, either through &quot;clever&quot; coding (such as
    &gt; the xor-trick for double-linked lists) or an optimizing compiler
    &gt; being to clever.  The former is a 'don't do that&quot;.  The latter is
    &gt; very rare, but can conceivably happen if the compiler generates an
    &gt; offsetted pointer while without leaving any reference to the actual
    &gt; object start.  Boehm GC can be configured to also check &quot;interior
    &gt; pointers&quot;; this reduces the problem, this hurts performance.

    &gt; See <a  rel="nofollow" href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/issues.html">http://www.hpl.hp.com/personal/Hans_Boehm/gc/issues.html</a>
    &gt; especially the &quot;Safety&quot; section.

It was not quite either of those.

In this case, the optimizer wasn't even being very clever -- it was
just reusing a register.

Picture a Scheme string representation like this:

    scheme_value
        |
        V
        ---------------------------------------------
        | length, tag bits, gc gbits |  (char *) o  |
        -----------------------------------------|---
                                                 |
                                                 V
                                          malloced string


(That the string is separately allocated makes little difference here.
Were it inline with the GC-controlled object the same kind of bug
would be just as likely to occur.   You could just as well picture:


    scheme_value
        |
        V
        --------------------------------------------------------
        | length, tag bits, gc gbits |  the string itself .... |
        --------------------------------------------------------



Given the scheme_value, I read the address of the malloced (or inline)
string and operate on that.  At this point the scheme_value, if I'm
not otherwise using it, is a dead variable as far as C is concerned.
Should the scheme value be collected while I'm working on the string,
the string data will be freed out from under me.  I must take
additional steps to keep the scheme_value live.

Picture (buggy) code like:

	{
           SCM scheme_string = some_init ();
           char * data = SCM_STRING_DATA (scheme_string);

           [... do stuff that can cause GC but doesn't directly
                use scheme_string ...];

           return SCM_BOOL_F;
        }

It needs to be corrected at least to something like:

	{
           SCM scheme_string = some_init ();
           char * data = SCM_STRING_DATA (scheme_string);

           [... do stuff that can cause GC but doesn't directly
                use scheme_string ...];


           scm_remember (scheme_string);

           return SCM_BOOL_F;
        }

or even (depending on the details of the object representations and
the situation with async execution or threads):

	{
           SCM scheme_string = some_init ();
           char * data;

           scm_remember_pointer (&amp;scheme_string);

           data = SCM_STRING_DATA (scheme_string);

           [... do stuff that can cause GC but doesn't directly
                use scheme_string ...];


           scm_remember_stuff ();

           return SCM_BOOL_F;
        }

at which point I stop and ask myself &quot;Why is it, again, that I'm not
just using precise GC instead?&quot;


    &gt; Tom Lord wrote:
    &gt; 
    &gt;  &gt; On a hunch, you review some of
    &gt;  &gt; the functions that you think your program is exercising to an unusual
    &gt;  &gt; degree and, sure enough -- find a conservative GC bug.
    &gt; 
    &gt; What kind of &quot;cerservative GC bug&quot;?  Is this with the Boehm GC?  Are
    &gt; these C functions, Scheme functions, or what?  Is it an optimizer bug?
    &gt; -- 

It was not with Boehm but this and similar problems apply to Boehm as
far as I know.  The even worse problem, as far as I'm concerned, is
that conservative collectors (including Boehm) admit subtle malicious
attacks that programmers simply can not protect themselves from (more
in the direction of failing to free values rather than freeing them
early).

I don't think that Boehm himself disagrees with any of my factual
claims -- only with our subjective assessments of how serious those
are and how one should promote conservative GC as a result.  And, to
be sure -- he's got the empirical edge on me if you measure
conseravative GC for its economic value minus its econmic costs ----
so far (and so far as we know).  

My bet is that it's just a matter of (within our lifetime) time before
the balance shifts in my favor due to a malicious exploit (unless
conservative techniques simply fall out of favor).  Since conservative
is ultimately no easier to use than precise: why take that bet; why
accept that risk?  Why not just eliminate the issue by barring
conservative GC from all critical systems?  That conservative is
vulnerable to malicious attack greatly skews any attempt you might
make to estimate the probability of a critical failure: really, it's a
function of the value to the attacker of that failure.

-t

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00324" href="msg00324.html">Re: Comparing Pika-syle and JNI-style</a></strong>
<ul><li><em>From:</em> Shiro Kawai</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00262" href="msg00262.html">Re: when GC is permitted</a></strong>
<ul><li><em>From:</em> Richard Kelsey</li></ul></li>
<li><strong><a name="00283" href="msg00283.html">temporarily withdrawing SRFI-50</a></strong>
<ul><li><em>From:</em> Jim Blandy</li></ul></li>
<li><strong><a name="00287" href="msg00287.html">Re: temporarily withdrawing SRFI-50</a></strong>
<ul><li><em>From:</em> Thomas Bushnell, BSG</li></ul></li>
<li><strong><a name="00294" href="msg00294.html">Re: temporarily withdrawing SRFI-50</a></strong>
<ul><li><em>From:</em> Jim Blandy</li></ul></li>
<li><strong><a name="00295" href="msg00295.html">Comparing Pika-syle and JNI-style</a></strong>
<ul><li><em>From:</em> Jim Blandy</li></ul></li>
<li><strong><a name="00296" href="msg00296.html">Re: Comparing Pika-syle and JNI-style</a></strong>
<ul><li><em>From:</em> Tom Lord</li></ul></li>
<li><strong><a name="00304" href="msg00304.html">Re: Comparing Pika-syle and JNI-style</a></strong>
<ul><li><em>From:</em> Jim Blandy</li></ul></li>
<li><strong><a name="00305" href="msg00305.html">Re: Comparing Pika-syle and JNI-style</a></strong>
<ul><li><em>From:</em> Tom Lord</li></ul></li>
<li><strong><a name="00312" href="msg00312.html">Re: Comparing Pika-syle and JNI-style</a></strong>
<ul><li><em>From:</em> Per Bothner</li></ul></li>
<li><strong><a name="00316" href="msg00316.html">Re: Comparing Pika-syle and JNI-style</a></strong>
<ul><li><em>From:</em> bear</li></ul></li>
<li><strong><a name="00317" href="msg00317.html">Re: Comparing Pika-syle and JNI-style</a></strong>
<ul><li><em>From:</em> Per Bothner</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00321.html">Re: Comparing Pika-syle and JNI-style</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00323.html">Re: Comparing Pika-syle and JNI-style</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00323.html">Re: Comparing Pika-syle and JNI-style</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00324.html">Re: Comparing Pika-syle and JNI-style</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00322"><strong>Date</strong></a></li>
<li><a href="threads.html#00322"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
