<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: Parsing Scheme [was Re: strings draft] -->
<!--X-From-R13: goNorpxrg.arg (Fubznf Phfuaryy, PEU) -->
<!--X-Date: Sat, 24 Jan 2004 20:34:34 +0100 (MET) -->
<!--X-Message-Id: 871xpp2la5.fsf@becket.becket.net -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 200401220511.VAA18432@morrowfield.regexps.com -->
<!--X-Reference: 200401230907.27619.Ken.Dickey@allvantage.com -->
<!--X-Reference: 200401232020.MAA26771@morrowfield.regexps.com -->
<!--X-Reference: 87hdymz7fk.fsf@becket.becket.net -->
<!--X-Reference: 200401232252.OAA27834@morrowfield.regexps.com -->
<!--X-Reference: 87zncdkfka.fsf@becket.becket.net -->
<!--X-Reference: 200401241855.KAA03861@morrowfield.regexps.com -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: Parsing Scheme [was Re: strings draft]</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00396.html">Date Prev</a>][<a href="msg00398.html">Date Next</a>][<a href="msg00395.html">Thread Prev</a>][<a href="msg00399.html">Thread Next</a>][<a href="maillist.html#00397">Date Index</a>][<a href="threads.html#00397">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: Parsing Scheme [was Re: strings draft]</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: Tom Lord &lt;<a href="mailto:lord@DOMAIN.HIDDEN">lord@xxxxxxx</a>&gt;</li>
<li><em>Subject</em>: Re: Parsing Scheme [was Re: strings draft]</li>
<li><em>From</em>: <a href="mailto:tb@DOMAIN.HIDDEN">tb@xxxxxxxxxx</a> (Thomas Bushnell, BSG)</li>
<li><em>Date</em>: 24 Jan 2004 11:34:26 -0800</li>
<li><em>Cc</em>: <a href="mailto:Ken.Dickey@DOMAIN.HIDDEN">Ken.Dickey@xxxxxxxxxxxxxx</a>, <a href="mailto:srfi-50@DOMAIN.HIDDEN">srfi-50@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-50@DOMAIN.HIDDEN">srfi-50@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:200401241855.KAA03861@DOMAIN.HIDDEN">200401241855.KAA03861@xxxxxxxxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>References</em>: &lt;<a href="mailto:200401220511.VAA18432@DOMAIN.HIDDEN">200401220511.VAA18432@xxxxxxxxxxxxxxxxxxxxxxx</a>&gt;	&lt;<a href="mailto:200401230907.27619.Ken.Dickey@DOMAIN.HIDDEN">200401230907.27619.Ken.Dickey@xxxxxxxxxxxxxx</a>&gt;	&lt;<a href="mailto:200401232020.MAA26771@DOMAIN.HIDDEN">200401232020.MAA26771@xxxxxxxxxxxxxxxxxxxxxxx</a>&gt;	&lt;<a href="mailto:87hdymz7fk.fsf@DOMAIN.HIDDEN">87hdymz7fk.fsf@xxxxxxxxxxxxxxxxx</a>&gt;	&lt;<a href="mailto:200401232252.OAA27834@DOMAIN.HIDDEN">200401232252.OAA27834@xxxxxxxxxxxxxxxxxxxxxxx</a>&gt;	&lt;<a href="mailto:87zncdkfka.fsf@DOMAIN.HIDDEN">87zncdkfka.fsf@xxxxxxxxxxxxxxxxx</a>&gt;	&lt;<a href="mailto:200401241855.KAA03861@DOMAIN.HIDDEN">200401241855.KAA03861@xxxxxxxxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>User-agent</em>: Gnus/5.09 (Gnus v5.9.0) Emacs/21.3</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>Tom Lord &lt;lord@xxxxxxx&gt; writes:

&gt; We should also point readers in general to:
&gt; 
&gt;   <a  rel="nofollow" href="http://www.unicode.org/reports/tr15/#Programming_Language_Identifiers">http://www.unicode.org/reports/tr15/#Programming_Language_Identifiers</a>
&gt; 
&gt; which is Annex 7 (&quot;Programming Language Identifiers&quot;) of Unicode
&gt; Technical Report 15 (&quot;Unicode Normalization Forms&quot;).

Yes.  I think the Unicode suggestions for programming language
identifiers are good ones, and we should both point to them and
strongly suggest their use.  I'm not quite prepared to say that we
should standardize Scheme to require it (even on Unicode places)

&gt; * (identifier? s) =&gt; &lt;bool&gt;

This is fine.  An implementation should be allowed to always return #t
from this function, even though not every such string could be parsed
as an identifier by the reader.  (This for the sake of eval, at least.)

&gt;      The definition of FOLD-IDENTIFIER must be consistent with the
&gt;      recommendations of Annex 7 (&quot;Programming Language Identifiers&quot; of
&gt;      Unicode Technical Report 15 for identifier names comprised
&gt;      entirely of Unicode characters.  

Again, I would suggest that we merely advocate this, but not require it.

&gt;      For this purpose, the characters
&gt;      of the portable Scheme character set are considered to be Unicode
&gt;      characters.  (A short summary of the implications of this
&gt;      requirement for portable identifiers is that given a portable
&gt;      identifier, FOLD-IDENTIFIER must map #\A..#\Z to #\a..#\z.)

On the other hand, we should certainly specify exactly the behavior of
the function for the required character set, agreed.

&gt;      (FOLD-IDENTIFIER is preferable to STRING-ID=? because it 
&gt;      produces a canonical form of each identifier explicitly 
&gt;      rather than implicitly.   The canonical form is useful because
&gt;      it can be hashed, stored in a trie, etc.   It would be
&gt;      impractical to implement, for example, a symbol table in a
&gt;      compiler given only STRING-ID=?.)

I think my worry is that it is not obvious that an implementation even
has an implicit folding available, at least, not cheaply.  There
should perhaps be a hash function to go with string-id=? to help.  

Many implementations will of course implement these things by
folding.  But if you think that really string-id=? should be allowed
to implement arbitrary equivalence classes (provided that the standard
character set works right), it isn't obvious to me that
fold-identifier can be cheap, and that it might well be more expensive
than whatever straightforward test is used.

&gt; * (concatenate-identifiers s0 s1 ...) =&gt; id
&gt; 
&gt;      Return a string ID, containing an identifier name which
&gt;      is the concatenation of the arguments which must themselves
&gt;      be identifier names.

&gt;      (As nearly as I can tell, CONCATENATE-IDENTIFIERS is needed
&gt;      because IDENTIFIER? won't be closed under STRING-APPEND -- but
&gt;      I could be mistake about that.  More research is needed.)

In the cases where identifier? isn't closed under string-append,
concatenate-identifiers might need to do more work than just
concatenate.  (What does &quot;the concatenation of the arguments&quot; mean, if
not string-append?)

&gt; * (char-id-start? c) =&gt; &lt;bool&gt;
&gt;   Return #t if C is a valid first character in an identifier.
&gt; 
&gt; * (char-id-extend? c) =&gt; &lt;bool&gt;
&gt;   Return #t if C is a valid non-first character in an identifier.

These may be contextual.  A character may be allowed in the beginning
of an identifier but only if, something else is true later on.
(Consider the &quot;if it's not a number, it's an identifier&quot; rule of the
current standard.)

Perhaps a system might want to have functions like this, but I'd like
to see more experience before standardizing something.

&gt; What about case independent character ordering (e.g., CHAR-CI&lt;? and
&gt; STRING-CI&lt;?)?  I see no compelling reason to eliminate them at this
&gt; stage -- they're still useful.  I think they should be specified to be
&gt; consistent with the single-character default case foldings of Unicode,
&gt; where the portable character set is considered to consist of Unicode
&gt; characters.  This will allow portable Scheme programs to use these
&gt; procedures to write programs which accurately manipulate Scheme
&gt; programs that use nothing but the portable character set.  

string-ci&lt;? is fine, but must have a locale argument.  If you want to
have a standardly specified &quot;default case foldings of Unicode&quot; locale,
that's fine with me.  Ditto for char-ci&lt;?.

&gt; What about case mappings (CHAR-UPCASE and CHAR-DOWNCASE).  Again:
&gt; retain them;  specify them as using the Unicode single character
&gt; mappings; permit implementations to add parameters are new procedures
&gt; -- the result allows portable Scheme programs to handle portable
&gt; Scheme program texts and captures a useful Unicode text process.

No, no, no.  Don't make functions that are known to be wrong.  This is
a bad idea.  It's like requiring &lt; to work for complex numbers, and
then comparing magnitude, and saying &quot;well, that's close enough&quot;.
It's not.

You can case map strings, and this should certainly be allowed.  It
should also have a locale argument.

You cannot sensible case-map characters except in the &quot;unicode single
character mappings&quot; locale; and why should we have special privileged
functions there?  It will only encourage people to *use* the
functions, and their code will then be non-portable precisely when it
matters.  

At the very least, make it allowed for char-upcase to simply fail to
give any answer, and provide a locale argument.  Or allow char-upcase
to return a string.

&gt; A final note: the desirability of the -CI, -UPCASE, and -DOWNCASE
&gt; procedures hinges on the assumption that the portable Scheme character
&gt; set is a proper subset of Unicode.   

I'm assuming that (or at least, I want to make it possible), but I do
*not* think that char-upcase and char-downcase are good ideas.

string-upcase and string-downcase, by contrast, are unobjectionable,
provided they get a locale argument.

Thomas

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00399" href="msg00399.html">Re: Parsing Scheme [was Re: strings draft]</a></strong>
<ul><li><em>From:</em> Tom Lord</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00342" href="msg00342.html">strings draft</a></strong>
<ul><li><em>From:</em> Tom Lord</li></ul></li>
<li><strong><a name="00371" href="msg00371.html">Parsing Scheme [was Re: strings draft]</a></strong>
<ul><li><em>From:</em> Ken Dickey</li></ul></li>
<li><strong><a name="00378" href="msg00378.html">Re: Parsing Scheme [was Re: strings draft]</a></strong>
<ul><li><em>From:</em> Tom Lord</li></ul></li>
<li><strong><a name="00381" href="msg00381.html">Re: Parsing Scheme [was Re: strings draft]</a></strong>
<ul><li><em>From:</em> Thomas Bushnell, BSG</li></ul></li>
<li><strong><a name="00385" href="msg00385.html">Re: Parsing Scheme [was Re: strings draft]</a></strong>
<ul><li><em>From:</em> Tom Lord</li></ul></li>
<li><strong><a name="00394" href="msg00394.html">Re: Parsing Scheme [was Re: strings draft]</a></strong>
<ul><li><em>From:</em> Thomas Bushnell, BSG</li></ul></li>
<li><strong><a name="00395" href="msg00395.html">Re: Parsing Scheme [was Re: strings draft]</a></strong>
<ul><li><em>From:</em> Tom Lord</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00396.html">Re: strings draft</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00398.html">Re: strings draft (premature,  need first class type definition	support first?)</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00395.html">Re: Parsing Scheme [was Re: strings draft]</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00399.html">Re: Parsing Scheme [was Re: strings draft]</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00397"><strong>Date</strong></a></li>
<li><a href="threads.html#00397"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
