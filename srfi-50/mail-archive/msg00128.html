<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: no constants please -->
<!--X-From-R13: Fbz Zbeq <ybeqNrzs.arg> -->
<!--X-Date: Wed, 31 Dec 2003 22:34:04 +0100 (NFT) -->
<!--X-Message-Id: 200312312159.NAA28424@morrowfield.regexps.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: E1Abnds&#45;000577&#45;00@mail.mumble.net -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: no constants please</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00127.html">Date Prev</a>][<a href="msg00129.html">Date Next</a>][<a href="msg00127.html">Thread Prev</a>][<a href="msg00129.html">Thread Next</a>][<a href="maillist.html#00128">Date Index</a>][<a href="threads.html#00128">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: no constants please</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: <a href="mailto:kelsey@DOMAIN.HIDDEN">kelsey@xxxxxxx</a></li>
<li><em>Subject</em>: Re: no constants please</li>
<li><em>From</em>: Tom Lord &lt;<a href="mailto:lord@DOMAIN.HIDDEN">lord@xxxxxxx</a>&gt;</li>
<li><em>Date</em>: Wed, 31 Dec 2003 13:59:09 -0800 (PST)</li>
<li><em>Cc</em>: <a href="mailto:tb@DOMAIN.HIDDEN">tb@xxxxxxxxxx</a>, <a href="mailto:srfi-50@DOMAIN.HIDDEN">srfi-50@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-50@DOMAIN.HIDDEN">srfi-50@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:E1Abnds-000577-00@DOMAIN.HIDDEN">E1Abnds-000577-00@xxxxxxxxxxxxxxx</a>&gt; (message from Richard Kelsey	on Wed, 31 Dec 2003 16:12:36 -0500)</li>
<li><em>References</em>: &lt;<a href="mailto:E1Abnds-000577-00@DOMAIN.HIDDEN">E1Abnds-000577-00@xxxxxxxxxxxxxxx</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>

    tb&gt; It is a known strategy for more complex memory systems to have
    tb&gt; a variety of different values for certain constants.

    rk&gt; Okay, but that doesn't supply an answer to either question.
    rk&gt; [....]

    rk&gt; This thread started with Tom Lord's statement:
    rk&gt; [....]
    rk&gt; tl&gt; because, you never know, those constants might be heap allocated.

    rk&gt; and then in a second message:  

    rk&gt; tl&gt; Perhaps it would be clearer if I said that those constants
    rk&gt; tl&gt; may be _newly_ heap allocated.

    rk&gt; I can't imagine why an implementation would allocate any of
    rk&gt; these constants on the fly.

tb just gave you one.


    rk&gt; There is a cost to indicating that a functions or macros may
    rk&gt; trigger a GC.  

So, basically, you don't care about threads or async execution?  It's
only if you don't care about those things that you need to indicate
which functions may trigger GC.  Otherwise, GC may occur anytime that
it isn't specifically excluded.


    &gt; Their uses have to be scrutinized to see which
    &gt; values are live across the use.  It's a total pain.  

Regarding which both the Pika and JNI/minor-style interfaces provide a
mitigation of that pain.


    &gt; I can't see declaring that SCHEME_FALSE, SCHEME_TRUE,
    &gt; SCHEME_NULL or SCHEME_UNDEFINED might trigger a GC just because
    &gt; there might someday exist such an implementation.

You haven't given any _positive_ reasons for making exceptions of
those values.

Your critics are proposing only greater _regularity_ in the FFI --
that's sufficient for everything we can imagine in some future
implementation.   You make it sound like we're trying to drive the
decision based on some hypothetical and unlikely future but really,
you can reach the same conclusion we have just by deciding not to
introduce gratuitous special cases in the FFI.


    &gt; If someone produces an undefined-value SRFI that describes
    &gt; undefined-value object containing useful data, such as Bear
    &gt; has in his implementation, then it would make sense to have
    &gt; a way to create such objects from C.  It doesn't make sense
    &gt; to do so now, when there isn't any such SRFI.  Even with
    &gt; such a SRFI there would be utility to having an undefined
    &gt; value that could be used in places where a GC would be
    &gt; undesirable.

Nobody has suggested that you provide a special interface for
bear-style undefineds.  With a parameterless, UNDEFINED-producing
function, bear could define that to good effect as a macro that
implicitly passes __FILE__ and __LINE__ and the like.

-t


</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00129" href="msg00129.html">Re: no constants please</a></strong>
<ul><li><em>From:</em> Richard Kelsey</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00127" href="msg00127.html">Re: no constants please</a></strong>
<ul><li><em>From:</em> Richard Kelsey</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00127.html">Re: no constants please</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00129.html">Re: no constants please</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00127.html">Re: no constants please</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00129.html">Re: no constants please</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00128"><strong>Date</strong></a></li>
<li><a href="threads.html#00128"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
