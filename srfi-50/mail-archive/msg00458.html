<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: Permitting and Supporting Extended Character Sets: response. -->
<!--X-From-R13: orne <orneNfbavp.arg> -->
<!--X-Date: Tue, 10 Feb 2004 01:23:01 +0100 (NFT) -->
<!--X-Message-Id: Pine.LNX.4.58.0402091433390.7119@bolt.sonic.net -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 200402072249.OAA18427@morrowfield.regexps.com -->
<!--X-Reference: Pine.LNX.4.58.0402081919550.26398@bolt.sonic.net -->
<!--X-Reference: 200402091716.JAA24462@morrowfield.regexps.com -->
<!--X-Reference: Pine.LNX.4.58.0402090933280.8273@bolt.sonic.net -->
<!--X-Reference: 200402092210.OAA05622@morrowfield.regexps.com -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: Permitting and Supporting Extended Character Sets: response.</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00457.html">Date Prev</a>][<a href="msg00459.html">Date Next</a>][<a href="msg00457.html">Thread Prev</a>][<a href="msg00459.html">Thread Next</a>][<a href="maillist.html#00458">Date Index</a>][<a href="threads.html#00458">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: Permitting and Supporting Extended Character Sets: response.</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: Tom Lord &lt;<a href="mailto:lord@DOMAIN.HIDDEN">lord@xxxxxxx</a>&gt;</li>
<li><em>Subject</em>: Re: Permitting and Supporting Extended Character Sets: response.</li>
<li><em>From</em>: bear &lt;<a href="mailto:bear@DOMAIN.HIDDEN">bear@xxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Mon, 9 Feb 2004 16:22:42 -0800 (PST)</li>
<li><em>Cc</em>: <a href="mailto:srfi-50@DOMAIN.HIDDEN">srfi-50@xxxxxxxxxxxxxxxxx</a>, <a href="mailto:pika-dev@DOMAIN.HIDDEN">pika-dev@xxxxxxxxxx</a></li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-50@DOMAIN.HIDDEN">srfi-50@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:200402092210.OAA05622@DOMAIN.HIDDEN">200402092210.OAA05622@xxxxxxxxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>References</em>: &lt;<a href="mailto:200402072249.OAA18427@DOMAIN.HIDDEN">200402072249.OAA18427@xxxxxxxxxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:Pine.LNX.4.58.0402081919550.26398@DOMAIN.HIDDEN">Pine.LNX.4.58.0402081919550.26398@xxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:200402091716.JAA24462@DOMAIN.HIDDEN">200402091716.JAA24462@xxxxxxxxxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:Pine.LNX.4.58.0402090933280.8273@DOMAIN.HIDDEN">Pine.LNX.4.58.0402090933280.8273@xxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:200402092210.OAA05622@DOMAIN.HIDDEN">200402092210.OAA05622@xxxxxxxxxxxxxxxxxxxxxxx</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>

On Mon, 9 Feb 2004, Tom Lord wrote:

&gt;    &gt; From: bear &lt;bear@xxxxxxxxx&gt;
&gt;
&gt;    &gt; The result of case-mapping via char-ci=? only on cased characters is
&gt;    &gt; that distinct identifiers written using these characters remain
&gt;    &gt; distinct no matter what the preferred case of the implementation
&gt;    &gt; is. That's the desirable, crucial property that I was trying to
&gt;    &gt; capture with the distinction between cased and uncased characters.
&gt;
&gt;I don't see why that property is crucial.
&gt;
&gt;Here's where I am on these thing:  please have a look at the
&gt;&quot;References&quot; section of the &quot;Unicode Identifiers&quot; draft.  The
&gt;consortium has made recommendations for case-insensitive programming
&gt;languages.   I think we should follow those and I don't think that
&gt;they're consistent with what you are adocating.

They are, very slightly, a superset of the unicode consortium's
reccomendations.  A scheme implementing that property will be
consistent with Unicode's reccomendations, but Unicode's
reccomendations are not entirely adequate to describe that property.

I believe that the additional restrictions become necessary because
the consortium's recommendations are not entirely adequate for the
needs of programming languages in which identifiers can be manipulated
as strings or result from calculation on strings, and where operations
such as string-ci=? are expected to be able to detect identifiers
which are &quot;the same&quot; identifier.  Scheme is such a language.

&gt;    &gt; I chose the properties of characters I called &quot;cased&quot; and &quot;uncased&quot;
&gt;    &gt; carefully; the distinctions they make are necessary and sufficient to
&gt;    &gt; allow implementations to detect which characters can safely be
&gt;    &gt; regarded as cased characters in the normal sense,
&gt;
&gt;I assume that you mean (Scheme) programs, not implementations.
&gt;
&gt;Programs can already detect which characters are naively cased in the
&gt;sense of your terms.   That you are able to define your CHAR-CASED in
&gt;a few lines of R5RS illustrates that.

While the definitions are implementable in a few lines of R5RS, the
point is that developers realizing they need such a predicate are
likely to implement it as you implemented your version of
char-alphabetic? - without realizing that the &quot;simplest&quot; definition
does not in fact describe characters having a one-to-one
correspondence between lowercase and uppercase characters and
therefore is not sufficient to preserve the portability of their
programs from harm.  It is better to provide this definition in a
standard and nail its meaning down rather than allowing its necessity
to drive the creation of many incompatible and/or buggy versions.

&gt; consider me to have written:
&gt;	For example, a Unicode STRING-&gt;SYMBOL _may_ wish to not
&gt;        canonicalize .....
&gt;
&gt;and my point stands.
&gt;
&gt;You'll want to take up this issue separately, in response to &quot;Scheme
&gt;Characters as (Extended) Unicode Codepoints&quot;, I think.
&gt;
&gt;
&gt;    &gt; IOW, because Macron and Cedilla are in different combining
&gt;    &gt; classes, the sequences A, Macron, Cedilla and A, Cedilla, Macron
&gt;    &gt; ought to be regarded as equal in a string comparison.
&gt;
&gt;Not by STRING=? in a Scheme in which the strings are regarded as
&gt;codepoint sequences, since STRING=? is the equivalence relation
&gt;induced by CHAR=?.

no...

(Char=? #\A:Macron:Cedilla #\A:Cedilla:Macron) =&gt; #t

(= (char-&gt;integer #\A:Macron:Cedilla)
   (char-&gt;integer #\A:Cedilla:Macron)) =&gt; #t

(String=? &quot;arf\(U+41:Macron:Cedilla)arf&quot;
          &quot;arf\(U+41:Cedilla:Macron)arf&quot;) =&gt; #t

string=? is in fact the equivalence relation induced by char=?.

You are, I expect, running into a problem I don't experience because
you prefer a representation that requires individual combining
codepoints to occupy separate, distinguishable locations in a string,
and as a result you are setting up a situation in which
autocanonicalization cannot be done transparently.  implementations
that conform to your proposal will need to take extra steps
(canonicalization, etc) to conform to the consortium's definition of
string equality.

&gt; And, incidentally, although that STRING=? is not the linguistically
&gt; sensitive string-equality relation that Unicode defines, it _is_ a
&gt; useful procedure to have around for _implementing_ Unicode text
&gt; processes.

Please humor me by not banning schemes in which string=? can be both.

&gt; _IF_ it were possible to define CHAR-ALPHABETIC? in a way which was
&gt; both linguistically correct _and_ upwards compatible with R5RS then
&gt; perhaps that would be almost a good idea.  I say &quot;almost&quot; because
&gt; CHAR-IDEOGRAPHIC? and CHAR-SYLLABIC? add bloat and those plus
&gt; CHAR-ALPHABETIC? fails to be a complete enumeration of letter
&gt; types....

&gt; But CHAR-ALPHABETIC? is just a botch.  It can not be rescued.  All
&gt; of these character classes belong elsewhere, with different names --
&gt; in a &quot;Linguistic Text Processing&quot; SRFI.

If you don't care to rescue it, then at least try to avoid abusing it
further.  I'd rather drop it all together rather than forcing this
case mapping property that doesn't belong with it onto it.

Char-alphabetic?  is properly, and should be, of exactly the same
stature as char-ideographic?  or char-syllabic? or (just remembered
this) char-phonemic? and maybe a few others.  If any of these don't
belong in the standard, then none of these belong in the standard.
They can be reintroduced as library procedures in a language-handling
library, if and when that becomes necessary.

Maybe char-letter?, completely devoid of case requirements, is in fact
all that the standard needs.

&gt; A predicate to detect &quot;cased&quot; characters can be trivially
&gt; synthesized from CHAR-UPCASE, CHAR-DOWNCASE, and CHAR=?.  I see no
&gt; need for it to be required by R6RS.

It can be trivially synthesized, but more than half of the people who
do it will do it with slightly different semantics if a precise
definition is not given.

&gt; Breaking CHAR-ALPHABETIC? in the way that you propose will not break
&gt; correct protable programs whose _input_data_ consists only of
&gt; portable characters, but it can break correct portable programs
&gt; whose input data includes extended characters.  There is no
&gt; particular reason to introduce that breakage.

Can you give an example?



&gt;  You are thinking that I am trying to make make CHAR-ALPHABETIC?
&gt; linguistically useful.  What I'm actually trying to do is to
&gt; minimize the degree to which CHAR-ALPHABETIC? is linguistically
&gt; useless.  The invariant above is in that spirit.

&gt; The requirements in R5RS for CHAR-ALPHABETIC? already make it
&gt; linguistic nonsense.  There's no hope for it.  Deprecating it is the
&gt; best thing.

You may be right; I'd prefer to see it excised completely from the
standard rather than preserved with this bizarre case requirement.  I
consider it nonsensical to say &quot;this character fails to behave
according to these expectations for cased characters and therefore we
will call it non-alphabetic even though it is part of an alphabet.&quot;

Even if previous editions of the standard presumed that all alphabetic
characters were cased, this is breakage.  You need to identify the set
of characters that behave as previous editions of the standard assumed
&quot;alphabetic&quot; characters behaved, but &quot;alphabetic&quot; is not the right
word to describe those characters. &quot;Char-alphabetic?&quot; should be simply
clarified NOT to be a description of case properties, although there
are no counterexamples to such a reading in the portable character
set.  As a general description of characters having these case
properties, a properly-named predicate should be introduced instead.
This permits &quot;alphabetic&quot; to retain its case semantics over at least
the portable character set, (which are all that portable programs have
ever relied on), without abandoning its linguistic meaning.

&gt;    &gt; Further, your definition does not capture the full range of what you
&gt;    &gt; need to express when checking for this property; characters such as
&gt;    &gt; dotless-i will be char-alphabetic? according to the definition above
&gt;    &gt; while still capable of causing bugs with char-ci=? and case-blind
&gt;    &gt; identifiers because they are not the preferred lowercase mappings of
&gt;    &gt; their own preferred uppercase mappings.

&gt;I'm following the letter of the (deprecated, stupid) law.  R5RS does
&gt;_not_ require, _even_for_ CHAR-ALPHABETIC? _characters_, that:

&gt;	(char=? (char-downcase c) (char-downcase (char-upcase c)))
&gt;        =&gt; #t

&gt;Amazing but true.

It does not require it explicitly but it depends on it for the correct
reading of identifiers which are not in the implementation's preferred
case.  Amazing but true.

&gt;There is no need to introduce the (linguistically random) notion of
&gt;&quot;cased character&quot;.   With the invariant I gave for CHAR-ALPHABETIC?,
&gt;correct, portable R5RS programs remain so.

The invariant you gave for CHAR-ALPHABETIC? is not merely
linguistically random. As applied to an extended character set, it is
linguistically wrong.  It is incorrect. It is false.

Moreover, It allows merging of identifiers which should not be merged
when those identifiers contain CHAR-ALPHABETIC?  (your definition)
characters which are not CHAR-CASED? (my definition) and their case
mapping properties interact badly with the implementation's preferred
case.

Therefore, it does not have the properties you claim for it for all
possible character sets. It happens to have those properties for the
portable character set, but its definition is not adequate to assure
them.  If you desire those properties, you will have to use a
definition like the one I proposed for CHAR-CASED?, whatever you
choose to call it.

&gt;R6RS should not attempt to provide comprehensive facilities for
&gt;Unicode text processing.   It should attempt to provide a minimum of
&gt;upward compatible character and string facilities which are a useful
&gt;_subset_ of Unicode text processing, close in informal meaning to what
&gt;the R5RS versions say.   My proposal does that.

I do not believe that it does. Setting aside for the moment the fact
that attaching the case invariants to char-alphabetic? is incorrect,
you have not identified the correct set of case invariants needed for
character-insensitive identifiers to remain distinct in correct,
portable programs.

&gt;The CHAR-ALPHABETIC? invariant that I gave is consistent with an
&gt;implementation that defines it for truly alphabetic characters that
&gt;are &quot;cased&quot; in the sense you have been using.  It's consistent with
&gt;R5RS.  It's a hopeless cause to try to require more from
&gt;CHAR-ALPHABETIC? than that and deprecating CHAR-ALPHABETIC? is
&gt;necessary.

The invariant you gave is necessary, but not sufficient.  It
identifies characters which have both lowercase and uppercase
forms, but it does not identify characters which are part of a
reciprocal 1-to-1 case mapping.

				Bear

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00459" href="msg00459.html">Re: Permitting and Supporting Extended Character Sets: response.</a></strong>
<ul><li><em>From:</em> Tom Lord</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00443" href="msg00443.html">Unicode and Scheme</a></strong>
<ul><li><em>From:</em> Tom Lord</li></ul></li>
<li><strong><a name="00451" href="msg00451.html">Permitting and Supporting Extended Character Sets: response.</a></strong>
<ul><li><em>From:</em> bear</li></ul></li>
<li><strong><a name="00453" href="msg00453.html">Re: Permitting and Supporting Extended Character Sets: response.</a></strong>
<ul><li><em>From:</em> Tom Lord</li></ul></li>
<li><strong><a name="00455" href="msg00455.html">Re: Permitting and Supporting Extended Character Sets: response.</a></strong>
<ul><li><em>From:</em> bear</li></ul></li>
<li><strong><a name="00457" href="msg00457.html">Re: Permitting and Supporting Extended Character Sets: response.</a></strong>
<ul><li><em>From:</em> Tom Lord</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00457.html">Re: Permitting and Supporting Extended Character Sets: response.</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00459.html">Re: Permitting and Supporting Extended Character Sets: response.</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00457.html">Re: Permitting and Supporting Extended Character Sets: response.</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00459.html">Re: Permitting and Supporting Extended Character Sets: response.</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00458"><strong>Date</strong></a></li>
<li><a href="threads.html#00458"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
