<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: Comparing Pika&#45;syle and JNI&#45;style -->
<!--X-From-R13: Xvz Pynaql <wvzoNerqung.pbz> -->
<!--X-Date: Wed, 14 Jan 2004 22:22:24 +0100 (NFT) -->
<!--X-Message-Id: vt2u12yb4zc.fsf@zenia.home -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: E1AfQRd&#45;0000Qa&#45;00@mail.mumble.net -->
<!--X-Reference: vt2y8scua4h.fsf@zenia.home -->
<!--X-Reference: 877jzwtzaz.fsf@becket.becket.net -->
<!--X-Reference: vt2ptdn2bqq.fsf@zenia.home -->
<!--X-Reference: vt2isje3nna.fsf_&#45;_@zenia.home -->
<!--X-Reference: 200401141840.KAA07050@morrowfield.regexps.com -->
<!--X-Reference: vt2lloacno0.fsf@zenia.home -->
<!--X-Reference: 200401142105.NAA07813@morrowfield.regexps.com -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: Comparing Pika-syle and JNI-style</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00307.html">Date Prev</a>][<a href="msg00309.html">Date Next</a>][<a href="msg00302.html">Thread Prev</a>][<a href="msg00310.html">Thread Next</a>][<a href="maillist.html#00308">Date Index</a>][<a href="threads.html#00308">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: Comparing Pika-syle and JNI-style</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: Tom Lord &lt;<a href="mailto:lord@DOMAIN.HIDDEN">lord@xxxxxxx</a>&gt;</li>
<li><em>Subject</em>: Re: Comparing Pika-syle and JNI-style</li>
<li><em>From</em>: Jim Blandy &lt;<a href="mailto:jimb@DOMAIN.HIDDEN">jimb@xxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: 14 Jan 2004 16:22:15 -0500</li>
<li><em>Cc</em>: <a href="mailto:srfi-50@DOMAIN.HIDDEN">srfi-50@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-50@DOMAIN.HIDDEN">srfi-50@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:200401142105.NAA07813@DOMAIN.HIDDEN">200401142105.NAA07813@xxxxxxxxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>References</em>: &lt;<a href="mailto:E1AfQRd-0000Qa-00@DOMAIN.HIDDEN">E1AfQRd-0000Qa-00@xxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:vt2y8scua4h.fsf@DOMAIN.HIDDEN">vt2y8scua4h.fsf@xxxxxxxxxx</a>&gt;	&lt;<a href="mailto:877jzwtzaz.fsf@DOMAIN.HIDDEN">877jzwtzaz.fsf@xxxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:vt2ptdn2bqq.fsf@DOMAIN.HIDDEN">vt2ptdn2bqq.fsf@xxxxxxxxxx</a>&gt;	&lt;<a href="mailto:vt2isje3nna.fsf_-_@DOMAIN.HIDDEN">vt2isje3nna.fsf_-_@xxxxxxxxxx</a>&gt;	&lt;<a href="mailto:200401141840.KAA07050@DOMAIN.HIDDEN">200401141840.KAA07050@xxxxxxxxxxxxxxxxxxxxxxx</a>&gt;	&lt;<a href="mailto:vt2lloacno0.fsf@DOMAIN.HIDDEN">vt2lloacno0.fsf@xxxxxxxxxx</a>&gt;	&lt;<a href="mailto:200401142105.NAA07813@DOMAIN.HIDDEN">200401142105.NAA07813@xxxxxxxxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Sender</em>: <a href="mailto:jimb@DOMAIN.HIDDEN">jimb@xxxxxxxxxx</a></li>
<li><em>User-agent</em>: Gnus/5.09 (Gnus v5.9.0) Emacs/21.3</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>
Tom Lord &lt;lord@xxxxxxx&gt; writes:

&gt;     &gt; From: Jim Blandy &lt;jimb@xxxxxxxxxx&gt;
&gt; 
&gt;     &gt; Tom Lord &lt;lord@xxxxxxx&gt; writes:
&gt;     &gt; &gt;     &gt; [cadr isn't very interesting, imho -- cadr example snipped]
&gt; 
&gt;     &gt; Could you humor me, and post the code anyway?  Of course, feel free to
&gt;     &gt; pose other problems.
&gt; 
&gt; <a  rel="nofollow" href="http://srfi.schemers.org/srfi-50/mail-archive/msg00241.html">http://srfi.schemers.org/srfi-50/mail-archive/msg00241.html</a>

See, that is interesting, though --- it shows that you don't have to
always set up frames in Pika, if you can do all your computation in
references owned by the calling frame.

&gt; Again, it comes down to the three classes of functions, (a), (b), and
&gt; (c).  My proposal allows people to write FFI-using code in any of
&gt; those three classes.  If the Pika FFI includes a standard interface to
&gt; that auxiliary stack, then people writing FFI-using code in class (c)
&gt; get full interoperability with one another.  But in the far more
&gt; common case (how many libraries do you know that permit longjmping
&gt; past them?), users writing FFI-using code in class (b) don't have to
&gt; pay for auxiliary stacks.

But I don't even want to have to think about whether I'm going to be
longjmped past.  It's a non-local property, involving code I probably
haven't even read, and certainly can't afford to audit each time it's
revised.  I'm willing to tolerate less-than-optimal behavior when a
longjmp occurs, as long as it's still correct, in exchange for not
having to think about it.  And I've suggested a way to fix the
problem: have SCM_PROTECT malloc frames, and SCM_UNPROTECT free them.

(People do get yelled at around here for not accepting workarounds
that have minor performance impacts, you know.  :)  Not that you did
that yourself.)

&gt;     &gt; That's right.  References must be explicitly freed; JNI can help you
&gt;     &gt; out in some cases, but you have to think about it.
&gt; 
&gt;     &gt; I think that JNI code will often be &quot;linear&quot;, in the SRFI-1 sense,
&gt;     &gt; with functions like 'f' that accept references being documented to
&gt;     &gt; free them.  The &quot;mn_to_car&quot; and &quot;mn_to_cdr&quot; functions are linear
&gt;     &gt; variants of &quot;mn_car&quot; and &quot;mn_cdr&quot;; we can add more of these as we find
&gt;     &gt; them useful.
&gt; 
&gt; Oh dear.   That's the thing: you're winding up not having a common
&gt; case of linear functions but instead, having a common case of wanting
&gt; two entry points for every function (one linear, one not).   And with
&gt; multiple parameters:  should it be linear in all of them?  or just
&gt; some?   Sounds like quite a mess.

To be fully general, you'd need 2^n variants of each function that
accepts n references.  This is the explicit-free hair.  At the moment,
I only have a few &quot;to&quot; functions, where I could think of important
idioms to support.

&gt;     &gt; The nice thing about functions that handle references in a linear way
&gt;     &gt; is that they are actually faster than ordinary functions: since you're
&gt;     &gt; about to free the reference, you know it's not shared amongst any
&gt;     &gt; threads, so you can reuse it without memory synchronization.  
&gt; 
&gt;     &gt; Thus the
&gt;     &gt; implementation of mn_to_car:
&gt; 
&gt;     &gt;     /* Officially, the following functions deallocate one of the
&gt;     &gt;        references they're passed (call it REF), and return a new
&gt;     &gt;        reference.  But in fact, they just set REF-&gt;obj, and return REF
&gt;     &gt;        as the new reference.
&gt; 
&gt;     &gt;        This can be done without synchronization, even if REF is a
&gt;     &gt;        global reference, because:
&gt;     &gt;        - if anyone ever refers to REF assuming the old value, there
&gt;     &gt;          must be a race condition, because it's about to be freed, and
&gt;     &gt;        - nobody should refer to REF expecting the new value, unless
&gt;     &gt;          they received it in some properly-synchronized way, because
&gt;     &gt;          it's supposed to be an entirely new reference.  */
&gt; 
&gt;     &gt;     mn_ref *
&gt;     &gt;     mn_to_car (mn_call *call, mn_ref *ref)
&gt;     &gt;     {
&gt;     &gt;       mn__begin_incoherent (call);
&gt;     &gt;       {
&gt;     &gt;         ref-&gt;obj = check_pair (ref)-&gt;car;
&gt;     &gt;       }
&gt;     &gt;       mn__end_incoherent (call);
&gt;     &gt; 
&gt;     &gt;       return ref;
&gt;     &gt;     }
&gt; 
&gt; Isn't that code incorrect in a threaded system?   While `ref' is,
&gt; indeed, about to be freed, the pair that it refers to is live.
&gt; Assuming that the `incoherent' calls exclude only GC but not other
&gt; mutators (which is the benefit you seem to be claiming), then the
&gt; `-&gt;car' risks producing garbage.

This is what that comment is going on about.  References are
immutable: there is no operation that changes a reference's referent.
mn_to_car looks like a counter-example, but it isn't: officially, it
frees REF, so it would be incorrect to call it if any other thread
were referring to it.  But since it's freeing a reference and then
immediately allocating a new one, it might as well just reuse the
reference.

&gt;     &gt;    NOTE: Many of the functions in this interface will typically be
&gt;     &gt;    used in contexts where the caller &quot;knows&quot; that no error will occur.
&gt;     &gt;    Having to check each call to these functions for an exception
&gt;     &gt;    return value is a burden; people probably wouldn't do it, and
&gt;     &gt;    people's experiences with this interface would be unpleasant.
&gt; 
&gt; That's what &quot;(void)&quot; is for? :-)

No, that doesn't address the issue at all.  I guess the comment isn't
as clear as I had thought it was.  I tried to rephrase it, but ended
up writing the same thing...  Hmm.

&gt;     &gt; &gt; 	err = g (&amp;frame.answer, instance, &amp;frame.x);
&gt;     &gt; &gt;         if (err)
&gt;     &gt; &gt;           {
&gt;     &gt; &gt;             ....;
&gt;     &gt; &gt;           }
&gt;     &gt; &gt;         err = f (&amp;frame.answer, instance, &amp;frame.answer);
&gt;     &gt; &gt;         if (err)
&gt;     &gt; &gt;           {
&gt;     &gt; &gt;             ...;
&gt;     &gt; &gt;           }
&gt; 
&gt;     &gt; Right: now imagine that g and f are 'car' and 'cdr'.  What should be
&gt;     &gt; 'mn_to_cdr (c, mn_car (c, x))' has become eight lines of code.
&gt; 
&gt; Apples and oranges.
&gt; 
&gt; The Pika-style equivalent to your code fragment is 2 lines, not 8.
&gt; 
&gt; 	scm_safely (g (&amp;frame.answer, instance, &amp;frame.x));
&gt; 	scm_safely (f (&amp;frame.answer, instance, &amp;frame.answer));

Oh, I agree --- I didn't mean to compare Pika vs. JNI there.  I meant
to compare check-for-error-codes vs. handle-error-internally.


&gt;     &gt; &gt;     &gt; - Variables are declared normally, and their values used directly.
&gt; 
&gt;     &gt; &gt; Variables are declared normally in Pika, too.  I think you mean that
&gt;     &gt; &gt; JNI-style attempts to disguise handles as Scheme values.  It is
&gt;     &gt; &gt; because it can't pull off that illusion perfectly that I think it is a
&gt;     &gt; &gt; questionable choice.
&gt; 
&gt;     &gt; There's an illusion at work in Pika, JNI, and SRFI-50, and it oozes
&gt;     &gt; out and reveals itself in all three systems.  (SRFI-50's ooze is that
&gt;     &gt; it limits when GC can happen.)  What I'm asking is which people
&gt;     &gt; consider the least of three oozes.
&gt; 
&gt; And I'm not criticizing your for asking.   I admit: Pika-style code is
&gt; the ugliest of the lot;  sometimes the most verbose.  I'm just making
&gt; the case that that's for very good reasons.
&gt; 
&gt; By the way: what is the &quot;illusion&quot; oozing out of Pika-style?  I don't
&gt; see it but perhaps I'm just too close to it.

Well, if you'll grant that this is fuzzy talk:

Pika's ooze is that you appear to be operating on local variables, but
you can only use them as lvalues, never rvalues.  And they're actually
data structures owned by the GC; rather than being managed by the
compiler, as local variables are, they have to be explicitly
registered and unregistered.  That's the source of the longjmp
problems, too.

If you malloc your frames, as I suggested, then your ooze is that you
can't use local variables.

A &quot;lump in the carpet&quot; metaphor would be better than ooze, I guess.

But anyway, all this finagling is how I ended up at the explicit-free
stuff.  The only way to really have a smooth carpet is to change C to
be precise-GC-friendly.  But we can't do that.  So the best you can do
is to put the lump in the carpet somewhere where people expect it, and
are used to stepping over it.

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00310" href="msg00310.html">Re: Comparing Pika-syle and JNI-style</a></strong>
<ul><li><em>From:</em> Tom Lord</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00262" href="msg00262.html">Re: when GC is permitted</a></strong>
<ul><li><em>From:</em> Richard Kelsey</li></ul></li>
<li><strong><a name="00283" href="msg00283.html">temporarily withdrawing SRFI-50</a></strong>
<ul><li><em>From:</em> Jim Blandy</li></ul></li>
<li><strong><a name="00287" href="msg00287.html">Re: temporarily withdrawing SRFI-50</a></strong>
<ul><li><em>From:</em> Thomas Bushnell, BSG</li></ul></li>
<li><strong><a name="00294" href="msg00294.html">Re: temporarily withdrawing SRFI-50</a></strong>
<ul><li><em>From:</em> Jim Blandy</li></ul></li>
<li><strong><a name="00295" href="msg00295.html">Comparing Pika-syle and JNI-style</a></strong>
<ul><li><em>From:</em> Jim Blandy</li></ul></li>
<li><strong><a name="00296" href="msg00296.html">Re: Comparing Pika-syle and JNI-style</a></strong>
<ul><li><em>From:</em> Tom Lord</li></ul></li>
<li><strong><a name="00299" href="msg00299.html">Re: Comparing Pika-syle and JNI-style</a></strong>
<ul><li><em>From:</em> Jim Blandy</li></ul></li>
<li><strong><a name="00302" href="msg00302.html">Re: Comparing Pika-syle and JNI-style</a></strong>
<ul><li><em>From:</em> Tom Lord</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00307.html">Re: when GC is permitted</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00309.html">Re: when GC is permitted</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00302.html">Re: Comparing Pika-syle and JNI-style</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00310.html">Re: Comparing Pika-syle and JNI-style</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00308"><strong>Date</strong></a></li>
<li><a href="threads.html#00308"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
