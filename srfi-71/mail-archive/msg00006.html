<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: what about dropping rest&#45;lists? -->
<!--X-From-R13: Eronfgvna Stare <fronfgvna.rtareNcuvyvcf.pbz> -->
<!--X-Date: Tue, 17 May 2005 13:59:46 +0200 (DFT) -->
<!--X-Message-Id: OF1F25D62C.F0476EF7&#45;ONC1257004.00369A69&#45;C1257004.0041D40C@philips.com -->
<!--X-Content-Type: multipart/alternative -->
<!--X-Reference: erWNxB.A.EAE.MDZiCB@rotkohl -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: what about dropping rest-lists?</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00005.html">Date Prev</a>][<a href="msg00007.html">Date Next</a>][<a href="msg00007.html">Thread Prev</a>][<a href="msg00009.html">Thread Next</a>][<a href="maillist.html#00006">Date Index</a>][<a href="threads.html#00006">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: what about dropping rest-lists?</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-71">SRFI 71</a> from before July 7th, 2015.  The <a href="http://srfi-email.schemers.org/srfi-71">new archives</a> for SRFI 71 contain all messages, not just those from before July 7th, 2015.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: <a href="mailto:srfi-71@DOMAIN.HIDDEN">srfi-71@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Subject</em>: Re: what about dropping rest-lists?</li>
<li><em>From</em>: Sebastian Egner &lt;<a href="mailto:sebastian.egner@DOMAIN.HIDDEN">sebastian.egner@xxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Tue, 17 May 2005 13:58:13 +0200</li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-71@DOMAIN.HIDDEN">srfi-71@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:erWNxB.A.EAE.MDZiCB@DOMAIN.HIDDEN">erWNxB.A.EAE.MDZiCB@rotkohl</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->

<br><font size=2><tt>Felix Winkelmann wrote:</tt></font>
<br><font size=2><tt>&gt; Is this correct? (not regarding the typos) Should
the latter occurence <br>
&gt; &quot;list-&gt;values&quot; be &quot;values-&gt;list&quot;?<br>
</tt></font>
<br><font size=2 face="sans-serif">Indeed, it should.</font>
<br>
<br><font size=2><tt>&gt; Could you (Sebastian) explain this a little?
I understand that there are several<br>
&gt; ways of decomposing complex data-structures into values, but for lists
and<br>
&gt; vectors, the way they are decomposed appears to be straightforward
to me.<br>
&gt; So I *would* think that ...-&gt;values might be more appropriate,
but this is<br>
&gt; probably a matter of taste...<br>
</tt></font>
<br><font size=2 face="sans-serif">In the end, it is a matter of taste.
I switched a number of times already before</font>
<br><font size=2 face="sans-serif">submitting the SRFI, but what tilted
the scale in the end was the DEQUE example</font>
<br><font size=2 face="sans-serif">(found in 'examples.scm'): The &quot;un&quot;-convention
modifies an English verb </font>
<br><font size=2 face="sans-serif">(to cons -&gt; to uncons) and does not
express a conversion. After some time I</font>
<br><font size=2 face="sans-serif">learned to like the &quot;un&quot;-convention,
and until now I had little reason for </font>
<br><font size=2 face="sans-serif">adding ...-&gt;values redundantly.</font>
<br>
<br><font size=2><tt>&gt; I wonder if the decomposition operations (and
&quot;values-&gt;...&quot;) should be <br>
&gt; dropped completely from this SRFI.<br>
&gt; They do not really fit to the main intention of this SRFI (as I understand<br>
&gt; it - mainly extzending &quot;let&quot;) and look like being thrown
in for good measure.</tt></font>
<br>
<br><font size=2 face="sans-serif">The main intention of this SRFI is a
little more ambitious than extending &quot;let&quot;:</font>
<br><font size=2 face="sans-serif">The main intention of this SRFI is integrating
multiple values smoothly into</font>
<br><font size=2 face="sans-serif">the Scheme language. In other words,
there should be a (preferably small)</font>
<br><font size=2 face="sans-serif">well-designed toolbox for dealing with
multiple values---and a turnkey way</font>
<br><font size=2 face="sans-serif">of packing values into heap-allocated
data structures (and unpacking</font>
<br><font size=2 face="sans-serif">again) is a natural part of that.</font>
<br><font size=2><tt><br>
&gt; &quot;uncons&quot; is already provided by SRFI-1 (&quot;car+cdr&quot;),
and the other<br>
&gt; operations are seldom used and don't really make our life much easier<br>
&gt; (IMHO).<br>
</tt></font>
<br><font size=2 face="sans-serif">In case this SRFI would eventually find
it's way into Scheme, both points might change:</font>
<br><font size=2 face="sans-serif">a) the decomposition ops do make life
easier, and hence,</font>
<br><font size=2 face="sans-serif">b) they will be used more frequently.</font>
<br>
<br><font size=2 face="sans-serif">If you look at Olin Shivers code for
sorting (e.g. in the Scheme 48 1.2 release)</font>
<br><font size=2 face="sans-serif">you find that multiple values are used
frequently and consistently. Unfortunately,</font>
<br><font size=2 face="sans-serif">the code is drenched in values/call-with-values.
[I am talking about things like </font>
<br><font size=2 face="sans-serif">'vector-util.scm': has-element/list-ref-or-default.]
Looking at the code more closely,</font>
<br><font size=2 face="sans-serif">you will also find macros [e.g. let-vector-start+end
in 'sort-support-macs.scm']</font>
<br><font size=2 face="sans-serif">that are ad hoc binding constructs for
solving a multiple value parameter</font>
<br><font size=2 face="sans-serif">passing problem. Of course, all this
has to do with the fact that the code was</font>
<br><font size=2 face="sans-serif">written long before tools for multiple
values (like receive) became standard.</font>
<br>
<br><font size=2 face="sans-serif">Well, this SRFI provides a general alternative
solution for the parameter passing</font>
<br><font size=2 face="sans-serif">problem, provided some operations like
unlist/values-&gt;list are included.</font>
<br>
<br><font size=2 face="sans-serif">There is another, deeper, aspect to
&quot;life made easiler&quot;: Right now data </font>
<br><font size=2 face="sans-serif">structures and types are defined in
terms of access functions, but often</font>
<br><font size=2 face="sans-serif">all I need to do is decompose the record
entirely. So, consider the following</font>
<br><font size=2 face="sans-serif">little syntax extension to SRFI 9 (define-record-type):</font>
<br>
<br><font size=2 face="sans-serif">&nbsp; &nbsp; &nbsp; &nbsp; (define-record-type
kons-pair (kons x y) kons? unkons)</font>
<br><font size=2 face="sans-serif">&nbsp; &nbsp; &nbsp; &nbsp; </font>
<br><font size=2 face="sans-serif">where kons-pair is a descriptive name
for the new type, kons? is a type</font>
<br><font size=2 face="sans-serif">predicate, kons is a binary constructor,
and unkons a deconstructor</font>
<br><font size=2 face="sans-serif">delivering the values x and y to its
continuation. You really need a KAR</font>
<br><font size=2 face="sans-serif">operation? Here it is: (lambda (p) (let
((x y (unkons p))) x)).</font>
<br>
<br><font size=2 face="sans-serif">In fact, the DEQUE example from 'examples.scm'
of this SRFI simply</font>
<br><font size=2 face="sans-serif">uses cons/uncons, but what I really
had in mind was </font>
<br>
<br><font size=2 face="sans-serif">&nbsp; &nbsp; &nbsp; &nbsp; (define-record-type
deque (deque:make f r) deque? deque:unmake)</font>
<br>
<br><font size=2 face="sans-serif">with the subsequent code unaltered.
You can decide for yourself if you</font>
<br><font size=2 face="sans-serif">like this style of dealing with records
(it is not always appropriate) but it</font>
<br><font size=2 face="sans-serif">can make life easier (and the code could
even be more efficient because</font>
<br><font size=2 face="sans-serif">fewer type checks are executed.)</font>
<br>
<br><font size=2 face="sans-serif">I did not include define-record-type
syntax into this SRFI because it is</font>
<br><font size=2 face="sans-serif">beyond the scope of this SRFI for now,
but it crossed my mind. However,</font>
<br><font size=2 face="sans-serif">I did not want to leave out *some* way
of decomposing data structures,</font>
<br><font size=2 face="sans-serif">and there were just two obvious candidates...</font>
<br>
<br><font size=2 face="sans-serif">Does this explanation satisfy you?</font>
<br>
<br><font size=2 face="sans-serif">Sebastian.</font>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00009" href="msg00009.html">Re: what about dropping rest-lists?</a></strong>
<ul><li><em>From:</em> felix winkelmann</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00005.html">Re: what about dropping rest-lists?</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00007.html">Re: what about dropping rest-lists?</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00007.html">Re: what about dropping rest-lists?</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00009.html">Re: what about dropping rest-lists?</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00006"><strong>Date</strong></a></li>
<li><a href="threads.html#00006"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
