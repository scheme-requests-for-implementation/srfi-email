<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: How about dropping semi&#45;variable&#45;arity? -->
<!--X-From-R13: Eronfgvna Stare <fronfgvna.rtareNcuvyvcf.pbz> -->
<!--X-Date: Thu, 19 May 2005 14:13:35 +0200 (DFT) -->
<!--X-Message-Id: OF87169BD8.B0BA337E&#45;ONC1257006.0042EE81&#45;C1257006.00432823@philips.com -->
<!--X-Content-Type: multipart/alternative -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: How about dropping semi-variable-arity?</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00020.html">Date Prev</a>][<a href="msg00022.html">Date Next</a>][<a href="msg00020.html">Thread Prev</a>][<a href="msg00022.html">Thread Next</a>][<a href="maillist.html#00021">Date Index</a>][<a href="threads.html#00021">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: How about dropping semi-variable-arity?</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-71">SRFI 71</a> from before July 7th, 2015.  The <a href="http://srfi-email.schemers.org/srfi-71">new archives</a> for SRFI 71 contain all messages, not just those from before July 7th, 2015.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: <a href="mailto:srfi-71@DOMAIN.HIDDEN">srfi-71@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Subject</em>: Re: How about dropping semi-variable-arity?</li>
<li><em>From</em>: Sebastian Egner &lt;<a href="mailto:sebastian.egner@DOMAIN.HIDDEN">sebastian.egner@xxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Thu, 19 May 2005 14:12:44 +0200</li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-71@DOMAIN.HIDDEN">srfi-71@xxxxxxxxxxxxxxxxx</a></li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->

<br><font size=2 face="sans-serif">-al wrote:</font>
<br><font size=2><tt>&gt; However, if that is provided, are you wedded
to the idea that lambda's<br>
&gt; feature of semi-variable-arity argument lists like (a b . c) must
also<br>
&gt; be supported?</tt></font>
<br><font size=2><tt>&gt;<br>
&gt; If you're thinking you want that so that you can use a destructuring<br>
&gt; idiom like:<br>
&gt;<br>
&gt; &nbsp;(let* ((foo '(1 2 3 4 5))<br>
&gt; &nbsp; &nbsp; &nbsp; &nbsp; ((values x y . z) (unlist foo)))<br>
&gt; &nbsp; &nbsp;(list x y (apply + z)))<br>
&gt; &nbsp;=&gt; (1 2 12)<br>
&gt;<br>
&gt; I would like to point out that that requires Z to be bound to a list<br>
&gt; of three new pairs and *not* to the cddr of FOO, so this really isn't<br>
&gt; an appropriate idiom for the typical operation of extracting the first<br>
&gt; few elements of a list and the remainder.</tt></font>
<br>
<br><font size=2 face="sans-serif">Well observed.</font>
<br>
<br><font size=2><tt>&gt; As has been suggested, the<br>
&gt; appropriate construct for that would be a pattern-match facility.<br>
</tt></font>
<br><font size=2 face="sans-serif">Not necessarily. More deconstructors
for lists of a certain length would cover most</font>
<br><font size=2 face="sans-serif">cases already, e.g. unccons, uncccons,
unccccons, ....</font>
<br>
<br><font size=2 face="sans-serif">Maybe one can even come up with a naming
convention (some sort of Van Dijk</font>
<br><font size=2 face="sans-serif">context-free language) encoding more
complicated binary trees into the name</font>
<br><font size=2 face="sans-serif">of the deconstructor; similar to c(a|d)^*r
specifying a path from the root in a binary tree.</font>
<br><font size=2 face="sans-serif">Pattern matching is of course more flexible,
but also much more expensive.</font>
<br>
<br><font size=2 face="sans-serif">In fact, my idea concerning the &quot;destructor
style&quot; of programming is that this SRFI</font>
<br><font size=2 face="sans-serif">could be a stepping stone towards patterns.
The severe limitation of pattern</font>
<br><font size=2 face="sans-serif">matching in most languages is that you
can only decompose concrete</font>
<br><font size=2 face="sans-serif">data structures. Often you want to decompose
an abstract data structure, i.e.</font>
<br><font size=2 face="sans-serif">I don't want to know how the priority
queue is represented, I just want to extract</font>
<br><font size=2 face="sans-serif">the minimal element. Now if you allow
this, and the language has side-effects,</font>
<br><font size=2 face="sans-serif">then user-defined decomposition operations
will shred your clean semantics,</font>
<br><font size=2 face="sans-serif">and maybe also limit the compiler's
options for making good code. This does</font>
<br><font size=2 face="sans-serif">not immediately imply, however, that
it's a bad idea. Scheme is full of procedures</font>
<br><font size=2 face="sans-serif">that behave like functions but are implemented
using side-effects.</font>
<br>
<br><font size=2 face="sans-serif">Now the mechanism in this SRFI with
uncons/unlist/unvector is just an inspiration</font>
<br><font size=2 face="sans-serif">for writing application-specific deconstructors.
I would be glad to see someone</font>
<br><font size=2 face="sans-serif">take up the challenge of defining a
good pattern matching mechanism that can</font>
<br><font size=2 face="sans-serif">apply application-specific deconstructors
in a convenient way.</font>
<br>
<br><font size=2><tt>&gt; If you drop support for semi-variable-arity,
and you drop support for<br>
&gt; zero-value clauses (which I will discuss more below) then you can
dump<br>
&gt; the VALUES keyword entirely, because (values . x) clauses can be more<br>
&gt; simply and clearly written -- without the triple-open-paren -- using<br>
&gt; values-&gt;list:<br>
</tt></font>
<br><font size=2 face="sans-serif">True. But I am not yet convinced that
getting rid of the VALUES keyword is worth</font>
<br><font size=2 face="sans-serif">dropping semi-variable arity, or zero-valued
clauses. Three parens is bad, but</font>
<br><font size=2 face="sans-serif">is it that bad?</font>
<br>
<br><font size=2><tt>&gt; With respect to zero-valued clauses: I'm not
sure it really makes<br>
&gt; sense to allow &quot;binding clauses&quot; that do not actually create
any<br>
&gt; bindings. &nbsp;In what situations are you thinking these would be
useful?<br>
</tt></font>
<br><font size=2 face="sans-serif">If you look at imperatively written
algorithms, e.g. often found in numerical analysis,</font>
<br><font size=2 face="sans-serif">you see variable bindings and statements
intermixed at a high rate, due to short-lived</font>
<br><font size=2 face="sans-serif">temporary variables. This is not specific
for Scheme but for the application domain.</font>
<br>
<br><font size=2 face="sans-serif">I wrote quite a bit of Ocaml code lately
and I quickly adopted the indentation</font>
<br><font size=2 face="sans-serif">convention of not indenting by scope
but by control structure. Example:</font>
<br>
<br><font size=1><tt>&nbsp; &nbsp; &nbsp; &nbsp; let x1 = foo1
x</tt></font>
<br><font size=1><tt>&nbsp; &nbsp; &nbsp; &nbsp; in &nbsp;foo2
x1;</tt></font>
<br><font size=1><tt>&nbsp; &nbsp; &nbsp; &nbsp; let x3 = foo3
x1 </tt></font>
<br><font size=1><tt>&nbsp; &nbsp; &nbsp; &nbsp; and x4 = foo4
x1</tt></font>
<br><font size=1><tt>&nbsp; &nbsp; &nbsp; &nbsp; in &nbsp;foo5
x1 x3 x4;;</tt></font>
<br>
<br><font size=2 face="sans-serif">If this stuff goes on for 30 lines and
more then a more conventional indentation</font>
<br><font size=2 face="sans-serif">makes you want to tilt you monitor 45
degrees clockwise...</font>
<br>
<br><font size=2 face="sans-serif">The nature of this sort of code is that
there is a linear sequence of things</font>
<br><font size=2 face="sans-serif">but the scopes flash in and out like
crazy.</font>
<br>
<br><font size=2 face="sans-serif">Of course, the usual reflex of programmers
is to forget about the actual</font>
<br><font size=2 face="sans-serif">data flow and write one giant LET*.
In Scheme everything has a value and</font>
<br><font size=2 face="sans-serif">hence you just write a binding (some-dummy-variable
&lt;no-values&gt;)</font>
<br><font size=2 face="sans-serif">when you need to execute a statement.
The only thing the ((values) &lt;_expression_&gt;)</font>
<br><font size=2 face="sans-serif">notation accomplishes is getting rid
of the dummy variable (and the notation for</font>
<br><font size=2 face="sans-serif">that is not even very good).</font>
<br>
<br><font size=2 face="sans-serif">Now what you propose is actually improving
the support for imperative</font>
<br><font size=2 face="sans-serif">programs. No doubt, I am in favor of
that. (And it annoyed me more than</font>
<br><font size=2 face="sans-serif">once that (begin) is not portable.)
However, I am not sure if this SRFI is</font>
<br><font size=2 face="sans-serif">the right place to attempt this. Fiddling
with LET is touchy already.</font>
<br>
<br><font size=2 face="sans-serif">Instead of modifying BEGIN, I am more
in favor of adding another production:</font>
<br>
<br><font size=2 face="sans-serif">&lt;binding spec&gt; --&gt; (begin &lt;_expression_&gt;*),</font>
<br>
<br><font size=2 face="sans-serif">which means nothing is bound and the
expressions are executed</font>
<br><font size=2 face="sans-serif">for side-effects, throwing away whatever
values they produce if any.</font>
<br>
<br><font size=2 face="sans-serif">Good style, or not, it allows to write</font>
<br>
<br><font size=1><tt>(let* ((y (foo x))</tt></font>
<br><font size=1><tt>&nbsp; &nbsp; &nbsp; &nbsp;(begin (display y))</tt></font>
<br><font size=1><tt>&nbsp; &nbsp; &nbsp; &nbsp;(z (bar-trashing-argument!
y)))</tt></font>
<br><font size=1><tt>&nbsp; z)</tt></font>
<br>
<br><font size=2 face="sans-serif">Two downsides: a) Looks funny. b) You
cannot bind a variable named 'begin'.</font>
<br><font size=2 face="sans-serif">Any other? If this is all, it could
be worth it.</font>
<br>
<br><font size=2 face="sans-serif">Sebastian.<br>
</font>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00022" href="msg00022.html">Re: How about dropping semi-variable-arity?</a></strong>
<ul><li><em>From:</em> Neil W. Van Dyke</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00020.html">Re: Rest and patterns</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00022.html">Re: How about dropping semi-variable-arity?</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00020.html">Re: Rest and patterns</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00022.html">Re: How about dropping semi-variable-arity?</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00021"><strong>Date</strong></a></li>
<li><a href="threads.html#00021"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
