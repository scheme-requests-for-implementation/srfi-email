<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: Some comments -->
<!--X-From-R13: [nep Trryrl <srryrlNWDA.G[bagerny.QO> -->
<!--X-Date: Sat,  4 Jan 2003 20:00:40 +0100 (NFT) -->
<!--X-Message-Id: 200301041900.h04J09k08622@dino00.iro.umontreal.ca -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 3E050560.6090507@freenet.de -->
<!--X-Reference: 200212220251.gBM2p2Y14110@dino00.iro.umontreal.ca -->
<!--X-Reference: 3E077CA2.2040703@freenet.de -->
<!--X-Reference: 200212301429.gBUETMm28219@dino00.iro.umontreal.ca -->
<!--X-Reference: 3E1701FF.20100@freenet.de -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: Some comments</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00014.html">Date Prev</a>][<a href="msg00016.html">Date Next</a>][<a href="msg00013.html">Thread Prev</a>][<a href="msg00016.html">Thread Next</a>][<a href="maillist.html#00015">Date Index</a>][<a href="threads.html#00015">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: Some comments</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-39">SRFI 39</a> from before July 7th, 2015.  The new archives for SRFI 39 are <a href="http://srfi-email.schemers.org/srfi-39/">here</a>.  The new archives contain all messages, not just those from before July 7th, 2015.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: <a href="mailto:felixundduni@DOMAIN.HIDDEN">felixundduni@xxxxxxxxxx</a></li>
<li><em>Subject</em>: Re: Some comments</li>
<li><em>From</em>: Marc Feeley &lt;<a href="mailto:feeley@DOMAIN.HIDDEN">feeley@xxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Sat, 4 Jan 2003 14:00:09 -0500</li>
<li><em>Cc</em>: <a href="mailto:srfi-39@DOMAIN.HIDDEN">srfi-39@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-39@DOMAIN.HIDDEN">srfi-39@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:3E1701FF.20100@DOMAIN.HIDDEN">3E1701FF.20100@xxxxxxxxxx</a>&gt; (message from felix on Sat, 04 Jan	2003 16:47:11 +0100)</li>
<li><em>References</em>: &lt;<a href="mailto:3E050560.6090507@DOMAIN.HIDDEN">3E050560.6090507@xxxxxxxxxx</a>&gt; &lt;<a href="mailto:200212220251.gBM2p2Y14110@DOMAIN.HIDDEN">200212220251.gBM2p2Y14110@xxxxxxxxxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:3E077CA2.2040703@DOMAIN.HIDDEN">3E077CA2.2040703@xxxxxxxxxx</a>&gt; &lt;<a href="mailto:200212301429.gBUETMm28219@DOMAIN.HIDDEN">200212301429.gBUETMm28219@xxxxxxxxxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:3E1701FF.20100@DOMAIN.HIDDEN">3E1701FF.20100@xxxxxxxxxx</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>&gt; Marc Feeley wrote:
&gt; &gt;&gt;
&gt; &gt;&gt;This is unfortunate, since this SRFI really moves all that &quot;legacy&quot;
&gt; &gt;&gt;code into non-specifiedness...
&gt; &gt; 
&gt; &gt; 
&gt; &gt; Since SRFI 39 did not exist when the legacy code was written the code
&gt; &gt; never conformed to it.  So SRFI 39 does not &quot;move&quot; the code into
&gt; &gt; non-specifiedness.  The other choice (of having &quot;make-parameter&quot;
&gt; &gt; create the mutable parameters as specified in SRFI 39) is even less
&gt; &gt; appealing because in that case PLT legacy code would no longer work if
&gt; &gt; PLT adopted that semantics.
&gt; 
&gt; That is exactly the reason why I think having fully thread-local
&gt; parameters is the more practical solution. The &quot;legacy&quot; code I talk of
&gt; is the (perhaps not unconsiderable) amount of code written that uses
&gt; parameters that do not share their value among different threads
&gt; (as in PLT).

But a SRFI is (almost) always a compromise between compatibility with
existing systems and proposing the &quot;right&quot; semantics.  This SRFI is no
different.  The best way to be compatible with PLT is to take the
specification out of the PLT manual.  Of course that is probably not
going to be compatible with other systems...  What I am proposing is
compatible with existing systems (that implement parameters) and it
also specifies what I think is the &quot;right&quot; semantics for mutable
parameters in the presence of threads.

&gt; &gt;&gt;I think parameters (as used in Chez, PLT or (say) Chicken) are
&gt; &gt;&gt;(IMHO) well understood and heavily used.
&gt; &gt; 
&gt; &gt; 
&gt; &gt; For these systems and Gambit-C, &quot;make-mutable-parameter&quot; and
&gt; &gt; &quot;make-parameter&quot; can be defined as the native &quot;make-parameter&quot; when
&gt; &gt; multithreading is not used.  The semantic differences only matter with
&gt; &gt; PLT when threads are being used and the parameters are mutated (indeed
&gt; &gt; only PLT and Chicken implement threads and the Chicken manual does not
&gt; &gt; explain the interaction between parameters and threads).
&gt; 
&gt; [It does, albeit not explicitly enough (see the SRFI-18 section).
&gt; I will fix this.]
&gt; 
&gt; &gt; I view SRFI
&gt; &gt; 39's main contribution as a specification of how mutation of
&gt; &gt; parameters should work in the presence of threads.
&gt; 
&gt; Absolutely. But I think one should be more pragmatic here and
&gt; use parameters as user-defined *fully* thread-local storage,
&gt; dynamically scoped.

It is the &quot;fully&quot; that I don't like.  With the semantics I propose
a user can decide what is shared and what is not shared (i.e. fully
thread-local).  For example, if I want to create a thread that has
a fully thread-local binding for the parameter current-input-port
then you can simply say:

  (define (make-thread-with-local-input-port thunk)
    (let ((cip (current-input-port)))
      (make-thread
        (lambda ()
          (parameterize ((current-input-port cip))
            (thunk))))))

  (make-thread-with-local-input-port (lambda () ...))

Or if you want to be more general:

  (define (make-thread-with-local params thunk)
    (let ((cp (map (lambda (p) (p)) params)))
      (make-thread
        (lambda ()

          (define (bind params cp thunk)
            (if (null? params)
                (thunk)
                (parameterize (((car params) (car cp)))
                  (bind (cdr params) (cdr cp) thunk))))

          (bind params cp thunk)))))

  (make-thread-with-local
    (list current-input-port current-output-port)
    (lambda () ...))

This way the user can choose what is shared and not on a
per thread basis.

&gt; &gt; No &quot;copy-on-write&quot; is not a valid implementation.  The reason is that
&gt; &gt; the &quot;swapping&quot; semantics requires the child thread to have an
&gt; &gt; independent copy of the parent's thread.  So the child must get a
&gt; &gt; snapshot of the parent's dynamic environment which will make the
&gt; &gt; child's mutations invisible to the parent ***AND*** the parent's
&gt; &gt; mutations invisible to the child.  The copy-on-write approach you
&gt; &gt; suggest only makes the child's mutations invisible to the parent.
&gt; 
&gt; That's not true. I'm probably expressing myself not clearly enough.
&gt; `make-parameter' creates a parameter in a global environment (not attached)
&gt; to any thread. Thread-creation copies the parent's parameter-env,
&gt; *but* this env will be empty if the parent has not yet changed it's
&gt; parameter-env (i.e. it is equivalent to the global env).

But can the global env be mutated by the main thread?  In other words
if the main thread does (current-output-port stderr) and (parameterize
((current-output-port stderr)) ...) does it mutate the global env?  My
understanding was that it did (thus thread creation would have to copy
the global env to get a consistent &quot;snapshot&quot; of the dynamic
environment).  If the global env is immutable, then parameter-env
could be as big (or bigger depending on your implementation) as the
global env.  So scalability is an issue.

The &quot;swapping semantics&quot; hides a (potentially expensive) copying
operation from the user.  I prefer when expensive operations are
explicit so the user has some control over them.

&gt; I'm pretty sure that it works. I would be delighted to see some sample
&gt; code that demonstrates the problem.
&gt; 
&gt; &gt; 
&gt; &gt; When I say &quot;clean&quot; I don't mean it so subjectively.  A strong argument
&gt; &gt; can be made that the semantics I propose in SRFI 39 for dynamic
&gt; &gt; binding are closer to the lexical binding semantics.  What does this
&gt; &gt; mean?  Well, if you look at how environments are manipulated in the
&gt; &gt; denotational semantics (section 7.2 of R5RS) you will see that there
&gt; &gt; are only two operations on environments &quot;lookup&quot; and &quot;extends&quot;.
&gt; &gt; &quot;lookup&quot; returns the location in the store that is bound to an
&gt; &gt; identifier.  The value associated to a location in the store is
&gt; &gt; obtained with &quot;hold&quot; and &quot;assign&quot; changes the value associated with
&gt; &gt; the location.  Dynamic binding as I propose it uses exactly the same
&gt; &gt; operations (with the minor point that the domain of &quot;lookup&quot; and
&gt; &gt; &quot;extends&quot; must be changed to accept parameter objects).  In addition
&gt; &gt; to the lexical environment, the semantic functions also need an extra
&gt; &gt; environment: the dynamic environment.  The dynamic binding semantics
&gt; &gt; is simply obtained by having procedure call pass this dynamic
&gt; &gt; environment to the called procedure (and this is the only thing that
&gt; &gt; distinguished it from lexical binding).  Similarly (but obviously
&gt; &gt; outside the scope of R5RS), the creation of a new thread would capture
&gt; &gt; the dynamic environment of the parent thread.  That's it.  There is no
&gt; &gt; need for an additional semantic operation for copying dynamic
&gt; &gt; environments (which is non trivial because it must allocate store).
&gt; &gt; Dynamic binding is a simple and natural extension of the R5RS
&gt; 
&gt; Perfectly valid, but to repeat: I see parameters as a simple and effective device
&gt; for having thread-local storage, nothing more.

My proposal does not prevent thread-local storage.  See my previous comment.

&gt; I find the reasons you give insufficient for changing a well-established
&gt; construct like parameters. The performance argument is weak, incompatibility
&gt; to existing systems will make adoption of this SRFI harder and compatibility
&gt; to non-released software is unimportant. Additionally it puts unneccessary burden
&gt; on implementors and confuses users of implementations that have parameters and threads.

I don't believe it would confuse users... there are few users that
combine threads and parameters and mutation, and those that do can
easily understand the semantics I propose (or indeed they are perhaps
incorrectly assuming the semantics I propose which is simpler and more
in line with the R5RS semantics!).  I am not changing the semantics of
a well-established construct... if I was proposing that
&quot;make-parameter&quot; add a handler for a command-line option then I would
see your point...

&gt; (BTW, there is a simple way out of this dilemma: use different
&gt; names - `make-dynamic' and `let-dynamic' come to mind, for example...)

This is why I added &quot;make-mutable-parameter&quot;.  Once again:
make-parameter is compatible with existing systems that support
parameters, even those supporting threads.

Alternatively, someone (perhaps you?) could propose a SRFI giving a
different semantics for &quot;make-parameter&quot; and mutation in the presence
of threads.  I think my proposal is the &quot;right&quot; way, but I don't have
a monopoly on &quot;rightfulness&quot;!

Marc

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00016" href="msg00016.html">Re: Some comments</a></strong>
<ul><li><em>From:</em> felix</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00001" href="msg00001.html">Some comments</a></strong>
<ul><li><em>From:</em> felix</li></ul></li>
<li><strong><a name="00003" href="msg00003.html">Re: Some comments</a></strong>
<ul><li><em>From:</em> Marc Feeley</li></ul></li>
<li><strong><a name="00008" href="msg00008.html">Re: Some comments</a></strong>
<ul><li><em>From:</em> felix</li></ul></li>
<li><strong><a name="00009" href="msg00009.html">Re: Some comments</a></strong>
<ul><li><em>From:</em> Marc Feeley</li></ul></li>
<li><strong><a name="00013" href="msg00013.html">Re: Some comments</a></strong>
<ul><li><em>From:</em> felix</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00014.html">Re: Some comments</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00016.html">Re: Some comments</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00013.html">Re: Some comments</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00016.html">Re: Some comments</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00015"><strong>Date</strong></a></li>
<li><a href="threads.html#00015"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
