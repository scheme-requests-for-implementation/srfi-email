<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: Format strings are wrong -->
<!--X-From-R13: Fnlybe Qnzcoryy <pnzcoryyNriqri.ngu.pk> -->
<!--X-Date: Sun, 28 Dec 2003 22:24:11 +0100 (NFT) -->
<!--X-Message-Id: 27BAA5B1&#45;397C&#45;11D8&#45;8C98&#45;000A95CCCEE4@evdev.ath.cx -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: y9lekur77gi.fsf@informatik.uni&#45;tuebingen.de -->
<!--X-Reference: 20031228043744.GA30222@synthcode.com -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: Format strings are wrong</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00037.html">Date Prev</a>][<a href="msg00039.html">Date Next</a>][<a href="msg00044.html">Thread Prev</a>][<a href="msg00039.html">Thread Next</a>][<a href="maillist.html#00038">Date Index</a>][<a href="threads.html#00038">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: Format strings are wrong</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: <a href="mailto:srfi-48@DOMAIN.HIDDEN">srfi-48@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Subject</em>: Re: Format strings are wrong</li>
<li><em>From</em>: Taylor Campbell &lt;<a href="mailto:campbell@DOMAIN.HIDDEN">campbell@xxxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Sun, 28 Dec 2003 16:24:01 -0500</li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-48@DOMAIN.HIDDEN">srfi-48@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:20031228043744.GA30222@DOMAIN.HIDDEN">20031228043744.GA30222@xxxxxxxxxxxxx</a>&gt;</li>
<li><em>References</em>: &lt;<a href="mailto:y9lekur77gi.fsf@DOMAIN.HIDDEN">y9lekur77gi.fsf@xxxxxxxxxxxxxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20031228043744.GA30222@DOMAIN.HIDDEN">20031228043744.GA30222@xxxxxxxxxxxxx</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre style="margin: 0em;">

On Dec 27, 2003, at 11:37 PM, Alex Shinn wrote:

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
The SRFI process isn't just about porting, but also standardizing
libraries.  One of the primary motivations of SRFI-1 was that all
Schemes provided varying levels of add-on list utilities with
incompatible API's.
</pre></blockquote><pre style="margin: 0em;">

</pre><tt>It's also about getting together and producing something _better_ than 
</tt><tt>what J.
</tt><tt>Random Schemer or Common Lisper thought up a while ago.  Remember 
</tt><tt>FLUID-LET? --
</tt><tt>there was once a SRFI about it, but it was ditched because there were 
</tt><tt>several
</tt><tt>arguments about why it was a bad idea, and better ideas.  (Actually, I 
</tt><tt>disagree
</tt><tt>with the design of SRFI 39 (parameters), too, which could be considered 
</tt><tt>to be
</tt><tt>one of those better ideas, but that's a different story and not really 
</tt><tt>relevant
</tt><tt>here.)  Likewise, if there are good arguments against format strings, 
</tt><tt>and there
</tt><tt>are good alternative ideas, why should you let yourself be held down by 
</tt><tt>the old
</tt><tt>and historically motivated idea?  I don't claim that LAMBDA: The 
</tt><tt>Ultimate
</tt><tt>Formatter is necessarily the best idea -- just as I don't think SRFI 39 
</tt><tt>is the
</tt><tt>best idea in the related set of ideas regarding fluid variables --, but 
</tt><tt>I think
</tt><pre style="margin: 0em;">
it's a better idea nevertheless.

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
  In this case almost all Schemes at least support
SRFI-28, and many support some or all of the full Common-Lisp format,
so it is definitely something people find useful and should be
standardized.  Many people feel SRFI-48 doesn't go far enough, so
there will likely be at least one more format SRFI.  Perhaps that will
explicitly make the individual formatting procedures accessible as
they are in Dirk Lutzebaeck's implementation, which would give you the
option of using both styles.
</pre></blockquote><pre style="margin: 0em;">

</pre><tt>Of course, and FLUID-LET is easily implemented and available in lots of 
</tt><tt>places.
</tt><tt>But that does not make it a _good_ thing.  Likewise, formatting strings 
</tt><tt>are
</tt><tt>easily implemented and available in lots of places; indeed, there are 
</tt><tt>portable
</tt><tt>implementations for full Common Lisp FORMAT.  But CL FORMAT isn't 
</tt><tt>necessarily
</tt><pre style="margin: 0em;">
a good thing.

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
Possibly something along the lines of simply adopting the notion that:
</pre><tt>(str-fmt ....) [or (string ...) be extended] to accept mixed string, 
</tt><tt>symbol,
</tt><tt>character and numerical arguments, and produces a string resulting 
</tt><tt>from the
</tt><pre style="margin: 0em;">
concatenation of its argument's string equivalences
</pre></blockquote><pre style="margin: 0em;">

Probably best not to overload string, especially in light of recent
discussions as to just what a character is.  Also, the procedure
should definitely output to a port, not a string.  But even using a
port this becomes inefficient if you inline write's:

  (define (write-to-string x) (with-output-to-string (cut write x)))
  (fmt #t &quot;list: &quot; (write-to-string ls) #\newline)

and likewise for performing different number-&gt;string conversions in
the middle of a format.
</pre></blockquote><pre style="margin: 0em;">

</pre><tt>Formatter procedures can work any way you like; all you need is to pass 
</tt><tt>some
</tt><tt>different WRITE-CHAR procedure, which allows for even more 
</tt><tt>expressiveness.  For
</tt><tt>instance, you could use SHIFT &amp; RESET to generate a stream from 
</tt><tt>FORMATTER:
</tt><pre style="margin: 0em;">

  (reset
    (format FORMATTER
      (lambda (char) (shift k (stream-cons char (k)))))
    stream-null)

</pre><tt>(Assuming the continuations that SHIFT lets you nab are n-ary.  It may 
</tt><tt>also be
</tt><pre style="margin: 0em;">
better to use BSHIFT &amp; BRESET, but that's diverging from this SRFI.)

</pre><tt>This doesn't force you to cons up intermediate strings or even 
</tt><tt>intermediate
</tt><tt>output ports with a specialized character writer.  (One might debate 
</tt><tt>about the
</tt><tt>efficiency of SHIFT &amp; RESET, which I don't want to right now, as it's 
</tt><tt>utterly
</tt><pre style="margin: 0em;">
beside the point.)

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
                         You really have to break it apart as:

  (display &quot;list: &quot;)
  (write ls)
  (newline)

which when compared with

  (format #t &quot;list: ~S\n&quot; ls)

looks clumsy and verbose, especially when you have many of these
throughout a program almost tripling the number of lines, and
especially when you have to wrap them in begins.  Format is very
concise
</pre></blockquote><pre style="margin: 0em;">

</pre><tt>If we cared that much about conciseness, we'd all be using Perl or GOO. 
</tt><tt> But we
</tt><pre style="margin: 0em;">
don't care _that_ much.

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
        and not only lets you re-use the format string in parts of
your program, it lets you easily change it at runtime
</pre></blockquote><pre style="margin: 0em;">

The same can be said about formatter procedures.

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
                                                      (even in an
eval-less Scheme) and lets you load it from things like config files.
</pre></blockquote><pre style="margin: 0em;">

</pre><tt>But what you're really doing there is just creating a very limited 
</tt><tt>language for
</tt><tt>formatting; it's equivalent to having a very limited EVAL.  Why not use 
</tt><tt>EVAL?
</tt><tt>You could even write an incredibly simple EVAL that supports only 
</tt><tt>LAMBDA,
</tt><pre style="margin: 0em;">
function application, and the built-in formatters.

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
Consider the log files of a server that need to produce customizable
output, like this from my httpd.conf:

</pre><tt>LogFormat &quot;%h %l %u %t \&quot;%r\&quot; %&gt;s %b \&quot;%{Referer}i\&quot; 
</tt><tt>\&quot;%{User-Agent}i\&quot; %T %v&quot; full
</tt><pre style="margin: 0em;">

Or consider the Emacs mode-line-format string which lets you customize
(again at runtime) what appears in your mode-line.  Of course, Emacs
allows nested lists as the format, which may be a consideration for
future format SRFIs rather than consider introducing artificial
nesting with ~&lt;...~&gt; etc.
</pre></blockquote><pre style="margin: 0em;">

Formatter procedures can easily be arbitrarily nested however you like.

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
By keeping the logic in one place format is also much better suited to
things like i18n, and can provide more efficient control over
columnating and padding.
</pre></blockquote><pre style="margin: 0em;">

</pre><tt>And you don't need to remember obscure formatting directive syntax with 
</tt><tt>obscure
</tt><tt>single-character main names and strange syntax to go around it (SRFI 
</tt><tt>29's ~@*,
</tt><tt>anyone?).  Column &amp; padding control are especially easy when you've got 
</tt><tt>full
</tt><tt>Scheme at your fingertips with which to write formatting routines.  It 
</tt><tt>would be
</tt><tt>trivial to write a FORMAT/PADDING routine that would keep track of the 
</tt><tt>columns
</tt><pre style="margin: 0em;">
that the sub-formatters write.

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><tt>All around, format is more consice [sic], more efficient, and more 
</tt><tt>flexible
</tt><pre style="margin: 0em;">
than the alternatives.  That doesn't mean we couldn't use some more
functional interfaces, but they will likely not replace format.
</pre></blockquote><pre style="margin: 0em;">

</pre><tt>Concise [sic], I concede; but do you really want _that_ much 
</tt><tt>conciseness?  I'd
</tt><tt>say no, or, as I said, we'd all be using Perl or GOO.  (OK, that's a 
</tt><tt>bit of an
</tt><pre style="margin: 0em;">
overstatement, but you get the idea.)

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
--
Alex

</pre></blockquote><pre style="margin: 0em;">

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00039" href="msg00039.html">what is scheme's formal refinement/extension philosophy? (Re:	Format strings are wrong)</a></strong>
<ul><li><em>From:</em> Paul Schlie</li></ul></li>
<li><strong><a name="00041" href="msg00041.html">Re: Format strings are wrong</a></strong>
<ul><li><em>From:</em> Alex Shinn</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00031" href="msg00031.html">Re: Format strings are wrong</a></strong>
<ul><li><em>From:</em> Paul Schlie</li></ul></li>
<li><strong><a name="00035" href="msg00035.html">Re: Format strings are wrong</a></strong>
<ul><li><em>From:</em> Alex Shinn</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00037.html">Re: Format strings are wrong</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00039.html">what is scheme's formal refinement/extension philosophy? (Re:	Format strings are wrong)</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00044.html">Re: LAMBDA: The Ultimate Formatter (was Re: Format strings are wrong)</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00039.html">what is scheme's formal refinement/extension philosophy? (Re:	Format strings are wrong)</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00038"><strong>Date</strong></a></li>
<li><a href="threads.html#00038"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
