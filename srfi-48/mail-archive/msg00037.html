<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: Format strings are wrong -->
<!--X-From-R13: Bnhy Epuyvr <fpuyvrNpbzpnfg.arg> -->
<!--X-Date: Sun, 28 Dec 2003 20:24:18 +0100 (NFT) -->
<!--X-Message-Id: BC149809.9C67%schlie@comcast.net -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: BC149519.9C62%schlie@comcast.net -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: Format strings are wrong</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00036.html">Date Prev</a>][<a href="msg00038.html">Date Next</a>][<a href="msg00034.html">Thread Prev</a>][<a href="msg00042.html">Thread Next</a>][<a href="maillist.html#00037">Date Index</a>][<a href="threads.html#00037">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: Format strings are wrong</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: &lt;<a href="mailto:srfi-48@DOMAIN.HIDDEN">srfi-48@xxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Subject</em>: Re: Format strings are wrong</li>
<li><em>From</em>: Paul Schlie &lt;<a href="mailto:schlie@DOMAIN.HIDDEN">schlie@xxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Sun, 28 Dec 2003 14:24:09 -0500</li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-48@DOMAIN.HIDDEN">srfi-48@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:BC149519.9C62%25schlie@DOMAIN.HIDDEN">BC149519.9C62%schlie@xxxxxxxxxxx</a>&gt;</li>
<li><em>User-agent</em>: Microsoft-Entourage/10.1.4.030702.0</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>Alex Shinn wrote:
&gt; The SRFI process isn't just about porting, but also standardizing
&gt; libraries....In this case almost all Schemes at least support
&gt; SRFI-28, and many support some or all of the full Common-Lisp format,
&gt; so it is definitely something people find useful and should be
&gt; standardized.  Many people feel SRFI-48 doesn't go far enough, so
&gt; there will likely be at least one more format SRFI.  Perhaps that will
&gt; explicitly make the individual formatting procedures accessible as
&gt; they are in Dirk Lutzebaeck's implementation, which would give you the
&gt; option of using both styles.

I appreciate that the SRFI process enables the definition of proposed
language/library features by providing a forum for such proposals; some
of which may be adopted, discarded, and/or refined through time for
incorporation into recommended practice.

I just simply believe that although a language/library-collection may enable
a particular capability through a variety of approaches, the approach which
should be recommended/adopted should strictly as reasonably possible follow
the philosophy of the language itself in a unifying manor; where by so
doing, multiplicatively extends it's expressive power. Which is basically
why I tend to believe that rather than simply attempting to &quot;standardize&quot;
potentially poor practices simply because they may exist in some form, it
may be better to reformulate unified solutions where possible based the
principles and philosophy of the core language itself for the fore
mentioned reasons.

&gt;&gt; Possibly something along the lines of simply adopting the notion that:
&gt;&gt; (philosophy ....) [or (string ...) be extended] to accept mixed string,
&gt;&gt; symbol, character and numerical arguments, and produces a string resulting
&gt;&gt; from the concatenation of its argument's string equivalences
&gt;
&gt; Probably best not to overload string, especially in light of recent
&gt; discussions as to just what a character is.  Also, the procedure
&gt; should definitely output to a port, not a string.  But even using a
&gt; port this becomes inefficient if you inline write's:
&gt; 
&gt;   (define (write-to-string x) (with-output-to-string (cut write x)))
&gt;   (fmt #t &quot;list: &quot; (write-to-string ls) #\newline)
&gt; 
&gt; and likewise for performing different number-&gt;string conversions in
&gt; the middle of a format.  You really have to break it apart as:
&gt; 
&gt;   (display &quot;list: &quot;)
&gt;   (write ls)
&gt;   (newline)
&gt; 
&gt; which when compared with
&gt; 
&gt;   (format #t &quot;list: ~S\n&quot; ls)
&gt; 
&gt; looks clumsy and verbose, ... All around, format is more consice...

Huh? 

(display (string &quot;list: &quot; ls #\newline) to-what-ever-port-you-like)

Free form linguistic text processing is likely beyond the scope, as both
of these approaches simply deal with the handling of text within the
character set defined for the scheme language itself.

(Personally I see no reason not to consider advocating simply backward
 compatibly extending (string ...) rather than advocating &quot;standardization&quot;
 of a function with limited additional utility which is arguably
 inconsistent with the language's philosophy; but that of course is the
 benefit that the SRFI process/forum provides us all.)

-paul-

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00042" href="msg00042.html">Re: Format strings are wrong</a></strong>
<ul><li><em>From:</em> Alex Shinn</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00036.html">LAMBDA: The Ultimate Formatter (was Re: Format strings are wrong)</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00038.html">Re: Format strings are wrong</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00034.html">Re: Format strings are wrong</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00042.html">Re: Format strings are wrong</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00037"><strong>Date</strong></a></li>
<li><a href="threads.html#00037"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
