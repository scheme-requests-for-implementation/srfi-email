<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: SRFI&#45;27 -->
<!--X-From-R13: fronfgvna.rtareNcuvyvcf.pbz -->
<!--X-Date: Thu, 22 Aug 2002 08:16:24 +0200 (DFT) -->
<!--X-Message-Id: OFA5E8E0C6.5D67F699&#45;ONC1256C1D.00215F8B@diamond.philips.com -->
<!--X-Content-Type: multipart/alternative -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: SRFI-27</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00033.html">Date Prev</a>][Date Next][<a href="msg00033.html">Thread Prev</a>][Thread Next][<a href="maillist.html#00034">Date Index</a>][<a href="threads.html#00034">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: SRFI-27</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-27">SRFI 27</a> from before July 7th, 2015.  The new archives for SRFI 27 are <a href="http://srfi-email.schemers.org/srfi-27/">here</a>.  The new archives contain all messages, not just those from before July 7th, 2015.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: Sven Hartrumpf &lt;<a href="mailto:Sven.Hartrumpf@DOMAIN.HIDDEN">Sven.Hartrumpf@xxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Subject</em>: Re: SRFI-27</li>
<li><em>From</em>: <a href="mailto:sebastian.egner@DOMAIN.HIDDEN">sebastian.egner@xxxxxxxxxxx</a></li>
<li><em>Date</em>: Thu, 22 Aug 2002 08:13:51 +0200</li>
<li><em>Cc</em>: <a href="mailto:srfi-27@DOMAIN.HIDDEN">srfi-27@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-27@DOMAIN.HIDDEN">srfi-27@xxxxxxxxxxxxxxxxx</a></li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->

<br><font size=2 face="sans-serif">Hi Sven,</font>
<br>
<br><font size=2 face="sans-serif">Thanks for pointing out the typos. I will check with the editors if how </font>
<br><font size=2 face="sans-serif">the corrections can be published.</font>
<br>
<br><font size=2 face="sans-serif">It is possible to have a Scheme-only implementation with only 30 bit</font>
<br><font size=2 face="sans-serif">integers---the only thing to do is to implement one's own 56-bit arithmetics</font>
<br><font size=2 face="sans-serif">on pairs of 30 bit integers. Presumably, this implementation will be</font>
<br><font size=2 face="sans-serif">very slow, probably to an extent which is annoying in practice.</font>
<br><font size=2 face="sans-serif">Moreover, there is not much from it to be learned for implementors. </font>
<br><font size=2 face="sans-serif">Therefore I have chosen not to provide any such implementation</font>
<br><font size=2 face="sans-serif">and hope that a Bigloo expert eventually implements the SRFI in</font>
<br><font size=2 face="sans-serif">a meaningful way.</font>
<br>
<br><font size=2 face="sans-serif">Cheers,</font>
<br>
<br><font size=2 face="sans-serif">Sebastian.</font>
<br>
<br><font size=2 face="sans-serif">----<br>
Dr. Sebastian Egner<br>
Senior Scientist<br>
Philips Research Laboratories<br>
Prof. Holstlaan 4 (WY2)<br>
5656 AA Eindhoven<br>
The Netherlands<br>
tel: &nbsp; &nbsp; &nbsp; +31 40 27-43309<br>
fax: &nbsp; &nbsp; &nbsp;+31 40 27-44918<br>
email: sebastian.egner@xxxxxxxxxxx</font>
<br>
<br>
<br>
<table width=100%>
<tr valign=top>
<td>
<td><font size=1 face="sans-serif"><b>Sven Hartrumpf &lt;Sven.Hartrumpf@xxxxxxxxxxxxxxxx&gt;</b></font>
<p><font size=1 face="sans-serif">08/21/02 18:01</font>
<br>
<td><font size=1 face="Arial">&nbsp; &nbsp; &nbsp; &nbsp; </font>
<br><font size=1 face="sans-serif">&nbsp; &nbsp; &nbsp; &nbsp; To: &nbsp; &nbsp; &nbsp; &nbsp;Sebastian Egner/EHV/RESEARCH/PHILIPS@EMEA3</font>
<br><font size=1 face="sans-serif">&nbsp; &nbsp; &nbsp; &nbsp; cc: &nbsp; &nbsp; &nbsp; &nbsp;</font>
<br><font size=1 face="sans-serif">&nbsp; &nbsp; &nbsp; &nbsp; Subject: &nbsp; &nbsp; &nbsp; &nbsp;SRFI-27</font>
<p><font size=1 face="sans-serif">&nbsp; &nbsp; &nbsp; &nbsp; Classification: &nbsp; &nbsp; &nbsp; &nbsp;</font>
<br></table>
<br>
<br>
<br><font size=2 face="Courier New">Hi Sebastian.<br>
Thanks for this nice SRFI!<br>
Unfortunately, I missed the discussion phase. So, here are just some minor<br>
comments.<br>
<br>
reference implementation mentions mrg32k3a-b.scm (2 times). Should be mrg32k3a-b.c.<br>
<br>
attached: some typos in srfi-27.html<br>
<br>
finally, is it possible to get a useful Scheme-only implementation of mrg32k3a with<br>
only 30-bit integers? (bigloo)<br>
<br>
Greetings<br>
Sven<br>
<br>
-----<br>
<br>
&lt;!-- X-URL: http://srfi.schemers.org/srfi-27/srfi-27.html --&gt;<br>
&lt;!-- Date: Tue, 20 Aug 2002 13:53:06 GMT --&gt;<br>
&lt;BASE HREF="">
<br>
&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML//EN&quot;&gt;<br>
&lt;html&gt;<br>
 &nbsp;&lt;head&gt;<br>
 &nbsp; &nbsp;&lt;title&gt;SRFI 27: Sources of Random Bits&lt;/title&gt;<br>
 &nbsp;&lt;/head&gt;<br>
<br>
 &nbsp;&lt;body&gt;<br>
<br>
&lt;H1&gt;Title&lt;/H1&gt;<br>
<br>
Sources of Random Bits<br>
<br>
&lt;H1&gt;Author&lt;/H1&gt;<br>
<br>
Sebastian Egner<br>
<br>
&lt;H1&gt;Status&lt;/H1&gt;<br>
<br>
This SRFI is currently in ``final'' status. To see an explanation of<br>
each status that a SRFI can hold, see &lt;a<br>
href="" &nbsp;<br>
You can access<br>
previous messages via<br>
&lt;a href="">
the archive of the mailing list&lt;/a&gt;.<br>
<br>
&lt;UL&gt;<br>
&lt;LI&gt;Draft: 2002/02/12-2002/04/12&lt;/LI&gt;<br>
&lt;LI&gt;Revised: 2002/04/04<br>
&lt;LI&gt;Revised: 2002/04/10<br>
&lt;LI&gt;Revised: 2002/04/10<br>
&lt;LI&gt;Final: 2002/06/03<br>
&lt;/UL&gt;<br>
<br>
&lt;H1&gt;Abstract&lt;/H1&gt;<br>
<br>
This document specifies an interface to sources of random bits,<br>
or &quot;random sources&quot; for brevity.<br>
In particular, there are three different ways to use the interface,<br>
with varying demands on the quality of the source and the<br>
amount of control over the production process:<br>
<br>
&lt;UL&gt;<br>
&lt;LI&gt;<br>
The &quot;no fuss&quot; interface specifies that <br>
&lt;code&gt;(random-integer &lt;/code&gt;&lt;I&gt;n&lt;/I&gt;&lt;code&gt;)&lt;/code&gt;<br>
produces the next random integer in {0, ..., &lt;I&gt;n&lt;/I&gt;-1} and<br>
&lt;code&gt;(random-real)&lt;/code&gt; produces the next random<br>
real number between zero and one.<br>
The details of how these random values are produced may not be<br>
very relevant, as long as they appear to be sufficiently random.<br>
&lt;LI&gt;<br>
For simulation purposes, on the contrary, it is usually necessary<br>
to know that the numbers are produced deterministically by a pseudo <br>
random number generator of high quality and to have explicit access <br>
to its state.<br>
In addition, one might want to use several independent sources of<br>
random numbers at the same time and it can be useful to have some<br>
simple form of randomization.<br>
&lt;LI&gt;<br>
For security applications a serious form of true randomization<br>
is essential, in the sense that it is difficult for an adversary to <br>
exploit or introduce imperfections into the distribution of random bits.<br>
Moreover, the linear complexity of the stream of random bits is more <br>
important than its statistical properties.<br>
In these applications, an entropy source (producing truly random<br>
bits at a low rate) is used to randomize a pseudo random number<br>
generator to increase the rate of available bits.<br>
&lt;/UL&gt;<br>
&lt;p&gt;<br>
<br>
Once random sources provide the infrastructure to obtain <br>
random bits, these can be used to construct other random deviates.<br>
Most important are floating point numbers of various distributions<br>
and random discrete structures, such as permutations or graphs.<br>
As there is an essentially unlimited number of such objects (with <br>
limited use elsewhere), we do not include them in this SRFI.<br>
In other words, this SRFI is &lt;em&gt;not&lt;/em&gt; about making<br>
all sorts of random objects---it is about obtaining random<br>
bits in a portable, flexible, reliable, and efficient way.<br>
<br>
&lt;H1&gt;Rationale&lt;/H1&gt;<br>
<br>
This SRFI defines an interface for sources of random bits <br>
computed by a pseudo random number generator.<br>
The interface provides range-limited integer and real numbers.<br>
It allows accessing the state of the underlying generator.</font>
<br><font size=2 face="Courier New">Moreover, it is possible to obtain a large number of <br>
independent generators and to invoke a mild form of true<br>
randomization.&lt;p&gt;<br>
<br>
The design aims at sufficient flexibility to cover the<br>
usage patterns of many applications as diverse as<br>
discrete structures, numerical simulations, and cryptographic protocols.<br>
At the same time, the interface aims at simplicity,<br>
which is important for occasional use.<br>
As there is no &quot;one size fits all&quot; random number generator,<br>
the design necessarily represents some form of compromise<br>
between the needs of the various applications.&lt;p&gt;<br>
<br>
Although strictly speaking not part of the specification,<br>
the emphasis of this proposal is on &lt;em&gt;high quality&lt;/em&gt;<br>
random numbers and on &lt;em&gt;high performance&lt;/em&gt;.<br>
As the state of the art in pseudo random number generators<br>
is still advancing considerably, the choice of method for<br>
the reference implementation should essentially be <br>
considered preliminary.<br>
<br>
&lt;H1&gt;Specification&lt;/H1&gt;<br>
<br>
&lt;DL&gt;<br>
<br>
&lt;DT&gt;<br>
&lt;code&gt;(random-integer &lt;/code&gt;&lt;I&gt;n&lt;/I&gt;&lt;code&gt;) -&gt; &lt;/code&gt;&lt;I&gt;x&lt;/I&gt;&lt;code&gt;&lt;/code&gt;<br>
&lt;/DT&gt;<br>
<br>
&lt;DD&gt;<br>
The next integer &lt;I&gt;x&lt;/I&gt; in {0, ..., &lt;I&gt;n&lt;/I&gt;-1} <br>
obtained from &lt;code&gt;default-random-source&lt;/code&gt;.<br>
Subsequent results of this procedure appear to be independent<br>
uniformly distributed over the range {0, ..., &lt;I&gt;n&lt;/I&gt;-1}.<br>
The argument &lt;I&gt;n&lt;/I&gt; must be a positive integer,<br>
otherwise an error is signalled.<br>
&lt;/DD&gt;<br>
<br>
&lt;/DL&gt;<br>
<br>
&lt;DL&gt;<br>
<br>
&lt;DT&gt;<br>
&lt;code&gt;(random-real) -&gt; &lt;/code&gt;&lt;I&gt;x&lt;/I&gt;&lt;code&gt;&lt;/code&gt;<br>
&lt;/DT&gt;<br>
<br>
&lt;DD&gt;<br>
The next number 0 &lt; &lt;I&gt;x&lt;/I&gt; &lt; 1 obtained from<br>
&lt;code&gt;default-random-source&lt;/code&gt;.<br>
Subsequent results of this procedure appear to be <br>
independent uniformly distributed.<br>
The numerical type of the results and the <br>
quantization of the output range depend on the implementation;<br>
refer to &lt;code&gt;random-source-make-reals&lt;/code&gt; for details.<br>
&lt;/DD&gt;<br>
<br>
&lt;/DL&gt;<br>
<br>
&lt;DL&gt;<br>
<br>
&lt;DT&gt;<br>
&lt;code&gt;default-random-source&lt;/code&gt;<br>
&lt;/DT&gt;<br>
<br>
&lt;DD&gt;<br>
A random source from which &lt;code&gt;random-integer&lt;/code&gt; and <br>
&lt;code&gt;random-real&lt;/code&gt; have been derived using<br>
&lt;code&gt;random-source-make-integers&lt;/code&gt; and<br>
&lt;code&gt;random-source-make-reals&lt;/code&gt;.<br>
Note that an assignment to &lt;code&gt;default-random-source&lt;/code&gt; <br>
does not change &lt;code&gt;random&lt;/code&gt; or &lt;code&gt;random-real&lt;/code&gt;;<br>
it is also strongly recommended not to assign a new value.<br>
&lt;/DD&gt;<br>
<br>
&lt;/DL&gt;<br>
&lt;HR ALIGN=left WIDTH=&quot;10%&quot;&gt;<br>
&lt;DL&gt;<br>
<br>
&lt;DT&gt;<br>
&lt;code&gt;(make-random-source) -&gt; &lt;/code&gt;&lt;I&gt;s&lt;/I&gt;&lt;code&gt;&lt;/code&gt;<br>
&lt;/DT&gt;<br>
<br>
&lt;DD&gt;<br>
Creates a new random source &lt;I&gt;s&lt;/I&gt;.<br>
Implementations may accept additional, optional arguments in <br>
order to create different types of random sources.<br>
A random source created with &lt;code&gt;make-random-source&lt;/code&gt;<br>
represents a deterministic stream of random bits generated<br>
by some form of pseudo random number generator.<br>
Each random source obtained as &lt;code&gt;(make-random-source)&lt;/code&gt;<br>
generates the same stream of values, unless the state is modified<br>
with one of the procedures below.<br>
&lt;/DD&gt;<br>
<br>
&lt;/DL&gt;<br>
<br>
&lt;DL&gt;<br>
<br>
&lt;DT&gt;<br>
&lt;code&gt;(random-source? &lt;/code&gt;&lt;I&gt;obj&lt;/I&gt;&lt;code&gt;) &nbsp;-&gt; &nbsp;&lt;/code&gt;&lt;I&gt;bool&lt;/I&gt;&lt;code&gt;&lt;/code&gt;<br>
&lt;/DT&gt;<br>
<br>
&lt;DD&gt;<br>
Tests if &lt;I&gt;obj&lt;/I&gt; is a random source.<br>
Objects of type random source are distinct from all<br>
other types of objects.<br>
&lt;/DD&gt;<br>
<br>
&lt;/DL&gt;<br>
<br>
&lt;DL&gt;<br>
<br>
&lt;DT&gt;<br>
&lt;code&gt;(random-source-state-ref &lt;/code&gt;&lt;I&gt;s&lt;/I&gt;&lt;code&gt;) &nbsp;-&gt; &nbsp;&lt;/code&gt;&lt;I&gt;state&lt;/I&gt;&lt;code&gt;&lt;/code&gt;&lt;br&gt;<br>
&lt;code&gt;(random-source-state-set! &lt;/code&gt;&lt;I&gt;s&lt;/I&gt;&lt;code&gt; &lt;/code&gt;&lt;I&gt;state&lt;/I&gt;&lt;code&gt;)&lt;/code&gt;<br>
&lt;/DT&gt;<br>
<br>
&lt;DD&gt;<br>
Get and set the current state of a random source &lt;I&gt;s&lt;/I&gt;. &nbsp;The<br>
structure of the object &lt;I&gt;state&lt;/I&gt; depends on the implementation;<br>
the only portable use of it is as argument to <br>
&lt;code&gt;random-source-state-set!&lt;/code&gt;.<br>
It is, however, required that a state possess an external<br>
representation.<br>
&lt;/DD&gt;<br>
<br>
&lt;/DL&gt;<br>
<br>
&lt;DL&gt;<br>
&lt;DT&gt;<br>
&lt;code&gt;(random-source-randomize! &lt;/code&gt;&lt;I&gt;s&lt;/I&gt;&lt;code&gt;)&lt;/code&gt;<br>
&lt;/DT&gt;<br>
<br>
&lt;DD&gt;<br>
Makes an effort to set the state of the random <br>
source &lt;I&gt;s&lt;/I&gt; to a truly random state.<br>
The actual quality of this randomization depends on the implementation<br>
but it can at least be assumed that the procedure sets &lt;I&gt;s&lt;/I&gt; to a <br>
different state for each subsequent run of the Scheme system.<br>
&lt;/DD&gt;<br>
&lt;/DL&gt;<br>
<br>
&lt;DL&gt;<br>
&lt;DT&gt;<br>
&lt;code&gt;(random-source-pseudo-randomize! &lt;/code&gt;&lt;I&gt;s&lt;/I&gt;&lt;code&gt; &lt;I&gt;i&lt;/I&gt; &lt;I&gt;j&lt;/I&gt;)&lt;/code&gt;<br>
&lt;/DT&gt;<br>
<br>
&lt;DD&gt;<br>
Changes the state of the random source &lt;I&gt;s&lt;/I&gt; into the initial<br>
state of the (&lt;I&gt;i&lt;/I&gt;, &lt;I&gt;j&lt;/I&gt;)-th independent random source,<br>
where &lt;I&gt;i&lt;/I&gt; and &lt;I&gt;j&lt;/I&gt; are non-negative integers.<br>
This procedure provides a mechanism to obtain a large number of <br>
independent random sources (usually all derived from the same backbone<br>
generator), indexed by two integers.<br>
In contrast to &lt;code&gt;random-source-randomize!&lt;/code&gt;,<br>
this procedure is entirely deterministic.<br>
&lt;/DD&gt;<br>
&lt;/DL&gt;<br>
<br>
<br>
&lt;HR ALIGN=left WIDTH=&quot;10%&quot;&gt;<br>
<br>
&lt;DL&gt;<br>
<br>
&lt;DT&gt;<br>
&lt;code&gt;(random-source-make-integers &lt;/code&gt;&lt;I&gt;s&lt;/I&gt;&lt;code&gt;) &nbsp;-&gt; &nbsp;&lt;/code&gt;&lt;I&gt;rand&lt;/I&gt;&lt;code&gt;&lt;/code&gt;<br>
&lt;/DT&gt;<br>
<br>
&lt;DD&gt;<br>
Obtains a procedure &lt;I&gt;rand&lt;/I&gt; to generate random integers <br>
using the random source &lt;I&gt;s&lt;/I&gt;.<br>
&lt;I&gt;Rand&lt;/I&gt; takes a single argument &lt;I&gt;n&lt;/I&gt;,<br>
which must be a positive integer, and returns the next uniformly<br>
distributed random integer from the interval {0, ..., &lt;I&gt;n&lt;/I&gt;-1}<br>
by advancing the state of the source &lt;I&gt;s&lt;/I&gt;.&lt;p&gt;<br>
<br>
If an application obtains and uses several generators for the same <br>
random source &lt;I&gt;s&lt;/I&gt;, a call to any of these generators advances <br>
the state of &lt;I&gt;s&lt;/I&gt;. Hence, the generators &lt;em&gt;do not&lt;/em&gt; produce <br>
the same sequence of random integers each but rather share a state.<br>
This also holds for all other types of generators derived from<br>
a fixed random sources.<br>
Implementations that support concurrency make sure that<br>
the state of a generator is properly advanced.&lt;p&gt;<br>
&lt;/DD&gt;<br>
<br>
&lt;/DL&gt;<br>
<br>
&lt;DL&gt;<br>
<br>
&lt;DT&gt;<br>
&lt;code&gt;(random-source-make-reals &lt;/code&gt;&lt;I&gt;s&lt;/I&gt;&lt;code&gt;) &nbsp;-&gt; &nbsp;&lt;/code&gt;&lt;I&gt;rand&lt;/I&gt;&lt;code&gt;&lt;/code&gt;&lt;br&gt;<br>
&lt;code&gt;(random-source-make-reals &lt;/code&gt;&lt;I&gt;s&lt;/I&gt;&lt;code&gt; &lt;/code&gt;&lt;I&gt;unit&lt;/I&gt;&lt;code&gt;) &nbsp;-&gt; &nbsp;&lt;/code&gt;&lt;I&gt;rand&lt;/I&gt;&lt;code&gt;&lt;/code&gt;&lt;br&gt;<br>
&lt;/DT&gt;<br>
<br>
&lt;DD&gt;<br>
Obtains a procedure &lt;I&gt;rand&lt;/I&gt; to generate random real numbers<br>
0 &lt; &lt;I&gt;x&lt;/I&gt; &lt; 1 using the random source &lt;I&gt;s&lt;/I&gt;.<br>
The procedure &lt;I&gt;rand&lt;/I&gt; is called without arguments.&lt;p&gt;<br>
<br>
The optional parameter &lt;I&gt;unit&lt;/I&gt; determines the type of numbers<br>
being produced by &lt;I&gt;rand&lt;/I&gt; and the quantization of the output.<br>
&lt;I&gt;Unit&lt;/I&gt; must be a number such that 0 &lt; &lt;I&gt;unit&lt;/I&gt; &lt; 1.<br>
The numbers created by &lt;I&gt;rand&lt;/I&gt; are of the same numerical<br>
type as &lt;I&gt;unit&lt;/I&gt; and the potential output values are<br>
spaced by at most &lt;I&gt;unit&lt;/I&gt;. One can imagine &lt;I&gt;rand&lt;/I&gt;<br>
to create numbers as &lt;I&gt;x&lt;/I&gt;*&lt;I&gt;unit&lt;/I&gt; where &lt;I&gt;x&lt;/I&gt;<br>
is a random integer in {1, ..., floor(1/&lt;I&gt;unit&lt;/I&gt;)-1}.<br>
Note, however, that this need not be the way the values<br>
are actually created and that the actual resolution of<br>
&lt;I&gt;rand&lt;/I&gt; can be much higher than &lt;I&gt;unit&lt;/I&gt;.<br>
In case &lt;I&gt;unit&lt;/I&gt; is absent it defaults to a reasonably<br>
small value (related to the width of the mantissa of an<br>
efficient number format).<br>
&lt;/DD&gt;<br>
<br>
&lt;/DL&gt;<br>
<br>
<br>
&lt;H1&gt;Design Rationale&lt;/H1&gt;<br>
<br>
&lt;H3&gt;Why not combine &lt;code&gt;random-integer&lt;/code&gt; and<br>
&lt;code&gt;random-real&lt;/code&gt;?&lt;/H3&gt;<br>
<br>
The two procedures are not combined into a single variable-arity <br>
procedures to save a little time and space during execution.<br>
Although some Scheme systems can deal with variable arity as<br>
efficiently as with fixed arity this is not always the case<br>
and time efficiency is very important here.<br>
<br>
&lt;H3&gt;Why not some object-oriented interface?&lt;/H3&gt;<br>
<br>
There are many alternatives to the interface as specified in this SRFI. <br>
In particular, every framework for object-orientation can be used to<br>
define a class for random sources and specify the interface for the<br>
methods on random sources.<br>
However, as the object-oriented frameworks differ considerably<br>
in terms of syntax and functionality, this SRFI does not make<br>
use of any particular framework.<br>
<br>
&lt;H3&gt;Why is there not just a generator with a fixed range?&lt;/H3&gt;<br>
<br>
A bare fixed-range generator is of very limited use.<br>
Nearly every application has to add some functionality </font>
<br><font size=2 face="Courier New">to make use of the random numbers.<br>
The most fundamental task in manipulating <br>
random numbers is to change the range and quantization.<br>
This is exactly what is provided by <br>
&lt;code&gt;random-integer&lt;/code&gt; and &lt;code&gt;random-real&lt;/code&gt;.<br>
In addition, is saves the user from the pitfall of changing<br>
the range with a simple &lt;code&gt;modulo&lt;/code&gt;-computation<br>
which may substantially reduce the quality of the<br>
numbers being produced.&lt;p&gt;<br>
<br>
The design of the interface is based on three prototype applications:<br>
&lt;OL&gt;<br>
&lt;LI&gt;<br>
Repeatedly choose from relatively small sets:<br>
As the size of the set is likely to vary from call to call,<br>
&lt;code&gt;random-integer&lt;/code&gt; accepts a range argument &lt;I&gt;n&lt;/I&gt; in every call.<br>
The implementation should try to avoid boxing/unboxing of values<br>
if the ranges fit into immediate integers.<br>
&lt;LI&gt;<br>
Generate a few large integers with a fixed number of bits:<br>
As generating the random number itself is expensive, <br>
passing the range argument in every call does not hurt performance.<br>
Hence, the same interface as in the first application can be used.<br>
&lt;LI&gt;<br>
Generate real numbers:<br>
Unlike the choose-from-set case, <br>
the range and the quantization is constant over a <br>
potentially very large number of calls.<br>
In addition, there are usually just a few distinct instances of<br>
quantization and number type, most likely corresponding to<br>
underlying &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; <br>
representations.<br>
Therefore,<br>
&lt;code&gt;random-real&lt;/code&gt; does not accept any parameters but<br>
the procedure &lt;code&gt;random-source-make-reals&lt;/code&gt; creates<br>
a properly configured &lt;code&gt;random-real&lt;/code&gt; procedure.<br>
&lt;/OL&gt;<br>
<br>
&lt;H3&gt;Why bother about floating point numbers at all?&lt;/H3&gt;<br>
<br>
A proper floating point implementation of a random number generator<br>
is potentially much more efficient that an integer implementation<br>
because it can use more powerful arithmetics hardware.<br>
If in addition the application needs floating point random numbers<br>
it would be an intolerable waste to run an integer generator to<br>
produce floating point random numbers.<br>
A secondary reason is to save the user from the 'not as easy as<br>
it seems' task of converting an integer generator into a real <br>
generator.<br>
<br>
&lt;H3&gt;Why are zero and one excluded from &lt;code&gt;random-real&lt;/code&gt;?&lt;/H3&gt;<br>
<br>
The procedure &lt;code&gt;random-real&lt;/code&gt; does not return <br>
&lt;I&gt;x&lt;/I&gt; = 0 or &lt;I&gt;x&lt;/I&gt; = 1 in order to allow <br>
&lt;code&gt;(log &lt;/code&gt;&lt;I&gt;x&lt;/I&gt;&lt;code&gt;)&lt;/code&gt; and <br>
&lt;code&gt;(log (- 1 &lt;/code&gt;&lt;I&gt;x&lt;/I&gt;)&lt;code&gt;)&lt;/code&gt;<br>
without the danger of a numerical exception.<br>
<br>
&lt;H1&gt;Implementation&lt;/H1&gt;<br>
<br>
&lt;H3&gt;Choice of generator&lt;/H3&gt;<br>
<br>
The most important decision about the implementation is <br>
the choice of the random number generator.<br>
The basic principle here is: &lt;em&gt;Let quality prevail!&lt;/em&gt;<br>
In the end, a performance penalty of a better generator may be <br>
a cheap price to pay for some avoided catastrophes.<br>
It may be unexpected, but I have also seen many examples<br>
where the better generator was also the faster.<br>
Simple linear congruential generator cannot be recommended<br>
as they tend to be ill-behaved in several ways.&lt;p&gt;<br>
<br>
For this reason, my initial proposal was George Marsaglia's<br>
COMBO generator, which is the combination of a 32-bit <br>
multiplicative lagged Fibonacci-generator with a 16-bit<br>
multiply with carry generator.<br>
The COMBO generator passes all tests of Marsaglia's<br>
&lt;a href="">
testsuite for random number generators and has<br>
a period of order 2^60.&lt;p&gt;<br>
<br>
As an improvement, Brad Lucier suggested<br>
&lt;a href="">
Pierre L'Ecuyer's<br>
&lt;a href="">
generator which is combination of two recursive generators<br>
of degree three, both of which fit into 54-bit arithmetics.<br>
The MRG32k3a generator also passes DIEHARD and in addition,<br>
has desirable spectral properties and a period in the<br>
order of 2^191.<br>
As a matter of fact, multiple recursive generators (MRGs) are <br>
theoretically much better understood than special constructions<br>
as the COMBO generator.<br>
This is the reason why the implementations provided here<br>
implements the MRG32k3a generator.<br>
When implemented in floating point arithmetics with sufficient<br>
mantissa-width, this generator is also very fast.&lt;p&gt;<br>
<br>
&lt;H3&gt;Choice of arithmetics&lt;/H3&gt;<br>
<br>
The next important decision about the implementation is<br>
the type of arithmetics to be used.<br>
The choice is difficult and depends heavily on the<br>
underlying Scheme system and even on the underlying<br>
hardware platform and architecture.<br>
For the MRG32k3a generator, use 64-bit arithmetics if you <br>
really have it. If not, use a floating point ALU if<br>
it gives you 54 or more bits of mantissa.<br>
And if you do not have floats either, then at least<br>
try to make sure you work with immediate integers<br>
(instead of allocated objects).<br>
Unfortunately, there is no portable way in Scheme to<br>
find out about native and emulated arithmetics.&lt;p&gt;<br>
<br>
As performance is critical to many applications, <br>
one might want to implement the actual<br>
generator itself in native code.<br>
For this reason, I provide three different <br>
implementations of the backbone generator <br>
as a source of inspiration.<br>
See the code below.<br>
<br>
&lt;H3&gt;Data Type for Random Sources&lt;/H3&gt;<br>
<br>
An important aspect of the specification in this SRFI<br>
is that random sources are objects of a distinct type.<br>
Although this is straight-forward and available in nearly<br>
every Scheme implementation, there is no portable way <br>
to do this at present.<br>
One way to define the record type is to use <br>
&lt;a href="">
<br>
The reference implementations below define a record<br>
type to contain the exported procedures.<br>
The actual state of the generator is stored in the<br>
binding time environment of &lt;code&gt;make-random-source&lt;/code&gt;.<br>
This has the advantage that access to the state is fast<br>
even if the record type would be slow (which need not be<br>
the case).<br>
<br>
&lt;H3&gt;Entropy Source for Randomization&lt;/H3&gt;<br>
<br>
Another problematic part of the specification with respect<br>
to portability is &lt;code&gt;random-source-randomize!&lt;/code&gt; as<br>
it needs access to a real entropy source.&lt;p&gt;<br>
<br>
A reasonable choice for such as source is to use the system<br>
clock in order to obtain a value for randomization, for example<br>
in the way John David Stone recommends (see reference below).<br>
This is good enough for most applications with the <br>
notable exception of security related programs.<br>
One way to obtain the time in Scheme is to use <br>
&lt;a href="">
<br>
&lt;H3&gt;Implementation of the specified interface&lt;/H3&gt;<br>
<br>
Once the portability issues are resolved, <br>
one can provide the remaining functionality as <br>
specified in this SRFI document.&lt;p&gt;<br>
<br>
For the reference implementation, a relatively large part<br>
of the code deals with the more advanced features of the <br>
MRG32k3a generator, <br>
in particular &lt;code&gt;random-source-pseudo-randomize!&lt;/code&gt;.<br>
This code is inspired by Pierre L'Ecuyer's own implementation<br>
of the MRG32k3a generator.&lt;p&gt;<br>
<br>
Another part of this generic code deals with changing<br>
the range and quantization of the random numbers and<br>
with error checking to detect common mistakes and abuses.&lt;p&gt;<br>
<br>
&lt;H3&gt;Implementation Examples&lt;/H3&gt;<br>
<br>
&lt;a href="" are three alternative implementations of the SRFI.<br>
(&lt;a href="" are all files, tar-gzipped, 13020 bytes.)<br>
Keep in mind that a SRFI is a &quot;request for implementation&quot;,<br>
which means these implementations are merely examples<br>
to illustrate the specification and inspire people to implement <br>
it better and faster. <br>
The performance figures below are rough indications measured<br>
on a Pentium3, 800 Mhz, Linux; &lt;i&gt;x&lt;/i&gt; ints/s, &lt;i&gt;y&lt;/i&gt; reals/s<br>
means &lt;code&gt;(random-integer 2)&lt;/code&gt; can be computed about &lt;i&gt;x&lt;/i&gt;<br>
times a second and &lt;code&gt;(random-real)&lt;/code&gt; about &lt;i&gt;y&lt;/i&gt; times a second.<br>
The implementations are<br>
<br>
&lt;OL type=&quot;a&quot;&gt;<br>
<br>
&lt;LI&gt; for Scheme 48 0.57, using 54-bit &lt;code&gt;integer&lt;/code&gt; only.<br>
This implementation aims at portability, not at performance<br>
(30000 ints/s, 3000/s reals/s).<br>
<br>
&lt;LI&gt; for Scheme 48 0.57 with the core generator being implemented <br>
in C using &lt;code&gt;(double)&lt;/code&gt;-arithmetics.<br>
The generator is made available in Scheme 48 via the<br>
&lt;a href="" <br>
interface&lt;/a&gt;.<br>
The performance of this generator is good<br>
(160000 ints/s, 180000 reals/s).<br>
<br>
&lt;LI&gt; for Gambit 3.0, using &lt;code&gt;flonum&lt;/code&gt; and <br>
54-bit &lt;code&gt;integer&lt;/code&gt;.<br>
This code is inspired by a program by Brad Lucier as <br>
&lt;a href="">
to the discussion archive of this SRFI.</font>
<br><font size=2 face="Courier New">The performance of this generator is good when compiled<br>
(5000 ints/s, 25000/s reals/s when interpreted,<br>
200000 ints/s, 400000/s reals/s when compiled;<br>
see acknowledgements).<br>
<br>
&lt;/OL&gt;<br>
<br>
In addition to the implementations there is a small<br>
collection of &lt;a href="" tests&lt;/a&gt;<br>
for the interface specified.<br>
The tests merely check a few assertions expressed by the specification.<br>
It is not the intention to provide a complete test of the interface here.<br>
It is even less the intention to provide statistical tests of the<br>
generator itself.<br>
However, there is a function to write random bits from<br>
the generators to a file in a way readable by the &lt;em&gt;DIEHARD&lt;/em&gt; <br>
testsuite. This makes it easier for implementors to find out<br>
about their favorite generators and check their implementation.&lt;p&gt;<br>
<br>
<br>
<br>
&lt;H1&gt;Recommended Usage Patterns&lt;/H1&gt;<br>
<br>
Unless the functionality defined in this SRFI is sufficient,<br>
an application has to implement more procedures to construct<br>
other random deviates.<br>
This section contains some recommendation <br>
on how to do this technically by presenting<br>
examples of increasing difficulty <br>
with respect to the interface.<br>
Note that the code below is not part of the specification,<br>
it is merely meant to illustrate the spirit<br>
<br>
&lt;H3&gt;Generating Random Permutations&lt;/H3&gt;<br>
<br>
The following code defines procedures to generate random <br>
permutations of the set {0, ..., &lt;I&gt;n&lt;/I&gt;-1}.<br>
Such a permutation is represented by a &lt;code&gt;vector&lt;/code&gt; <br>
of length &lt;I&gt;n&lt;/I&gt; for the images of the points.&lt;p&gt;<br>
<br>
Observe that the implementation first defines the procedure <br>
&lt;code&gt;random-source-make-permutations&lt;/code&gt; to<br>
turn a random source &lt;I&gt;s&lt;/I&gt; into a procedure to generate<br>
permutations of given degree &lt;I&gt;n&lt;/I&gt;.<br>
In a second step, this is applied to the default source<br>
to define a ready-to-use procedure for permutations:<br>
&lt;code&gt;(random-permutation &lt;/code&gt;&lt;I&gt;n&lt;/I&gt;&lt;code&gt;)&lt;/code&gt;<br>
constructs a random permutation of degree &lt;I&gt;n&lt;/I&gt;.<br>
<br>
&lt;code&gt;&lt;pre&gt;<br>
(define (random-source-make-permutations s)<br>
 &nbsp;(let ((rand (random-source-make-integers s)))<br>
 &nbsp; &nbsp;(lambda (n)<br>
 &nbsp; &nbsp; &nbsp;(let ((x (make-vector n 0)))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (do ((i 0 (+ i 1)))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((= i n))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (vector-set! x i i))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (do ((k n (- k 1)))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((= k 1) x)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (let* ((i (- k 1))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (j (rand k))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (xi (vector-ref x i))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (xj (vector-ref x j)))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (vector-set! x i xj)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (vector-set! x j xi)))))))<br>
<br>
(define random-permutation<br>
 &nbsp;(random-source-make-permutations default-random-source))<br>
&lt;/pre&gt;&lt;/code&gt;<br>
<br>
For the algorithm refer to Knuth's &quot;The Art of Computer Programming&quot;,<br>
Vol. II, 2nd ed., Algorithm P of Section 3.4.2.<br>
<br>
&lt;H3&gt;Generating Exponentially-Distributed Random Numbers&lt;/H3&gt;<br>
<br>
The following code defines procedures to generate exponentially<br>
Exp(mu)-distributed random numbers.<br>
The technical difficulty of the interface addressed here is<br>
how to pass optional arguments to &lt;code&gt;random-source-make-reals&lt;/code&gt;.<br>
<br>
&lt;code&gt;&lt;pre&gt;<br>
(define (random-source-make-exponentials s . unit)<br>
 &nbsp;(let ((rand (apply random-source-make-reals s unit)))<br>
 &nbsp; &nbsp;(lambda (mu)<br>
 &nbsp; &nbsp; &nbsp;(- (* mu (log (rand)))))))<br>
<br>
(define random-exponential<br>
 &nbsp;(random-source-make-exponentials default-random-source))<br>
&lt;/pre&gt;&lt;/code&gt;<br>
<br>
The algorithm is folklore. Refer to Knuth's &quot;The Art of Computer <br>
Programming&quot;, Vol. II, 2nd ed., Section 3.4.1.D.<br>
<br>
&lt;H3&gt;Generating Normally-Distributed Random Numbers&lt;/H3&gt;<br>
<br>
The following code defines procedures to generate <br>
normal N(mu, sigma)-distributed real numbers using <br>
the polar method.&lt;p&gt;<br>
<br>
The technical difficulty of the interface addressed here<br>
is that the polar method generates two results per computation.<br>
We return one of the result and store the second one to be <br>
returned by the next call to the procedure.<br>
Note that this implies that &lt;code&gt;random-source-state-set!&lt;/code&gt;<br>
(and the other procedures modifying the state) does not necessarily<br>
affect the output of &lt;code&gt;random-normal&lt;/code&gt; immediately!<br>
<br>
&lt;code&gt;&lt;pre&gt;<br>
(define (random-source-make-normals s . unit)<br>
 &nbsp;(let ((rand (apply random-source-make-reals s unit))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (next #f))<br>
 &nbsp; &nbsp;(lambda (mu sigma)<br>
 &nbsp; &nbsp; &nbsp;(if next<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (let ((result next))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (set! next #f)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (+ mu (* sigma result)))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (let loop ()<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (let* ((v1 (- (* 2 (rand)) 1))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (v2 (- (* 2 (rand)) 1))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (s (+ (* v1 v1) (* v2 v2))))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (if (&gt;= s 1)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(loop)<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(let ((scale (sqrt (/ (* -2 (log s)) s))))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set! next (* scale v2))<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(+ mu (* sigma scale v1))))))))))<br>
<br>
(define random-normal<br>
 &nbsp;(random-source-make-normals default-random-source))<br>
&lt;/pre&gt;&lt;/code&gt;<br>
<br>
For the algorithm refer to Knuth's &quot;The Art of Computer Programming&quot;,<br>
Vol. II, 2nd ed., Algorithm P of Section 3.4.1.C.<br>
<br>
&lt;H1&gt;Acknowledgements&lt;/H1&gt;<br>
<br>
I would like to thank all people who have participated in the discussion,<br>
in particular Brad Lucier and Pierre l'Ecuyer.<br>
Their contributions have greatly improved the design of this SRFI.<br>
Moreover, Brad has optimized the Gambit implementation quite substantially.<br>
<br>
&lt;H1&gt;References&lt;/H1&gt;<br>
<br>
&lt;OL&gt;<br>
<br>
&lt;LI&gt;<br>
 &nbsp; &nbsp; &nbsp; G. Marsaglia: <br>
 &nbsp; &nbsp; &nbsp; Diehard -- Testsuite for Random Number Generators. <br>
 &nbsp; &nbsp; &nbsp; &lt;a href="">
 &nbsp; &nbsp; &nbsp; (Also contains some generators that do pass Diehard.)<br>
&lt;/LI&gt;<br>
<br>
&lt;LI&gt;<br>
 &nbsp; &nbsp; &nbsp; D. E. Knuth:<br>
 &nbsp; &nbsp; &nbsp; The Art of Computer Programming;<br>
 &nbsp; &nbsp; &nbsp; Volume II Seminumerical Algorithms.<br>
 &nbsp; &nbsp; &nbsp; 2nd ed. Addison-Wesley, 1981.<br>
 &nbsp; &nbsp; &nbsp; (The famous chapter on random number generators.)<br>
&lt;/LI&gt;<br>
<br>
&lt;LI&gt;<br>
 &nbsp; &nbsp; &nbsp; P. L'Ecuyer:<br>
 &nbsp; &nbsp; &nbsp; &quot;Software for Uniform Random Number Generation:<br>
 &nbsp; &nbsp; &nbsp; Distinguishing the Good and the Bad&quot;,<br>
 &nbsp; &nbsp; &nbsp; Proceedings of the 2001 Winter Simulation Conference, <br>
 &nbsp; &nbsp; &nbsp; IEEE Press, Dec. 2001, 95--105.<br>
 &nbsp; &nbsp; &nbsp; &lt;a href="">
 &nbsp; &nbsp; &nbsp; (Profound discussion of random number generators.)<br>
&lt;/LI&gt;<br>
<br>
&lt;LI&gt;<br>
 &nbsp; &nbsp; &nbsp; P. L'Ecuyer:<br>
 &nbsp; &nbsp; &nbsp; &quot;Good Parameter Sets for Combined Multiple Recursive<br>
 &nbsp; &nbsp; &nbsp; Random Number Generators&quot;, <br>
 &nbsp; &nbsp; &nbsp; Shorter version in Operations Research, 47, 1 (1999), 159--164.<br>
 &nbsp; &nbsp; &nbsp; &lt;a href="">
 &nbsp; &nbsp; &nbsp; (Actual numbers for good generators.)<br>
&lt;/LI&gt;<br>
<br>
&lt;LI&gt;<br>
 &nbsp; &nbsp; &nbsp; P. L'Ecuyer:<br>
 &nbsp; &nbsp; &nbsp; &quot;Software for Uniform Random Number Generation:<br>
 &nbsp; &nbsp; &nbsp; Distinguishing the Good and the Bad&quot;,<br>
 &nbsp; &nbsp; &nbsp; Proceedings of the 2001 Winter Simulation Conference, <br>
 &nbsp; &nbsp; &nbsp; IEEE Press, Dec. 2001, 95--105.<br>
&lt;/LI&gt;<br>
<br>
&lt;LI&gt;<br>
 &nbsp; &nbsp; &nbsp; MIT Scheme v7.6:<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &lt;code&gt;random flo:random-unit *random-state* make-random-state <br>
 &nbsp; &nbsp; &nbsp; &nbsp; random-state?&lt;/code&gt;<br>
 &nbsp; &nbsp; &nbsp; &lt;a href="">
 &nbsp; &nbsp; &nbsp; (A mechanism to run a fixed unspecified generator.)<br>
&lt;/LI&gt;<br>
<br>
&lt;LI&gt;<br>
 &nbsp; &nbsp; &nbsp; A. Jaffer: <br>
 &nbsp; &nbsp; &nbsp; SLIB 2d2 with (require 'random):<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &lt;code&gt;random *random-state* copy-random-state seed-&gt;random-state<br>
 &nbsp; &nbsp; &nbsp; &nbsp; make-random-state random:uniform random:exp random:normal-vector!<br>
 &nbsp; &nbsp; &nbsp; &nbsp; random-hollow-sphere! random:solid-sphere!&lt;/code&gt;<br>
 &nbsp; &nbsp; &nbsp; &lt;a href="">
 &nbsp; &nbsp; &nbsp; (Based on the MIT Scheme mechanism.)<br>
&lt;/LI&gt;<br>
<br>
&lt;LI&gt;<br>
 &nbsp; &nbsp; &nbsp; R. Kelsey, J. Rees:<br>
 &nbsp; &nbsp; &nbsp; Scheme 48 v0.57 'random.scm': <br>
 &nbsp; &nbsp; &nbsp; &nbsp; &lt;code&gt;make-random make-random-vector&lt;/code&gt;<br>
 &nbsp; &nbsp; &nbsp; (Internal procedures of Scheme48; a fixed 28-bit generator.)<br>
&lt;/LI&gt;<br>
<br>
&lt;LI&gt;<br>
 &nbsp; &nbsp; &nbsp; M. Flatt: <br>
 &nbsp; &nbsp; &nbsp; PLT MzScheme Version 200alpha1:<br>
 &nbsp; &nbsp; &nbsp; &nbsp; &lt;code&gt;random random-seed current-pseudo-random-generator <br>
 &nbsp; &nbsp; &nbsp; &nbsp; make-pseudo-random-generator pseudo-random-generator?&lt;/code&gt;<br>
 &nbsp; &nbsp; &nbsp; &lt;a href="">
 &nbsp; &nbsp; &nbsp; (A mechanism to run a generator and to exchange the generator.)</font>
<br><font size=2 face="Courier New">&lt;/LI&gt;<br>
<br>
&lt;LI&gt;<br>
 &nbsp; &nbsp; &nbsp; H. Abelson, G. J. Sussmann, J. Sussman:<br>
 &nbsp; &nbsp; &nbsp; Structure and Interpretation of Computer Programs.<br>
 &nbsp; &nbsp; &nbsp; &lt;a href="">
 &nbsp; &nbsp; &nbsp; (The &lt;code&gt;rand&lt;/code&gt;-example shows a textbook way to define a <br>
 &nbsp; &nbsp; &nbsp; random number generator.)<br>
&lt;/LI&gt;<br>
<br>
&lt;LI&gt;<br>
 &nbsp; &nbsp; &nbsp; John David Stone:<br>
 &nbsp; &nbsp; &nbsp; A portable random-number generator.<br>
 &nbsp; &nbsp; &nbsp; &lt;a href="">
 &nbsp; &nbsp; &nbsp; (An implementation of a linear congruential generator in Scheme.)<br>
&lt;/LI&gt;<br>
<br>
&lt;LI&gt;<br>
 &nbsp; &nbsp; &nbsp; Network Working Group:<br>
 &nbsp; &nbsp; &nbsp; RFC1750: Randomness Recommendations for Security.<br>
 &nbsp; &nbsp; &nbsp; &lt;a href="">
 &nbsp; &nbsp; &nbsp; (A serious discussion of serious randomness for serious security.)<br>
&lt;/LI&gt;<br>
<br>
&lt;LI&gt;<br>
 &nbsp; &nbsp; &nbsp; &lt;a href="">
 &nbsp; &nbsp; &nbsp; &lt;a href="">
 &nbsp; &nbsp; &nbsp; (Resources on random number generators and randomness.)<br>
&lt;/LI&gt;<br>
<br>
&lt;/OL&gt;<br>
<br>
<br>
&lt;H1&gt;Copyright&lt;/H1&gt;<br>
Copyright (C) Sebastian Egner (2002). All Rights Reserved. <br>
&lt;p&gt;<br>
This document and translations of it may be copied and furnished to<br>
others, and derivative works that comment on or otherwise explain it<br>
or assist in its implementation may be prepared, copied, published and<br>
distributed, in whole or in part, without restriction of any kind,<br>
provided that the above copyright notice and this paragraph are<br>
included on all such copies and derivative works. However, this<br>
document itself may not be modified in any way, such as by removing<br>
the copyright notice or references to the Scheme Request For<br>
Implementation process or editors, except as needed for the purpose of<br>
developing SRFIs in which case the procedures for copyrights defined<br>
in the SRFI process must be followed, or as required to translate it<br>
into languages other than English.<br>
&lt;p&gt;<br>
The limited permissions granted above are perpetual and will not be<br>
revoked by the authors or their successors or assigns.<br>
&lt;p&gt;<br>
This document and the information contained herein is provided on an<br>
&quot;AS IS&quot; basis and THE AUTHOR AND THE SRFI EDITORS DISCLAIM ALL<br>
WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY<br>
WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY<br>
RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A<br>
PARTICULAR PURPOSE.<br>
<br>
<br>
 &nbsp; &nbsp;&lt;hr&gt;<br>
 &nbsp; &nbsp;&lt;address&gt;Editor: &lt;a href="" Sperber&lt;/a&gt;&lt;/address&gt;<br>
 &nbsp; &nbsp;&lt;address&gt;Author: &lt;a href="" Egner&lt;/a&gt;&lt;/address&gt;<br>
&lt;!-- Created: Mon Feb 4 18:17 EST 2002 --&gt;<br>
&lt;!-- hhmts start --&gt;<br>
Last modified: Mon Jun &nbsp;3 17:52:06 MST 2002<br>
&lt;!-- hhmts end --&gt;<br>
 &nbsp;&lt;/body&gt;<br>
&lt;/html&gt;<br>
</font>
<br>
<br>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00033.html">Final SRFI 27: Sources of Random Bits</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00033.html">Final SRFI 27: Sources of Random Bits</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00034"><strong>Date</strong></a></li>
<li><a href="threads.html#00034"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
