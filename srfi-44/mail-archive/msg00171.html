<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: [oleg@pobox.com: Interface view of dictionaries] -->
<!--X-From-R13: fptzvyyrNserrargcebwrpg.bet -->
<!--X-Date: Tue, 28 Oct 2003 15:10:40 +0100 (NFT) -->
<!--X-Message-Id: 20031028141032.GA28954@freenetproject.org -->
<!--X-Content-Type: multipart/signed -->
<!--X-Reference: 20031028012813.GB12968@freenetproject.org -->
<!--X-Reference: 20031028042549.GA10098@loki.vpn.szonye.com -->
<!--X-Reference: 20031028045401.GB16906@freenetproject.org -->
<!--X-Reference: 20031028053331.GC10098@loki.vpn.szonye.com -->
<!--X-Derived: pgpBGf11JCxp9.pgp -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: [oleg@xxxxxxxxx: Interface view of dictionaries]</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00170.html">Date Prev</a>][<a href="msg00172.html">Date Next</a>][<a href="msg00170.html">Thread Prev</a>][<a href="msg00172.html">Thread Next</a>][<a href="maillist.html#00171">Date Index</a>][<a href="threads.html#00171">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: [oleg@xxxxxxxxx: Interface view of dictionaries]</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: <a href="mailto:srfi-44@DOMAIN.HIDDEN">srfi-44@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Subject</em>: Re: <a href="mailto:%5Boleg@DOMAIN.HIDDEN">[oleg@xxxxxxxxx</a>: Interface view of dictionaries]</li>
<li><em>From</em>: <a href="mailto:scgmille@DOMAIN.HIDDEN">scgmille@xxxxxxxxxxxxxxxxxx</a></li>
<li><em>Date</em>: Tue, 28 Oct 2003 08:10:32 -0600</li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-44@DOMAIN.HIDDEN">srfi-44@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:20031028053331.GC10098@DOMAIN.HIDDEN">20031028053331.GC10098@xxxxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Mail-followup-to</em>: <a href="mailto:scgmille@DOMAIN.HIDDEN">scgmille@xxxxxxxxxxxxxxxxx</a>,	<a href="mailto:srfi-44@DOMAIN.HIDDEN">srfi-44@xxxxxxxxxxxxxxxxx</a></li>
<li><em>References</em>: &lt;<a href="mailto:20031028012813.GB12968@DOMAIN.HIDDEN">20031028012813.GB12968@xxxxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20031028042549.GA10098@DOMAIN.HIDDEN">20031028042549.GA10098@xxxxxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20031028045401.GB16906@DOMAIN.HIDDEN">20031028045401.GB16906@xxxxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20031028053331.GC10098@DOMAIN.HIDDEN">20031028053331.GC10098@xxxxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>User-agent</em>: Mutt/1.5.4i</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>On Mon, Oct 27, 2003 at 09:33:31PM -0800, Bradd W. Szonye wrote:
&gt; Consider procedures that operate on K sequential elements, starting with
&gt; a given key. It's a common operation for dictionaries that permit
&gt; duplicate keys; you often need to enumerate all elements that match a
&gt; given key.
But this operation doesn't make any sense for dictionaries that don't 
permit duplicate keys.

&gt; &gt;&gt; And Bear is trying to establish that some of these functions are not
&gt; &gt;&gt; only common but important extensions. For most dictionary-type
&gt; &gt;&gt; collections, primitives aren't sufficient. There's a convenience
&gt; &gt;&gt; argument *and* a performance argument for extending the set.
&gt; 
&gt; &gt; But only if those operators generalize to all dictionaries.
&gt; 
&gt; They'd better, or it'll be very difficult to deal with duplicate keys.
&gt; IIRC, I mentioned this in my last review of dictionaries; the interface
&gt; doesn't even have GET-ANY to fetch all matching elements. That's an
&gt; important interface for dictionaries with non-unique keys.
This is a valid point.

&gt; 
&gt; &gt; Otherwise they impair the elegance and utility of the API that is
&gt; &gt; general to all dictionaries.
&gt; 
&gt; Pardon my vulgarity, but screw elegance. It means different things to
&gt; everyone, and it's the doom of many a design. The overzealous desire for
&gt; so-called elegance is one of the things that leads to what Bear called
&gt; APIs for stupid programs.
&gt; 
&gt; I see this desire for elegance in designers of all kinds, and it almost
&gt; always reflects the author's unreasoning infatuation with some design,
&gt; whether it's actually useful or not. In my opinion, &quot;elegance&quot; should
&gt; never, ever be a design goal; it's a primrose path that leads to Hell.

You sir, are obviously not using the right language then.  

&gt; Oleg wrote:
&gt; &gt;&gt;&gt; The intent is not to make it unnecessary to add more API in future
&gt; &gt;&gt;&gt; SRFIs. Rather, the intent is to make it unnecessary to remove
&gt; &gt;&gt;&gt; SRFI-44 features in future SRFIs.
&gt; 
&gt; &gt;&gt; Why would you need to remove a function that is more convenient and more
&gt; &gt;&gt; efficient?
&gt; 
&gt; &gt; Because they may not apply to a hypothetical collection.
&gt; 
&gt; I'm sorry, what sort of dictionary does &quot;fetch K elements from key&quot; not
&gt; apply to? This is a perfect example of being too attached to &quot;elegance&quot;
&gt; and too willing to throw away useful concepts.

I agree with this particular operator, but this is simply not true for 
many of the operators in Bear's kitchen sink dictionary library.

&gt; &gt; Hardly.  The SRFI was defined before there was even an object system
&gt; &gt; selected for the reference implementation.  We were very careful not
&gt; &gt; to evey specify polymorphism.  The SRFI only requires that the more
&gt; &gt; general functions work for the 'subtypes' of the SRFI.  It never says
&gt; &gt; that the collections actually be subtypes in some object system, its
&gt; &gt; just a useful metaphor.
&gt; 
&gt; But the metaphor reeks of class-based, objects-as-references
&gt; inheritance. I asked before, and I'll ask again: What's the OO design
&gt; principle behind the classes? Should the Liskov Substitution Principle
&gt; hold? Why isn't set a subtype of bag, or vice versa? Why aren't
&gt; dictionaries and sequences more closely related? Is the bag type
&gt; justified at all?

There is no OO principle behind the classes.  There is a metaphor of 
subtyping which serves to eluminate collection interaction and 
interoperability relationships.

Set isn't a subtype of bag because they have subtly different 
properties, despite similar interfaces.  See:

<a  rel="nofollow" href="http://okmij.org/ftp/Computation/Subtyping/">http://okmij.org/ftp/Computation/Subtyping/</a>

Dictionaries and sequences have no business being related.  A dictionary 
maps arbitrary keys to one or more values.  A sequence merely stores 
values in a contiguous range accessable by integers.  Attempting to 
wedge one into the other will limit the utility and generality of both.

&gt; Right now, I don't know why the hierarchy looks the way it does. For all
&gt; I know, the design was, &quot;These collection types seem kinda related.
&gt; Let's make one a subtype of the other.&quot; What are the actual principles,
&gt; and how will they hold up in a prototype-based system or with parametric
&gt; polymorphism? Does the hierarchy constrain implementors in ways that you
&gt; don't expect?

Hardly.  The hierarchy deliberately seeks to limit restrictions.  If you 
notice, the only actual inheritance chain is for 
Bag-&gt;Sequence-&gt;Flexible Sequence.  This is quite logical, since 
sequences still support multiple instances of values.  

The design is largely influenced by the rational choices of collection 
libraries in many languages, and was chosen carefully to be mappable to 
many types of generic dispatch and OO styles.

&gt; With no explicit design goals, no complete implementation, and no
&gt; examples of the collections in actual use, how are we supposed to trust
&gt; that these won't be problems?
If you don't trust me, construct a counter-example.  I'm not going to 
make a proof by example, since you could very well argue that it wasn't 
the 'right' example.

&gt; 
&gt; &gt; You seem to portray this as if I'm hiding some dark secret about
&gt; &gt; limitations to the API.  I'm quite confident in the API in fact, and
&gt; &gt; just don't believe that I need 'prove' its good to you by writing a
&gt; &gt; bunch of code that won't wind up in the SRFI.
&gt; 
&gt; That's nice that you're confident in your own design. But isn't that the
&gt; whole point of the reference implementation? We're not *supposed* to
&gt; take your implementation on faith. *You're* supposed to demonstrate that
&gt; it's actually implementable. Extra points if you can show that it stands
&gt; up well under real use.
And we did, for the set of collections that exist already in Scheme 
and are relevant in this SRFI.  Again, only sets weren't represented.

&gt; If it seems like I'm being a jerk about this, it's because my day job is
&gt; 100% about quality -- code reviews, design reviews, testing,
&gt; verification, making sure that we have more than just the developer's
&gt; word that a system is good. This &quot;I don't need to prove that my design
&gt; is good&quot; attitude doesn't fly in a code review. And isn't that exactly
&gt; what the SRFI draft process is?

I respect your background, but if it matters so much to you, why not 
attempt to write a new bag collection yourself.  Just deal with the 
concrete functions (my-bag-contains?, etc).  Let me know if you run into 
problems.  

&gt; 
&gt; &gt;&gt; So while I agree that there is value in a stable API, I don't think
&gt; &gt;&gt; there's any value in rushing an immature API to finalization just so
&gt; &gt;&gt; that we can call it &quot;stable.&quot; It'd be much better to propose a
&gt; &gt;&gt; concrete collection or three, get some experience with their use, and
&gt; &gt;&gt; it they're successful, factor out the interface and publish that as a
&gt; &gt;&gt; SRFI.
&gt; 
&gt; &gt; This is arguably bad design. Writing many collections and then culling
&gt; &gt; the common operators is a great way to wind up with a poorly thought
&gt; &gt; out system.
&gt; 
&gt; Not if those collections are themselves well-designed. Design a good
&gt; system, implement it, determine what can be reused or factored out for
&gt; future projects. That's how reuse works. If you haven't already, I
&gt; strongly recommend that you study it. I can dig out some good titles if
&gt; you like, although they're all for C++ rather than Scheme.

Even if the collections themselves have fantastic designs, they don't 
necessarily generalize to other collections.  Worse, the intersection of 
operators from a number of collections may miss more general operators 
that must exist for a reasonable interface.  The fold operator is an 
excellent example.

&gt; Once again: It isn't general or interoperable until you've seen it in
&gt; use, until you've tried to use it and reuse it. Until then, it's just an
&gt; interface that you *hope* is reusable. Many projects start out by
&gt; assuming that interfaces like these will be reusable. They typically
&gt; fail. Again, spend some time studying reusability if you haven't
&gt; already; getting it right is a LOT harder than it seems.

Go for it.

&gt; &gt;&gt; Actually, if they're successful, there's less need to publish the
&gt; &gt;&gt; interface separately. Future developers will imitate it like they
&gt; &gt;&gt; already imitate SRFI-1. That's a much more desirable outcome: We get
&gt; &gt;&gt; useful collection types *and* a de facto standard interface that way.
&gt; 
&gt; &gt; Name one language with a useful generic collections library that got
&gt; &gt; it this way?
&gt; 
&gt; You have heard of C++, right?

I'm restraining laughter.  

	Scott

</pre><p><strong>Attachment:
<a href="pgpBGf11JCxp9.pgp" ><tt>pgpBGf11JCxp9.pgp</tt></a></strong><br>
<em>Description:</em> PGP signature</p>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00172" href="msg00172.html">Re: [oleg@xxxxxxxxx: Interface view of dictionaries]</a></strong>
<ul><li><em>From:</em> scgmille</li></ul></li>
<li><strong><a name="00176" href="msg00176.html">Re: [oleg@xxxxxxxxx: Interface view of dictionaries]</a></strong>
<ul><li><em>From:</em> Bradd W. Szonye</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00165" href="msg00165.html">[oleg@xxxxxxxxx: Interface view of dictionaries]</a></strong>
<ul><li><em>From:</em> scgmille</li></ul></li>
<li><strong><a name="00167" href="msg00167.html">Re: [oleg@xxxxxxxxx: Interface view of dictionaries]</a></strong>
<ul><li><em>From:</em> Bradd W. Szonye</li></ul></li>
<li><strong><a name="00169" href="msg00169.html">Re: [oleg@xxxxxxxxx: Interface view of dictionaries]</a></strong>
<ul><li><em>From:</em> scgmille</li></ul></li>
<li><strong><a name="00170" href="msg00170.html">Re: [oleg@xxxxxxxxx: Interface view of dictionaries]</a></strong>
<ul><li><em>From:</em> Bradd W. Szonye</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00170.html">Re: [oleg@xxxxxxxxx: Interface view of dictionaries]</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00172.html">Re: [oleg@xxxxxxxxx: Interface view of dictionaries]</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00170.html">Re: [oleg@xxxxxxxxx: Interface view of dictionaries]</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00172.html">Re: [oleg@xxxxxxxxx: Interface view of dictionaries]</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00171"><strong>Date</strong></a></li>
<li><a href="threads.html#00171"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
