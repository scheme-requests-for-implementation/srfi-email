<!-- MHonArc v2.6.15 -->
<!--X-Subject: Interface view of dictionaries -->
<!--X-From-R13: orne <orneNfbavp.arg> -->
<!--X-Date: Sat, 25 Oct 2003 21:28:03 +0200 (DFT) -->
<!--X-Message-Id: Pine.LNX.4.58.0310251010190.5625@bolt.sonic.net -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20031020191331.GB4433@ogre.szonye.com -->
<!--X-Reference: 20031020203620.GB28213@freenetproject.org -->
<!--X-Reference: 20031021004429.GE4433@ogre.szonye.com -->
<!--X-Reference: 20031021011250.GA26398@loki.vpn.szonye.com -->
<!--X-Reference: 20031021072047.GB26398@loki.vpn.szonye.com -->
<!--X-Reference: 20031023010959.GA20350@freenetproject.org -->
<!--X-Reference: 20031023020257.GA6989@loki.vpn.szonye.com -->
<!--X-Reference: 20031023024351.GA21257@freenetproject.org -->
<!--X-Reference: 20031023033542.GB6989@loki.vpn.szonye.com -->
<!--X-Reference: 20031025035254.GB26663@freenetproject.org -->
<!--X-Reference: 20031025165854.GA18773@loki.vpn.szonye.com -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Interface view of dictionaries</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00130.html">Date Prev</a>][<a href="msg00132.html">Date Next</a>][<a href="msg00157.html">Thread Prev</a>][<a href="msg00133.html">Thread Next</a>][<a href="maillist.html#00131">Date Index</a>][<a href="threads.html#00131">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Interface view of dictionaries</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-44">SRFI 44</a> from before July 7th, 2015.  The new archives for SRFI 44 are <a href="http://srfi-email.schemers.org/srfi-44/">here</a>.  Eventually, the entire history will be moved there, including any new messages.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: &quot;Bradd W. Szonye&quot; &lt;<a href="mailto:bradd%2Bsrfi@DOMAIN.HIDDEN">bradd+srfi@xxxxxxxxxx</a>&gt;</li>
<li><em>Subject</em>: Interface view of dictionaries</li>
<li><em>From</em>: bear &lt;<a href="mailto:bear@DOMAIN.HIDDEN">bear@xxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Sat, 25 Oct 2003 12:27:54 -0700 (PDT)</li>
<li><em>Cc</em>: <a href="mailto:srfi-44@DOMAIN.HIDDEN">srfi-44@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-44@DOMAIN.HIDDEN">srfi-44@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:20031025165854.GA18773@DOMAIN.HIDDEN">20031025165854.GA18773@xxxxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>References</em>: &lt;<a href="mailto:20031020191331.GB4433@DOMAIN.HIDDEN">20031020191331.GB4433@xxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20031020203620.GB28213@DOMAIN.HIDDEN">20031020203620.GB28213@xxxxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20031021004429.GE4433@DOMAIN.HIDDEN">20031021004429.GE4433@xxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20031021011250.GA26398@DOMAIN.HIDDEN">20031021011250.GA26398@xxxxxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20031021072047.GB26398@DOMAIN.HIDDEN">20031021072047.GB26398@xxxxxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20031023010959.GA20350@DOMAIN.HIDDEN">20031023010959.GA20350@xxxxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20031023020257.GA6989@DOMAIN.HIDDEN">20031023020257.GA6989@xxxxxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20031023024351.GA21257@DOMAIN.HIDDEN">20031023024351.GA21257@xxxxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20031023033542.GB6989@DOMAIN.HIDDEN">20031023033542.GB6989@xxxxxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20031025035254.GB26663@DOMAIN.HIDDEN">20031025035254.GB26663@xxxxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20031025165854.GA18773@DOMAIN.HIDDEN">20031025165854.GA18773@xxxxxxxxxxxxxxxxxxx</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>

On Sat, 25 Oct 2003, Bradd W. Szonye wrote:

&gt;Bradd wrote:
&gt;&gt;&gt; Agreed. I keep waffling between two different concepts for the
&gt;&gt;&gt; dictionary: is it a collection of mappings, or is it a bag with an
&gt;&gt;&gt; index?
&gt;
&gt;scgmille@xxxxxxxxxxxxxxxxxx wrote:
&gt;&gt; A dictionary is a datastructure which stores values that can be
&gt;&gt; accessed using a key.  Anything more specific than that assumes a
&gt;&gt; specific implementation type.

&gt;There are two common kinds of dictionary ADTs:

&gt;1. A collection of mappings. This is how you define a dictionary in set
&gt;   theory. In this kind of dictionary, the keys are conceptually a part
&gt;   of a collection element (but they need not be represented that way
&gt;   internally). Scheme alists and C++ maps use this concept.

&gt;2. A collection with an index. This is more like a sequence, or a bag
&gt;   with an index. The keys are conceptually external to the elements
&gt;   (but they need not be represented that way internally). PLT Scheme
&gt;   hash tables use this concept.

I'm going to step back from the theory questions and fold questions,
and tell you what I find useful as a programmer.  I've implemented
most of this for hashtables, binary trees, and alists already, and
filling it out with the performance predicates would be the logical
next step.  I don't think of a &quot;collection of mappings&quot; versus a
&quot;collection with an index&quot; - I think of Ordered and Unordered
dictionaries.

I don't know whether this is really good design; but I think it's
fairly clear, and in practice my hashtable and btree libraries are
working quite nicely and easy to work with. To be honest, &quot;fold&quot; isn't
a very meaningful word to me, and I wouldn't use it in naming
functions.  I think in terms of iterators, ordering functions, and
reversed iterators, not in terms of folding operations.  likewise
&quot;reversible&quot; is a word that can mean any of dozens of things; what I'm
asking is whether an operation is sublinear time or constant time and
I'd use those keywords in naming performance predicates.

An iterator is part of the basic dictionary functionality; it's a
function that, when given a key, returns some &quot;next&quot; key that's valid
for that dictionary.  For unordered dictionaries, the sequence is
arbitrary.  For ordered dictionaries, it will depend on the key
ordering predicate that was given the dictionary creation function.
Reversed iterators traverse the keys in the opposite order, and as
such are only found in ordered dictionaries.  The &quot;fold&quot; operation is
most easily understood in terms of iterators, but iterators are not as
easily understood in terms of fold.  (or maybe that's just me.... I
already said it's not a very meaningful word to me.  When I see &quot;fold&quot;
in a program I'm probably going to be thinking about compressing hash
tables or something.)

My preferred style is that there are &quot;interfaces&quot; -- sets of functions
which are valid on a given structure.  So my take on it would be to
have all dictionaries provide the &quot;dictionary&quot; interface -- which is
this:

    (Forgive me for not relating these function names to the proposal;
    there aren't even near analogues to my libs in some cases.)

(create-*)
(*-insert! dict datum key),

     ;; fetch is a key lookup.
(*-fetch dict key),
(*-fetch-deleting! dict key)

     ;; get just gets one or more elements without caring which.
(*-get-one dict)
(*-get-one-deleting! dict)
(*-get-n dict num)
(*-get-n-deleting! dict num)

     ;; the following two are for functions of the signature
     ;; (callback dict keyval dataval)
(*-foreach dict callback)
     ;; a copy is made of the dict to protect it from side effects
(*-foreach! dict callback)
     ;; side effects happen to the dictionary.

(*-size dict) ;; returns number of datum/key pairs stored

(get-iterator dict)   ;; returns an iterator function that
                      ;; takes a key arg and returns some &quot;next&quot; key,
                      ;; or takes '() and returns some (arbitrarily
                      ;; chosen for unordered dictionaries) &quot;first&quot; key.

(*-nextkey dict) ;; same as function returned from get-iterator

;; the following is a test to see whether the &quot;Ordered dictionary&quot;
;; interface is also provided. The test for ordered dictionaries could
;; be part of the interface for all dictionaries.

(ordered-dict? dict)

     ;; the following eight items are performance predicates
(sublinear-insert? dict)
(constant-insert? dict)
     ;; get means the get-one and get-n operations, which don't care
     ;; about keys.
(sublinear-get? dict)
(constant-get? dict)
     ;; lookup means the fetch operations, which take a key.
(sublinear-lookup? dict)
(constant-lookup? dict)
     ;; these refer to the performance of the iterator function
(sublinear-next? dict)
(constant-next? dict)


Some dictionaries would also provide the &quot;ordered dictionary&quot;
interface -- which includes

(create-* &lt;key ordering function&gt;)
(*-fetchfirst dict)  ;; returns 1 entry
(*-fetchfirst dict number) ;; returns number entries
(*-fetchfirst-deleting! dict)
(*-fetchfirst-deleting! dict number)
(*-fetchlast dict)
(*-fetchlast dict number)
(*-fetchlast-deleting! dict)
(*-fetchlast-deleting! dict number)
(*-fetchrange dict key1 key2)
(*-fetchrange-deleting! dict key1 key2)
(*-fetch-next-n dict key1 number)
(*-fetch-next-n-deleting! dict key1 number)
(*-fetch-prev-n dict key1 number)
(*-fetch-prev-n-deleting! dict key1 number)
(*-firstkey dict)
(*-nextkey dict key) ;; same as returned from the get-iterator func above
(*-lastkey dict)     ;; same as returned from the get-reversed-iterator func
(get-reversed-iterator dict)
(keys-ordered? dict key1 key2)

  ;; the following items are performance predicates.
(sublinear-first? dict)
(constant-first? dict)
(sublinear-last? dict)
(constant-last? dict)
   ;; these refer to the performance of the reversed
   ;; iterator.
(sublinear-prev? dict)
(constant-prev? dict)




Associated with each interface is a predicate which accepts an
argument of any type and returns #t if it provides that interface.
So, for the sake of examples, we would have





(define htable (create-hashtable hfunc))
(define alyst (create-alist))
(define pqueue (create-priority-queue &lt; ))
(define btree (create-binary-tree &lt; ))
(define olist (create-ordered-alist &lt; ))

(dictionary? htable) =&gt; #t
(dictionary? pqueue) =&gt; #t
(dictionary? btree) =&gt; #t
(dictionary? olist) =&gt; #t
(dictionary? alyst) =&gt; #t

(ordered-dict? htable) =&gt; #f
(ordered-dict? alyst) =&gt; #f
(ordered-dict? olist) =&gt; #t
(ordered-dict? btree) =&gt; #t
(ordered-dict? pqueue) =&gt; #t





Finally there's considerations of efficiency: Additional predicates
tell which general classes of operations are constant, sublinear, or
linear.





(sublinear-first? pqueue) =&gt; #t
(sublinear-first? olist) =&gt; #t
(sublinear-first? btree) =&gt; #t

(sublinear-next? btree) =&gt;#t
(sublinear-next? pqueue) =&gt;#f
(constant-next? btree) =&gt;#f

(sublinear-prev? pqueue) =&gt;#f
(sublinear-prev? btree) =&gt;#t
(constant-prev? btree) =&gt;#f

(constant-first? btree) =&gt; #f
(constant-first? olist) =&gt; #t
(constant-first? pqueue) =&gt; #f
  ;; pqueue has constant fetchfirst and get (which are actually the
  ;; same operation) but it cannot claim constant-first, because
  ;; its get-deleting! and first-deleting! operations take logarithmic
  ;; time.

(sublinear-last? pqueue) =&gt; #f
(sublinear-last? olist) =&gt; #f
(sublinear-last? btree) =&gt; #t

(sublinear-lookup? htable) =&gt; #t
(sublinear-lookup? btree) =&gt; #t
(sublinear-lookup? alyst) =&gt; #f
(sublinear-lookup? olist) =&gt; #f

(constant-lookup? htable) =&gt; #t
(constant-lookup? btree) =&gt; #f

(sublinear-insert? olist) =&gt; #f
(sublinear-insert? alyst) =&gt; #t
(sublinear-insert? btree) =&gt; #t
(sublinear-insert? htable) =&gt; #t

(constant-insert? alyst) =&gt; #t
(constant-insert? btree) =&gt; #f
(constant-insert? htable) =&gt; #t

;; the next two are implied because sublinear-first
;; or sublinear-last is true of them...

(sublinear-get? btree) =&gt; #t
(sublinear-get? htable) =&gt; #t

;; but that condition, while sufficient, is not necessary,
;; as alyst demonstrates.

(sublinear-get? alyst) =&gt; #t
(constant-get? alyst) =&gt; #t


</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00133" href="msg00133.html">Re: Interface view of dictionaries</a></strong>
<ul><li><em>From:</em> scgmille</li></ul></li>
<li><strong><a name="00152" href="msg00152.html">Re: Interface view of dictionaries</a></strong>
<ul><li><em>From:</em> scgmille</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00095" href="msg00095.html">Re: s/-LEFT//g?</a></strong>
<ul><li><em>From:</em> Bradd W. Szonye</li></ul></li>
<li><strong><a name="00102" href="msg00102.html">Re: s/-LEFT//g?</a></strong>
<ul><li><em>From:</em> scgmille</li></ul></li>
<li><strong><a name="00103" href="msg00103.html">Re: s/-LEFT//g?</a></strong>
<ul><li><em>From:</em> Bradd W. Szonye</li></ul></li>
<li><strong><a name="00104" href="msg00104.html">Procedures (interfaces)</a></strong>
<ul><li><em>From:</em> Bradd W. Szonye</li></ul></li>
<li><strong><a name="00105" href="msg00105.html">Re: Procedures (interfaces)</a></strong>
<ul><li><em>From:</em> Bradd W. Szonye</li></ul></li>
<li><strong><a name="00115" href="msg00115.html">Re: Procedures (interfaces)</a></strong>
<ul><li><em>From:</em> scgmille</li></ul></li>
<li><strong><a name="00116" href="msg00116.html">Major issues</a></strong>
<ul><li><em>From:</em> Bradd W. Szonye</li></ul></li>
<li><strong><a name="00117" href="msg00117.html">Re: Major issues</a></strong>
<ul><li><em>From:</em> scgmille</li></ul></li>
<li><strong><a name="00118" href="msg00118.html">Re: Major issues</a></strong>
<ul><li><em>From:</em> Bradd W. Szonye</li></ul></li>
<li><strong><a name="00122" href="msg00122.html">Re: Major issues</a></strong>
<ul><li><em>From:</em> scgmille</li></ul></li>
<li><strong><a name="00125" href="msg00125.html">Re: Major issues</a></strong>
<ul><li><em>From:</em> Bradd W. Szonye</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00130.html">Re: Major issues</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00132.html">Re: Left- and right-ness of folds</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00157.html">Re: Major issues</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00133.html">Re: Interface view of dictionaries</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00131"><strong>Date</strong></a></li>
<li><a href="threads.html#00131"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
