<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: [oleg@pobox.com: Interface view of dictionaries] -->
<!--X-From-R13: fptzvyyrNserrargcebwrpg.bet -->
<!--X-Date: Tue, 28 Oct 2003 05:54:09 +0100 (NFT) -->
<!--X-Message-Id: 20031028045401.GB16906@freenetproject.org -->
<!--X-Content-Type: multipart/signed -->
<!--X-Reference: 20031028012813.GB12968@freenetproject.org -->
<!--X-Reference: 20031028042549.GA10098@loki.vpn.szonye.com -->
<!--X-Derived: pgp4HbaVtST3W.pgp -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: [oleg@xxxxxxxxx: Interface view of dictionaries]</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00168.html">Date Prev</a>][<a href="msg00170.html">Date Next</a>][<a href="msg00167.html">Thread Prev</a>][<a href="msg00170.html">Thread Next</a>][<a href="maillist.html#00169">Date Index</a>][<a href="threads.html#00169">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: [oleg@xxxxxxxxx: Interface view of dictionaries]</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: <a href="mailto:srfi-44@DOMAIN.HIDDEN">srfi-44@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Subject</em>: Re: <a href="mailto:%5Boleg@DOMAIN.HIDDEN">[oleg@xxxxxxxxx</a>: Interface view of dictionaries]</li>
<li><em>From</em>: <a href="mailto:scgmille@DOMAIN.HIDDEN">scgmille@xxxxxxxxxxxxxxxxxx</a></li>
<li><em>Date</em>: Mon, 27 Oct 2003 22:54:01 -0600</li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-44@DOMAIN.HIDDEN">srfi-44@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:20031028042549.GA10098@DOMAIN.HIDDEN">20031028042549.GA10098@xxxxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Mail-followup-to</em>: <a href="mailto:scgmille@DOMAIN.HIDDEN">scgmille@xxxxxxxxxxxxxxxxx</a>,	<a href="mailto:srfi-44@DOMAIN.HIDDEN">srfi-44@xxxxxxxxxxxxxxxxx</a></li>
<li><em>References</em>: &lt;<a href="mailto:20031028012813.GB12968@DOMAIN.HIDDEN">20031028012813.GB12968@xxxxxxxxxxxxxxxxxx</a>&gt; &lt;<a href="mailto:20031028042549.GA10098@DOMAIN.HIDDEN">20031028042549.GA10098@xxxxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>User-agent</em>: Mutt/1.5.4i</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>On Mon, Oct 27, 2003 at 08:25:49PM -0800, Bradd W. Szonye wrote:
&gt; This is Oleg's response, correct?

Yes.

&gt; 
&gt; &gt; Ray Dillinger wrote:
&gt; &gt;&gt; And when joe code writer is looking at the API going, I want
&gt; &gt;&gt; something that applies a function to each mapping, &quot;foreach&quot; is going
&gt; &gt;&gt; to attract his attention.  

&gt; 
&gt; Sure.
&gt; 
&gt; &gt; Should R5RS authors have added BREAK, RETURN and GOTO to Scheme, as CL
&gt; &gt; has done?
&gt; 
&gt; Whoah, hold on? When did Bear suggest that Scott should do this? He was
&gt; suggesting a name that he felt was more intuitive, not proposing a bunch
&gt; of aliases.

He's refering I believe to a more general point related to having only 
enumerators and defining any other paradigm as opposed to providing all 
of them.

&gt; Thing is, there are a few functions like this which have superior
&gt; performance characteristics for *many* collections, if you limit the
&gt; interface somewhat. As you say, there are trade-offs between performance
&gt; and generality. However, there's a significant class of collections --
&gt; any tree-based dictionary, for example -- where you can improve from
&gt; O(N) performance to O(lg N + K) performance for sequential access to
&gt; keys. That's both efficient and generic.

I agree, and I expect a tree implementation of dictionaries to specify 
exactly those operators.  But they don't necessarily extend to 
hashtables, disk file databases, or any number of other dictionary 
mappable datastructures... a set which is larger than the set of Tree 
dictionaries.

&gt; 
&gt; &gt; If I read the intent of SRFI-44 correctly, its goal is not to provide
&gt; &gt; all things for all people. Rather, the goal is to define the framework
&gt; &gt; and to describe a _minimal_ set of core functions plus a _limited_ set
&gt; &gt; of very common extensions.
&gt; 
&gt; And Bear is trying to establish that some of these functions are not
&gt; only common but important extensions. For most dictionary-type
&gt; collections, primitives aren't sufficient. There's a convenience
&gt; argument *and* a performance argument for extending the set.

But only if those operators generalize to all dictionaries.  Otherwise 
they impair the elegance and utility of the API that is general to all 
dictionaries.  We're not outright disagreeing, these operators just need 
to be defined in the SRFI that specifies tree or even just &quot;log n 
efficient indexed dictionaries&quot;.

&gt; 
&gt; &gt; The intent is not to make it unnecessary to add more API in future
&gt; &gt; SRFIs. Rather, the intent is to make it unnecessary to remove SRFI-44
&gt; &gt; features in future SRFIs.
&gt; 
&gt; Why would you need to remove a function that is more convenient and more
&gt; efficient?
Because they may not apply to a hypothetical collection.

&gt; Also, speaking of things which might need to be removed, I'm concerned
&gt; about the object-oriented nature of the containers. Polymorphism is
&gt; good, but I suspect that the SRFI's design may be tied too closely to
&gt; the specific object system used in the reference implementation. For
&gt; example, the hierarchy looks like it's based on a traditional &quot;objects
&gt; as references&quot; class-based system, when an &quot;objects as values&quot;
&gt; prototype-based system may fit better into Scheme. (Especially given the
&gt; way such a system incorporates primitive data structures according to
&gt; content rather than type).

Hardly.  The SRFI was defined before there was even an object system 
selected for the reference implementation.  We were very careful not to 
evey specify polymorphism.  The SRFI only requires that the more general 
functions work for the 'subtypes' of the SRFI.  It never says that the 
collections actually be subtypes in some object system, its just a 
useful metaphor.

&gt; inconsistent with the core language they're supposed to extend.
&gt; 
&gt; &gt; About experience using SRFI-44. I can see how to change my
&gt; &gt; implementation of treaps to fit SRFI-44.
&gt; 
&gt; That's good. Present the implementations as support for the design. The
&gt; author hasn't done so, however -- indeed, he keeps making excuses for
&gt; why he shouldn't have to. That reduces my confidence in the proposal.
&gt; Furthermore, the SRFI Process Document recommends against exactly that
&gt; kind of thing.
&gt; 
You seem to portray this as if I'm hiding some dark secret about 
limitations to the API.  I'm quite confident in the API in fact, and 
just don't believe that I need 'prove' its good to you by writing a 
bunch of code that won't wind up in the SRFI.  I have limited time for 
this SRFI among many many projects, so this is strictly pragmatic.

&gt; 
&gt; &gt; About fold-right. I'd rather wish to see fold-right gone ....
&gt; &gt; Reversible collections is another thing that I'm uneasy about. A
&gt; &gt; concept of views has received quite a lot of attention recently.
&gt; 
&gt; I was thinking the same thing -- container views and enumeration
&gt; adapters would be a much better way to provide some of this stuff. I
&gt; think I mentioned it earlier in the discussion, but I dropped it because
&gt; of the attitude that it's best not to change the SRFI at this point.

Fortunately, collection-fold-right could (if I'm not mistaken) be 
implemented in terms of collection-fold-left and container views.  So 
we're not losing too much by leaving it in.

&gt; &gt; Bradd W. Szonye wrote:
&gt; &gt;&gt; And, most importantly, can you show how to implement a
&gt; &gt;&gt; multiple-collection fold without cursors?
&gt; &gt;&gt;
&gt; &gt;&gt;     (nfold f seed c1 c2 c3 ...)
&gt; 
&gt; &gt; First of all, who said that we should ban cursors completely?
&gt; 
&gt; Have you read the author's replies to our review comments? He dismisses
&gt; them immediately, with a handwave in the general direction of your
&gt; earlier article.

Absolutely not.  I dismissed cursors because I knew they were derivable 
from enumeration.  I said this at least twice and then pointed you to 
the document Oleg initially cited.

&gt; enumerator,&quot; a coroutine designed to traverse the collection efficiently
&gt; (and without any special coding! just a straightforward traversal that
&gt; supplies every value with YIELD). The main FOLD function creates the
&gt; coroutines, grabs a value from each, and calls the folding-function.
&gt; I've already got this implemented. It was almost trivial, once I
&gt; understood how coroutines work.

&gt; Yes, a stable API would be good. My objection is that the SRFI is not a
&gt; stable API. Parts of it are unimplemented, and major sections have
&gt; changed recently. And what's there doesn't take advantage of prior art
&gt; like SRFI-1 and SRFI-13 very well; it reinvents the wheel too much IMO.
&gt; Some elements it did take from SRFI (like linear update functions) are a
&gt; bit controversial -- see the beginner's discussion on c.l.s.

We've already established disagreement on the stability and 
implementation arguments.  Linear update procedures aren't 
controversial.  Whats confusing to new users (but not so much to 
experienced ones) is the naming collision between linear update and 
purely mutable update functions.  Sound familiar?  This is why we had a 
! and !! distinction in the first place.  

&gt; So while I agree that there is value in a stable API, I don't think
&gt; there's any value in rushing an immature API to finalization just so
&gt; that we can call it &quot;stable.&quot; It'd be much better to propose a concrete
&gt; collection or three, get some experience with their use, and it they're
&gt; successful, factor out the interface and publish that as a SRFI.

This is arguably bad design.  Writing many collections and then culling 
the common operators is a great way to wind up with a poorly thought out 
system.  Especially when the stated goal here is to create a general, 
*interoperable* framework for collections.


&gt; Actually, if they're successful, there's less need to publish the
&gt; interface separately. Future developers will imitate it like they
&gt; already imitate SRFI-1. That's a much more desirable outcome: We get
&gt; useful collection types *and* a de facto standard interface that way.
Name one language with a useful generic collections library that got it 
this way?  Java had to competely rewrite its collections library at 1.2 
in order to get a general framework, because the former approach didn't 
work.

	Scott
</pre><p><strong>Attachment:
<a href="pgp4HbaVtST3W.pgp" ><tt>pgp4HbaVtST3W.pgp</tt></a></strong><br>
<em>Description:</em> PGP signature</p>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00170" href="msg00170.html">Re: [oleg@xxxxxxxxx: Interface view of dictionaries]</a></strong>
<ul><li><em>From:</em> Bradd W. Szonye</li></ul></li>
<li><strong><a name="00173" href="msg00173.html">Re: [oleg@xxxxxxxxx: Interface view of dictionaries]</a></strong>
<ul><li><em>From:</em> bear</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00165" href="msg00165.html">[oleg@xxxxxxxxx: Interface view of dictionaries]</a></strong>
<ul><li><em>From:</em> scgmille</li></ul></li>
<li><strong><a name="00167" href="msg00167.html">Re: [oleg@xxxxxxxxx: Interface view of dictionaries]</a></strong>
<ul><li><em>From:</em> Bradd W. Szonye</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00168.html">Re: Interface view of dictionaries</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00170.html">Re: [oleg@xxxxxxxxx: Interface view of dictionaries]</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00167.html">Re: [oleg@xxxxxxxxx: Interface view of dictionaries]</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00170.html">Re: [oleg@xxxxxxxxx: Interface view of dictionaries]</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00169"><strong>Date</strong></a></li>
<li><a href="threads.html#00169"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
