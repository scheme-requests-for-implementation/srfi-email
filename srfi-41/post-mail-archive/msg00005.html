<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: [Chicken&#45;users] Which eggs to migrate from Chicken 3 first? -->
<!--X-From-R13: Buvy Prjvt <corjvtNtznvy.pbz> -->
<!--X-Date: Wed,  6 May 2009 14:32:39 +0000 (UTC) -->
<!--X-Message-Id: da4fbdb30905060732x5604d8f8n8776ae926d99abc6@mail.gmail.com -->
<!--X-Content-Type: multipart/alternative -->
<!--X-Reference: 20090422161112.GA721@mercury.ccil.org -->
<!--X-Reference: da4fbdb30904220916y46def0e6y48d69ebbe2a679d2@mail.gmail.com -->
<!--X-Reference: 20090506021620.GR11542@freaks&#45;unidos.net -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: [Chicken-users] Which eggs to migrate from Chicken 3 first?</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00004.html">Date Prev</a>][<a href="msg00006.html">Date Next</a>][<a href="msg00004.html">Thread Prev</a>][<a href="msg00006.html">Thread Next</a>][<a href="maillist.html#00005">Date Index</a>][<a href="threads.html#00005">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: [Chicken-users] Which eggs to migrate from Chicken 3 first?</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: Alejandro Forero Cuervo &lt;<a href="mailto:azul@DOMAIN.HIDDEN">azul@xxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Subject</em>: Re: [Chicken-users] Which eggs to migrate from Chicken 3 first?</li>
<li><em>From</em>: Phil Bewig &lt;<a href="mailto:pbewig@DOMAIN.HIDDEN">pbewig@xxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Wed, 6 May 2009 09:32:35 -0500</li>
<li><em>Cc</em>: <a href="mailto:srfi-41@DOMAIN.HIDDEN">srfi-41@xxxxxxxxxxxxxxxxx</a>, <a href="mailto:chicken-users@DOMAIN.HIDDEN">chicken-users@xxxxxxxxxx</a></li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-41@DOMAIN.HIDDEN">srfi-41@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Dkim-signature</em>: v=1; a=rsa-sha256; c=relaxed/relaxed;        d=gmail.com; s=gamma;        h=domainkey-signature:mime-version:received:in-reply-to:references         :date:message-id:subject:from:to:cc:content-type;        bh=N+DA2zcR8/8+jvhh0EjGcH1tkvXE07H5nSNM7aaDehA=;        b=iHP2JYNZ8GcvQfISAqDDWa4+MufS6gfy5ICu3lXS3UnxDC37wSI9C03CzmgLMkHpq8         gm+GuAm4MXLxI2Dr7sr8dpL8S3UJTxH5f4FP0/Lj75Z4YV2UZEaxwLmPUQ9vIZl/vpk4         Dj3mQaqXXFi/ClYuy14xbfnDTa3cGe69d6dK0=</li>
<li><em>Domainkey-signature</em>: a=rsa-sha1; c=nofws;        d=gmail.com; s=gamma;        h=mime-version:in-reply-to:references:date:message-id:subject:from:to         :cc:content-type;        b=Fa+OgutN7GbfP+c42ofY5gX/3zmTF99R5wud6fEJCsLE+ze6WVTO6ccqFQRxOgSI0u         xebTpv9D3z8MjqWUwrgxJsysPoQ/elsvJgF8S/kF3+tfWdyUkOcuJQ2O9T8HILASRHIN         Yt/le/6E4jaLEVFKnN553Vr7CLph75obhrd9A=</li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:20090506021620.GR11542@DOMAIN.HIDDEN">20090506021620.GR11542@xxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>References</em>: &lt;<a href="mailto:20090422161112.GA721@DOMAIN.HIDDEN">20090422161112.GA721@xxxxxxxxxxxxxxxx</a>&gt;	 &lt;<a href="mailto:da4fbdb30904220916y46def0e6y48d69ebbe2a679d2@DOMAIN.HIDDEN">da4fbdb30904220916y46def0e6y48d69ebbe2a679d2@xxxxxxxxxxxxxx</a>&gt;	 &lt;<a href="mailto:20090506021620.GR11542@DOMAIN.HIDDEN">20090506021620.GR11542@xxxxxxxxxxxxxxxxx</a>&gt;</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
I did not consider the stream-ext library in the design of SRFI-41.&#xA0; In general, as explained in the SRFI, I designed SRFI-41 according to the advice of Antoine de Saint-Exup&#xE9;ry: <i>&quot;Il semble que la perfection soit atteinte non quand il n&#x2019;y a plus rien &#xE0; ajouter, mais quand il n&#x2019;y a plus rien &#xE0; retrancher</i>.&quot;&#xA0; (&#x201C;Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away.&#x201D;)&#xA0; And I think I got a couple of things wrong -- if I was to rewrite SRFI-41 today, I would take away even more.<br>

<br>Streams are not lists.&#xA0; Scheme ensures there are substantial disadvantages to using streams rather than lists, due to the underlying promises that require numerous type conversions, so streams should be used only when the sequence of elements is truly infinite (such as mathematical series) or when there is some clear advantage of laziness (such as reducing the number of passes through a large data set).&#xA0; Writing a library that duplicates SRFI-1 for streams seems to me to be folly.<br>

<br>I looked briefly at your list of suggested extensions.&#xA0; A few may be useful for a modest extension library, if you have in mind a particular set of uses --&#xA0; some of the examples in the SRFI, such as stream-partition, fall into this category.&#xA0; Some certainly don&#39;t belong in a general-purpose library -- if you need symbol-&gt;stream to convert the name of a symbol into a stream of characters, you can write it as part of your program.&#xA0; Many -- such as stream-butlast -- make sense only for lists (which are materialized in their entirety) and not for streams (which may never be materialized).&#xA0; I find it amusing that you consider stream-&gt;vector and vector-&gt;stream, since the pure FP people have such trouble with mutable arrays.&#xA0; And even the design is poor -- stream-butlast-n should almost certainly be merged into stream-butlast with an optional argument, but stream-reverse shouldn&#39;t also optionally append a list (or is it a stream?).<br>

<br>You say that it is so obvious that all these functions should be included that you won&#39;t waste your time justifying it, but to me it is anything but obvious -- in fact, it is obvious to me that some of the functions you mentioned should never exist in the context of streams implemented for Scheme, much less be included in a standard library.&#xA0; On the other hand, in the context of streams implemented for Haskell, it may make sense to include some of the list-oriented functions, since Haskell has no finite-list type and uses streams in its place.&#xA0; Remember: streams are not lists.<br>

<br>You are of course free to use SRFI-41 as the basis for an extended library of stream functions.&#xA0; I ask only that you do not call it streams, or streams-primitive, or streams-derived, so as not to cause confusion with the SRFI.&#xA0; I also recommend that you switch over as soon as possible from the deprecated SRFI-40 to SRFI-41.<br>

<br>By the way, you should have mentioned as you critiqued SRFI-41 that you are the author of stream-ext.<br><br>Phil<br><br><div class="gmail_quote">On Tue, May 5, 2009 at 9:16 PM, Alejandro Forero Cuervo <span dir="ltr">&lt;<a rel="nofollow" href="mailto:azul@xxxxxxxxxxxxxxxxx" target="_blank">azul@xxxxxxxxxxxxxxxxx</a>&gt;</span> wrote:<br>

<blockquote class="gmail_quote" style="border-left: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;"><div>&gt; SRFI-40 is deprecated due to a memory leak. &#xA0;Please port SRFI-41 instead,<br>

&gt; and adapt any code that uses SRFI-40 to the new interface.<br>
<br>
</div>Did you, during the design of srfi-41, consider the existance of the<br>
stream-ext library, which implements a lot of stream functions on top<br>
of srfi-40?<br>
<br>
<a rel="nofollow" href="http://chicken.wiki.br/eggref/3/stream-ext" target="_blank">http://chicken.wiki.br/eggref/3/stream-ext</a><br>
<br>
It&#39;s first version was released a long time before srfi-41 and only<br>
small changes have been made since then. &#xA0;The naming conventions and<br>
the semantics match those of srfi-1 as close as possible, to make<br>
things as consistent as possible.<br>
<br>
I&#39;ve used the stream-ext library in many applications that represent<br>
strings as streams of characters throughout. &#xA0;The largest of these is<br>
probably Svnwiki.<br>
<br>
I&#39;m worried about the incompatibilities I see between stream-ext and<br>
srfi-41. &#xA0;My concerns are the following:<br>
<br>
1. srfi-41 provides a very small subset of the functionality that I<br>
think that any program that uses streams significantly will need. &#xA0;As<br>
such, I think it fails significantly at providing &quot;syntax derived from<br>
those primitives that permits convenient _expression_ of stream<br>
operations&quot;. &#xA0;Most of the functions I list below can be implemented in<br>
a portable manner, as stream-ext does. &#xA0;To be fair, srfi-41 does seem<br>
to provide some functions that stream-ext does not.<br>
<br>
2. More importantly (the previous concern can be solved with an<br>
additional library), a small portion of the interface exported by<br>
srfi-41 differs from that in the stream-ext library. &#xA0;I provide some<br>
cases below and explain why I believe the semantics from stream-ext<br>
are slightly preferable, mostly because of consistency with the srfi-1<br>
list-based counterparts. &#xA0;I quite like the interface of srfi-1 and I<br>
find that, by providing inconsistent counterparts, srfi-41 is making<br>
it slightly harder to use streams than stream-ext.<br>
<br>
I may be the person who has written the most Scheme code using srfi-40<br>
streams. &#xA0;I&#39;ve put special care into the design of the interface of<br>
the stream-ext library. &#xA0;This interest I have in using streams in<br>
Scheme makes the fact that srfi-41 offers an inferior interface rather<br>
frustrating for me.<br>
<br>
Now onto the differences and similarities:<br>
<br>
The following is a list of symbols provided by stream-ext and srfi-41<br>
with apparently the exact same semantics:<br>
<br>
 &#xA0;list-&gt;stream<br>
 &#xA0;stream-ref<br>
 &#xA0;stream-length<br>
 &#xA0;stream-append<br>
 &#xA0;stream-take-while<br>
 &#xA0;stream-drop-while<br>
<br>
The following is a list of symbols available in stream-ext but not in<br>
srfi-41, which I believe most software using streams would benefit<br>
from:<br>
<br>
 &#xA0;stream-xcons<br>
 &#xA0;stream-cons*<br>
 &#xA0;stream-tabulate<br>
 &#xA0;stream-iota<br>
 &#xA0;make-infinite-stream<br>
<br>
 &#xA0; &#xA0;I think these should be included as counterparts to the srfi-1<br>
 &#xA0; &#xA0;versions for lists. &#xA0;The make-infinite-stream should probably be<br>
 &#xA0; &#xA0;added (see stream-ext&#39;s make-stream, discussed bellow).<br>
<br>
 &#xA0;stream-&gt;string<br>
 &#xA0;string-&gt;stream<br>
 &#xA0;stream-downcase, stream-upcase<br>
 &#xA0;stream-lines<br>
 &#xA0;stream-unlines<br>
<br>
 &#xA0; &#xA0;I think these should be included: if one does include<br>
 &#xA0; &#xA0;port-&gt;stream, encouraging the use of streams of characters to<br>
 &#xA0; &#xA0;represent ports/streams, why not go the extra mile of simplifying<br>
 &#xA0; &#xA0;conversion to and from strings and handling of streams of<br>
 &#xA0; &#xA0;characters?<br>
<br>
 &#xA0;stream-&gt;vector<br>
 &#xA0;vector-&gt;stream<br>
 &#xA0;number-&gt;stream<br>
 &#xA0;stream-&gt;number<br>
 &#xA0;stream-&gt;symbol<br>
 &#xA0;symbol-&gt;stream<br>
<br>
 &#xA0; &#xA0;And if we include the stream-&gt;string and string-&gt;stream symbols,<br>
 &#xA0; &#xA0;encouraging the programmer to use streams throughout his program<br>
 &#xA0; &#xA0;to represent strings, these should probably also be included,<br>
 &#xA0; &#xA0;specially the vector ones. &#xA0;I don&#39;t think we should force all<br>
 &#xA0; &#xA0;programs that use streams to define this compositions directly.<br>
<br>
 &#xA0;iterator-&gt;stream<br>
<br>
 &#xA0; &#xA0;This is a fundamental block for turning iterators into streams.<br>
 &#xA0; &#xA0;I&#39;ve found it extremely useful in my programs that use streams.<br>
 &#xA0; &#xA0;For example, list-&gt;stream can be trivially implemented as:<br>
<br>
 &#xA0; &#xA0; &#xA0;(define (list-&gt;stream l)<br>
 &#xA0; &#xA0; &#xA0; &#xA0;(iterator-&gt;stream<br>
 &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;(lambda (return stop)<br>
 &#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;(for-each return l))))<br>
<br>
 &#xA0; &#xA0;Among *many* other things, this makes it trivial to do things like<br>
 &#xA0; &#xA0;&#39;with-output-to-stream&#39;, given the right support from the<br>
 &#xA0; &#xA0;implementation (for creating special ports). &#xA0;Also,<br>
 &#xA0; &#xA0;iterator-&gt;stream does not depend on anything non-portable, simply<br>
 &#xA0; &#xA0;on call/cc.<br>
<br>
 &#xA0;write-stream<br>
<br>
 &#xA0; &#xA0;The counter-part to port-&gt;stream. &#xA0;Most of my programs have a lot<br>
 &#xA0; &#xA0;of functions that generate streams (see for example my html-stream<br>
 &#xA0; &#xA0;library). &#xA0;A lot of these will be wrapped in a simple call to<br>
 &#xA0; &#xA0;write-stream, to output these to the right port. &#xA0;I think it<br>
 &#xA0; &#xA0;should be included in a general purpose streams library.<br>
<br>
 &#xA0;stream=<br>
 &#xA0;stream-prefix=<br>
 &#xA0;stream&gt;, stream&lt;<br>
 &#xA0;stream-caar ... stream-cddddr<br>
 &#xA0;stream-first ... stream-tenth<br>
 &#xA0;stream-intersperse<br>
 &#xA0;stream-split<br>
 &#xA0;stream-last<br>
 &#xA0;stream-last-n<br>
 &#xA0;stream-butlast<br>
 &#xA0;stream-butlast-n<br>
 &#xA0;stream-length&gt;=<br>
 &#xA0;stream-count<br>
 &#xA0;stream-partition<br>
 &#xA0;stream-remove<br>
 &#xA0;stream-sort<br>
 &#xA0;stream-find<br>
 &#xA0;stream-find-tail<br>
 &#xA0;stream-any<br>
 &#xA0;stream-every<br>
<br>
 &#xA0; &#xA0;I&#39;m using all these quite often. &#xA0;I feel all of them deserve<br>
 &#xA0; &#xA0;inclussion in a general purpose for construction of streams. &#xA0;I<br>
 &#xA0; &#xA0;think this is obvious enough that I won&#39;t waste my time justifying<br>
 &#xA0; &#xA0;it. &#xA0;If you think a given one of these should not be included, ask<br>
 &#xA0; &#xA0;me and I&#39;ll explain why I think it should.<br>
<br>
 &#xA0; &#xA0;I find it a bit surprising that stream-partition, stream-remove,<br>
 &#xA0; &#xA0;stream-find and stream-sort were not included in the library, even<br>
 &#xA0; &#xA0;though they were considered general enough that they were defined<br>
 &#xA0; &#xA0;as examples (though stream-sort is implemented using merge-sort).<br>
<br>
 &#xA0;with-output-to-stream<br>
<br>
 &#xA0; &#xA0;Very convenient for turning code that generates output to its<br>
 &#xA0; &#xA0;current-output-port into code that builds a (lazy, obviously)<br>
 &#xA0; &#xA0;stream. &#xA0;However, I suppose this can&#39;t be implemented in a<br>
 &#xA0; &#xA0;portable manner. :-/<br>
<br>
 &#xA0;with-input-from-stream<br>
<br>
 &#xA0; &#xA0;The rationale is very similar to that of with-output-to-stream.<br>
 &#xA0; &#xA0;However, I&#39;ve found this procedure a bit less useful than the<br>
 &#xA0; &#xA0;other.<br>
<br>
The following is a list of symbols provided by stream-ext with<br>
semantics incompatible with those of srfi-41. &#xA0;I believe the<br>
definition in stream-ext is more adequate for the reasons I explain.<br>
<br>
 &#xA0;make-stream<br>
<br>
 &#xA0; &#xA0;stream-ext&#39;s definition matches the counterpart from srfi-1&#39;s<br>
 &#xA0; &#xA0;make-list. &#xA0;srfi-41 defines this but, fortunately, does not export<br>
 &#xA0; &#xA0;it.<br>
<br>
 &#xA0;stream-&gt;list<br>
<br>
 &#xA0; &#xA0;I don&#39;t like the idea of the optional number-of-elements<br>
 &#xA0; &#xA0;arguments. &#xA0;This should simply work only on finite streams (and<br>
 &#xA0; &#xA0;one should use stream-take for infinite streams). &#xA0;I think<br>
 &#xA0; &#xA0;stream-ext&#39;s definition is more adequate as it more commonly<br>
 &#xA0; &#xA0;reflects the expectation from the programmer (of just converting a<br>
 &#xA0; &#xA0;stream to its corresponding list); taking the head of the list<br>
 &#xA0; &#xA0;should not be done by this function. &#xA0;I also tend to dislike<br>
 &#xA0; &#xA0;optional parameters preceeding mandatory parameters.<br>
<br>
 &#xA0;port-&gt;stream<br>
<br>
 &#xA0; &#xA0;The interface described in srfi-41 is a subset of that in<br>
 &#xA0; &#xA0;stream-ext: stream-ext adds two optional parameters that make this<br>
 &#xA0; &#xA0;procedure a lot more flexible/usable, without any disadvantages.<br>
<br>
 &#xA0;stream-take, stream-take-safe<br>
 &#xA0;stream-drop, stream-drop-safe<br>
<br>
 &#xA0; &#xA0;These are *almost* compatible. &#xA0;The only difference is that, in<br>
 &#xA0; &#xA0;consistence with srfi-1, I&#39;ve decided to make it an error to take<br>
 &#xA0; &#xA0;more elements than the stream has. &#xA0;srfi-41, instead, has decided<br>
 &#xA0; &#xA0;to not make it an error. &#xA0;I prefer the stream-ext behavior simply<br>
 &#xA0; &#xA0;for being consistent with what the srfi-1 counterparts do. &#xA0;I want<br>
 &#xA0; &#xA0;to make the streams and lists libraries as compatible as possible.<br>
<br>
 &#xA0;stream-concatenate<br>
<br>
 &#xA0; &#xA0;srfi-41 decided to call this stream-concat, which is inconsistent<br>
 &#xA0; &#xA0;with srfi-1. &#xA0;I prefer stream-ext&#39;s consistent naming convention.<br>
<br>
 &#xA0;stream-reverse<br>
<br>
 &#xA0; &#xA0;This is *almost* compatible, but stream-ext allows the caller to<br>
 &#xA0; &#xA0;pass a list to be appended to the result, which I think makes the<br>
 &#xA0; &#xA0;procedure slightly more useful.<br>
<br>
The following are other symbols in stream-ext that I haven&#39;t had time<br>
to compare with those in srfi-41:<br>
<br>
 &#xA0;stream-fold<br>
 &#xA0;stream-fold-right<br>
 &#xA0;stream-fold-right-delay<br>
 &#xA0;stream-span, stream-break<br>
 &#xA0;stream-index<br>
 &#xA0;stream-member, stream-memq, stream-memv<br>
 &#xA0;stream-format<br>
 &#xA0;stream-delete<br>
 &#xA0;stream-delete-duplicates<br>
<br>
I suspect the fold procedures provided by stream-ext are far more<br>
usable than those in srfi-41, but, as I said, I haven&#39;t had time to<br>
compare them.<br>
<br>
The following are symbols in srfi-41 and not in srfi-40 that I haven&#39;t<br>
had time to compare with those in stream-ext:<br>
<br>
 &#xA0;stream-lambda<br>
 &#xA0;define-stream<br>
 &#xA0;stream-constant<br>
 &#xA0;stream-fold<br>
 &#xA0;stream-from<br>
 &#xA0;stream-iterate<br>
 &#xA0;stream-let<br>
 &#xA0;stream-match<br>
 &#xA0;stream-of<br>
 &#xA0;stream-range<br>
 &#xA0;stream-scan<br>
 &#xA0;stream-unfold<br>
 &#xA0;stream-unfolds<br>
 &#xA0;stream-zip<br>
<br>
Thanks.<br>
<br>
Alejo.<br>
<a rel="nofollow" href="http://azul.freaks-unidos.net/" target="_blank">http://azul.freaks-unidos.net/</a><br>
</blockquote></div><br>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00006" href="msg00006.html">Re: [Chicken-users] Which eggs to migrate from Chicken 3 first?</a></strong>
<ul><li><em>From:</em> Alexey Radul</li></ul></li>
<li><strong><a name="00009" href="msg00009.html">Re: [Chicken-users] Which eggs to migrate from Chicken 3 first?</a></strong>
<ul><li><em>From:</em> Alex Shinn</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00004.html">Stream-member</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00006.html">Re: [Chicken-users] Which eggs to migrate from Chicken 3 first?</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00004.html">Stream-member</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00006.html">Re: [Chicken-users] Which eggs to migrate from Chicken 3 first?</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00005"><strong>Date</strong></a></li>
<li><a href="threads.html#00005"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
