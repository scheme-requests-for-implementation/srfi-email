<!-- MHonArc v2.6.16 -->
<!--X-Subject: [PATCH] Important fix and HTML markup improvements -->
<!--X-From-R13: [nex V Irnire <zujNargevf.bet> -->
<!--X-Date: Wed, 31 Oct 2012 09:24:15 +0000 (UTC) -->
<!--X-Message-Id: 87txtbm1uu.fsf@tines.lan -->
<!--X-Content-Type: multipart/mixed -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>[PATCH] Important fix and HTML markup improvements</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00167.html">Date Prev</a>][<a href="msg00169.html">Date Next</a>][<a href="msg00162.html">Thread Prev</a>][<a href="msg00169.html">Thread Next</a>][<a href="maillist.html#00168">Date Index</a>][<a href="threads.html#00168">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>[PATCH] Important fix and HTML markup improvements</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: &quot;David A. Wheeler&quot; &lt;<a href="mailto:dwheeler@DOMAIN.HIDDEN">dwheeler@xxxxxxxxxxxx</a>&gt;</li>
<li><em>Subject</em>: [PATCH] Important fix and HTML markup improvements</li>
<li><em>From</em>: Mark H Weaver &lt;<a href="mailto:mhw@DOMAIN.HIDDEN">mhw@xxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Wed, 31 Oct 2012 05:23:37 -0400</li>
<li><em>Cc</em>: <a href="mailto:srfi-105@DOMAIN.HIDDEN">srfi-105@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-105@DOMAIN.HIDDEN">srfi-105@xxxxxxxxxxxxxxxxx</a></li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>The current draft says:
&gt; 5. An unprefixed ( . e) MUST evaluate as e.

s/MUST evaluate as/MUST be read as/

I've attached a patch which fixes this, and also improves the HTML
markup.  Most notably, I converted many VAR elements to CODE elements,
e.g. every occurrence of $nfx$ and $bracket-apply$, since these are not
variables for purposes of this specification, but rather constant
symbols.

I used VAR for symbols that can stand for any of a set of expressions
(e.g. 'e', 'e1', and 'e2' in the n-expression spec), which I believe is
a more appropriate use of VAR.  I also tried to use CODE and SAMP where
appropriate, and avoided marking ellipses with either one.

What do you think?

    Regards,
      Mark


</pre><pre>--- srfi-105.html	2012-10-30 23:50:56.694669579 -0400
+++ srfi-105-new.html	2012-10-31 04:55:27.762946812 -0400
@@ -92,13 +92,13 @@
 maps cleanly to
 &lt;samp&gt;(+&amp;nbsp;x&amp;nbsp;(*&amp;nbsp;y&amp;nbsp;z))&lt;/samp&gt;.
 Forms with mixed infix operators and other complications have
-&amp;#8220;&lt;var&gt;$nfx$&lt;/var&gt;&amp;#8221; prepended to
+&amp;#8220;&lt;code&gt;$nfx$&lt;/code&gt;&amp;#8221; prepended to
 enable later macro processing, e.g.,
 &lt;samp&gt;{4&amp;nbsp;+&amp;nbsp;5&amp;nbsp;*&amp;nbsp;6}&lt;/samp&gt; &amp;#8658;
 &lt;samp&gt;($nfx$&amp;nbsp;4&amp;nbsp;+&amp;nbsp;5&amp;nbsp;*&amp;nbsp;6)&lt;/samp&gt;.
 Also, inside a curly-infix list (recursively),
-expressions of the form &lt;samp&gt;f(...)&lt;/samp&gt; are simply
-an abbreviation for &lt;samp&gt;(f&amp;nbsp;...)&lt;/samp&gt;.&lt;/p&gt;
+expressions of the form &lt;code&gt;&lt;var&gt;f&lt;/var&gt;(&lt;/code&gt;...&lt;code&gt;)&lt;/code&gt; are simply
+an abbreviation for &lt;code&gt;(&lt;var&gt;f&lt;/var&gt;&amp;nbsp;&lt;/code&gt;...&lt;code&gt;)&lt;/code&gt;.&lt;/p&gt;
 
 &lt;p&gt;Note that this is derived from the
 &amp;#8220;&lt;a href=&quot;<a  rel="nofollow" href="http://readable.sourceforge.net/&quot">http://readable.sourceforge.net/&quot</a>;&gt;readable&lt;/a&gt;&amp;#8221;
@@ -151,9 +151,9 @@
 the &lt;em&gt;simple&lt;/em&gt; curly-infix list,
 a list whose visual presentation is in infix order instead of prefix order.
 The simple curly-infix list
-&lt;samp&gt;{operand-1 operator operand-2 operator operand-3 operator ...}&lt;/samp&gt;
+&lt;samp&gt;{&lt;var&gt;operand-1&lt;/var&gt; &lt;var&gt;operator&lt;/var&gt; &lt;var&gt;operand-2&lt;/var&gt; &lt;var&gt;operator&lt;/var&gt; &lt;var&gt;operand-3&lt;/var&gt; &lt;var&gt;operator&lt;/var&gt; &lt;/samp&gt;...&lt;samp&gt;}&lt;/samp&gt;
 is mapped to
-&lt;samp&gt;(operator operand-1 operand-2 operand-3 ...)&lt;/samp&gt; so that two or
+&lt;samp&gt;(&lt;var&gt;operator&lt;/var&gt; &lt;var&gt;operand-1&lt;/var&gt; &lt;var&gt;operand-2&lt;/var&gt; &lt;var&gt;operand-3&lt;/var&gt; &lt;/samp&gt;...&lt;samp&gt;)&lt;/samp&gt; so that two or
 more operands are handled cleanly.
 E.g., &lt;samp&gt;{a&amp;nbsp;+&amp;nbsp;b&amp;nbsp;+&amp;nbsp;c}&lt;/samp&gt; &amp;#8658;
 &lt;samp&gt;(+&amp;nbsp;a&amp;nbsp;b&amp;nbsp;c)&lt;/samp&gt;.&lt;/p&gt;
@@ -195,11 +195,11 @@
 &lt;ol&gt;
 &lt;li&gt;A &lt;dfn&gt;simple&lt;/dfn&gt; curly-infix list has an odd number of
 parameters, at least three parameters, and all even parameters are
-&amp;#8220;&lt;var&gt;equal?&lt;/var&gt;&amp;#8221;.
+&amp;#8220;&lt;code&gt;equal?&lt;/code&gt;&amp;#8221;.
 If there is more than one even parameter, and
 an even parameter contains a cycle, then
-the &lt;var&gt;equal?&lt;/var&gt; comparison &lt;em&gt;MUST&lt;/em&gt; terminate
-if &lt;var&gt;equal?&lt;/var&gt; terminates (otherwise
+the &lt;code&gt;equal?&lt;/code&gt; comparison &lt;em&gt;MUST&lt;/em&gt; terminate
+if &lt;code&gt;equal?&lt;/code&gt; terminates (otherwise
 the comparison &lt;em&gt;MAY&lt;/em&gt; terminate).
 A simple curly-infix list is mapped by
 the reader into a list with the first even parameter
@@ -211,26 +211,26 @@
 &lt;samp&gt;{4&amp;nbsp;*&amp;nbsp;5&amp;nbsp;*&amp;nbsp;6}&lt;/samp&gt; &amp;#8658;
 &lt;samp&gt;(*&amp;nbsp;4&amp;nbsp;5&amp;nbsp;6)&lt;/samp&gt;.&lt;/li&gt;
 &lt;li&gt;The &lt;dfn&gt;empty&lt;/dfn&gt; curly-infix list
-&lt;samp&gt;{}&lt;/samp&gt; is mapped to the empty list &lt;samp&gt;()&lt;/samp&gt;.
+&lt;code&gt;{}&lt;/code&gt; is mapped to the empty list &lt;code&gt;()&lt;/code&gt;.
 An implementation &lt;em&gt;MUST&lt;/em&gt; permit, and not require,
 whitespace between the braces in an empty curly-infix list.&lt;/li&gt;
 &lt;li&gt;An &lt;dfn&gt;escaping&lt;/dfn&gt; curly-infix list
-&lt;samp&gt;{e}&lt;/samp&gt; is mapped to &lt;samp&gt;e&lt;/samp&gt;.
+&lt;code&gt;{&lt;var&gt;e&lt;/var&gt;}&lt;/code&gt; is mapped to &lt;code&gt;&lt;var&gt;e&lt;/var&gt;&lt;/code&gt;.
 E.g., &lt;samp&gt;{5}&lt;/samp&gt; is mapped to &lt;samp&gt;5&lt;/samp&gt;.&lt;/li&gt;
 &lt;li&gt;A &lt;dfn&gt;unary-operation&lt;/dfn&gt; curly-infix list
-&lt;samp&gt;{e1&amp;nbsp;e2}&lt;/samp&gt;
+&lt;code&gt;{&lt;var&gt;e1&lt;/var&gt;&amp;nbsp;&lt;var&gt;e2&lt;/var&gt;}&lt;/code&gt;
 is mapped to
-&lt;samp&gt;(e1&amp;nbsp;e2)&lt;/samp&gt;.
+&lt;code&gt;(&lt;var&gt;e1&lt;/var&gt;&amp;nbsp;&lt;var&gt;e2&lt;/var&gt;)&lt;/code&gt;.
 E.g.,
 &lt;samp&gt;{-&amp;nbsp;x}&lt;/samp&gt; &amp;#8658;
 &lt;samp&gt;(-&amp;nbsp;x)&lt;/samp&gt;.&lt;/li&gt;
 &lt;li&gt;The mapping of a curly-infix list beginning with the symbol
-&amp;#8220;&lt;var&gt;.&lt;/var&gt;&amp;#8221; is unspecified.
+&amp;#8220;&lt;code&gt;.&lt;/code&gt;&amp;#8221; is unspecified.
 (Note: the reference implementation maps
-&lt;samp&gt;{.&amp;nbsp;e}&lt;/samp&gt; to &lt;samp&gt;e&lt;/samp&gt;.)
+&lt;code&gt;{.&amp;nbsp;&lt;var&gt;e&lt;/var&gt;}&lt;/code&gt; to &lt;code&gt;&lt;var&gt;e&lt;/var&gt;&lt;/code&gt;.)
 &lt;/li&gt;
 &lt;li&gt;Any other curly-infix list (including all other improper lists) is
-&lt;dfn&gt;mixed&lt;/dfn&gt;.  A mixed curly-infix list &lt;em&gt;MUST&lt;/em&gt; be mapped to that list with &amp;#8220;&lt;var&gt;$nfx$&lt;/var&gt;&amp;#8221; added to its front.
+&lt;dfn&gt;mixed&lt;/dfn&gt;.  A mixed curly-infix list &lt;em&gt;MUST&lt;/em&gt; be mapped to that list with &amp;#8220;&lt;code&gt;$nfx$&lt;/code&gt;&amp;#8221; added to its front.
 E.g.,
 &lt;samp&gt;{q&amp;nbsp;+&amp;nbsp;r&amp;nbsp;*&amp;nbsp;s}&lt;/samp&gt;
 is mapped to
@@ -271,8 +271,8 @@
 &lt;/p&gt;
 &lt;ol&gt;
 &lt;li&gt;
-&lt;samp&gt;e(...)&lt;/samp&gt; &amp;#8658;
-&lt;samp&gt;(e&amp;nbsp;...)&lt;/samp&gt;.
+&lt;code&gt;&lt;var&gt;e&lt;/var&gt;(&lt;/code&gt;...&lt;code&gt;)&lt;/code&gt; &amp;#8658;
+&lt;code&gt;(&lt;var&gt;e&lt;/var&gt;&amp;nbsp;&lt;/code&gt;...&lt;code&gt;)&lt;/code&gt;.
 E.g.,
 &lt;samp&gt;cos(x)&lt;/samp&gt; &amp;#8658;
 &lt;samp&gt;(cos&amp;nbsp;x)&lt;/samp&gt;,
@@ -283,11 +283,11 @@
 &lt;samp&gt;read(.&amp;nbsp;options)&lt;/samp&gt; &amp;#8658;
 &lt;samp&gt;(read&amp;nbsp;.&amp;nbsp;options)&lt;/samp&gt;.&lt;/li&gt;
 &lt;li&gt;
-&lt;samp&gt;e{}&lt;/samp&gt; &amp;#8658; &lt;samp&gt;(e)&lt;/samp&gt;
+&lt;code&gt;&lt;var&gt;e&lt;/var&gt;{}&lt;/code&gt; &amp;#8658; &lt;code&gt;(&lt;var&gt;e&lt;/var&gt;)&lt;/code&gt;
 when there are zero or more whitespace characters
 within the braces;
 otherwise,
-&lt;samp&gt;e{...}&lt;/samp&gt; &amp;#8658; &lt;samp&gt;(e&amp;nbsp;{...})&lt;/samp&gt;.
+&lt;code&gt;&lt;var&gt;e&lt;/var&gt;{&lt;/code&gt;...&lt;code&gt;}&lt;/code&gt; &amp;#8658; &lt;code&gt;(&lt;var&gt;e&lt;/var&gt;&amp;nbsp;{&lt;/code&gt;...&lt;code&gt;})&lt;/code&gt;.
 E.g.,
 &lt;samp&gt;f{n&amp;nbsp;-&amp;nbsp;1}&lt;/samp&gt;
 &amp;#8658;
@@ -298,12 +298,12 @@
 &lt;samp&gt;g{-&amp;nbsp;x}&lt;/samp&gt;
 &amp;#8658;
 &lt;samp&gt;(g&amp;nbsp;(-&amp;nbsp;x))&lt;/samp&gt;.&lt;/li&gt;
-&lt;li&gt;&lt;samp&gt;e[...]&lt;/samp&gt; &amp;#8658;
-&lt;samp&gt;($bracket-apply$&amp;nbsp;e&amp;nbsp;...)&lt;/samp&gt;&lt;/li&gt;
+&lt;li&gt;&lt;code&gt;&lt;var&gt;e&lt;/var&gt;[&lt;/code&gt;...&lt;code&gt;]&lt;/code&gt; &amp;#8658;
+&lt;code&gt;($bracket-apply$&amp;nbsp;&lt;var&gt;e&lt;/var&gt;&amp;nbsp;&lt;/code&gt;...&lt;code&gt;)&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt;The above mappings &lt;em&gt;MUST NOT&lt;/em&gt; be applied
 if one or more whitespace characters are present between e and the open
 paired character.&lt;/li&gt;
-&lt;li&gt;An unprefixed &lt;samp&gt;(&amp;nbsp;.&amp;nbsp;e)&lt;/samp&gt; &lt;em&gt;MUST&lt;/em&gt; evaluate as &lt;samp&gt;e&lt;/samp&gt;.&lt;/li&gt;
+&lt;li&gt;An unprefixed &lt;code&gt;(&amp;nbsp;.&amp;nbsp;&lt;var&gt;e&lt;/var&gt;)&lt;/code&gt; &lt;em&gt;MUST&lt;/em&gt; be read as &lt;code&gt;&lt;var&gt;e&lt;/var&gt;&lt;/code&gt;.&lt;/li&gt;
 &lt;li&gt;
 These &lt;em&gt;MUST&lt;/em&gt; recurse within lists and vectors,
 so any list or vector
@@ -515,8 +515,8 @@
 
 &lt;p&gt;
 An implementation of this SRFI &lt;em&gt;MUST&lt;/em&gt; accept
-the marker &lt;var&gt;#!curly-infix&lt;/var&gt; followed by a whitespace character
-in its standard datum readers (e.g., &lt;var&gt;read&lt;/var&gt; and, if applicable,
+the marker &lt;code&gt;#!curly-infix&lt;/code&gt; followed by a whitespace character
+in its standard datum readers (e.g., &lt;code&gt;read&lt;/code&gt; and, if applicable,
 the default implementation REPL).
 This marker (including the trailing whitespace character)
 &lt;em&gt;MUST&lt;/em&gt; be consumed and considered whitespace.
@@ -542,13 +542,13 @@
 &lt;p&gt;
 An implementation &lt;em&gt;MUST NOT&lt;/em&gt;
 bind the symbols
-&amp;#8220;&lt;var&gt;$nfx$&lt;/var&gt;&amp;#8221; or
-&amp;#8220;&lt;var&gt;$bracket-apply$&lt;/var&gt;&amp;#8221;
+&amp;#8220;&lt;code&gt;$nfx$&lt;/code&gt;&amp;#8221; or
+&amp;#8220;&lt;code&gt;$bracket-apply$&lt;/code&gt;&amp;#8221;
 by default to a procedure, macro, or syntax
 that &lt;em&gt;cannot&lt;/em&gt; be overridden.
 An implementation &lt;em&gt;SHOULD NOT&lt;/em&gt; bind the symbols
-&amp;#8220;&lt;var&gt;$nfx$&lt;/var&gt;&amp;#8221; or
-&amp;#8220;&lt;var&gt;$bracket-apply$&lt;/var&gt;&amp;#8221;
+&amp;#8220;&lt;code&gt;$nfx$&lt;/code&gt;&amp;#8221; or
+&amp;#8220;&lt;code&gt;$bracket-apply$&lt;/code&gt;&amp;#8221;
 to a procedure, macro, or syntax in the
 default environment, with the exception that it
 &lt;em&gt;MAY&lt;/em&gt; bind them by default to something that produces an error.
@@ -562,16 +562,16 @@
 &lt;em&gt;However&lt;/em&gt;, an implementation &lt;em&gt;MAY&lt;/em&gt;
 provide one or more
 &lt;em&gt;libraries&lt;/em&gt; that when imported
-bind the &amp;#8220;&lt;var&gt;$nfx$&lt;/var&gt;&amp;#8221; and/or
-&amp;#8220;&lt;var&gt;$bracket-apply$&lt;/var&gt;&amp;#8221;
+bind the &amp;#8220;&lt;code&gt;$nfx$&lt;/code&gt;&amp;#8221; and/or
+&amp;#8220;&lt;code&gt;$bracket-apply$&lt;/code&gt;&amp;#8221;
 symbols
 (as it is then a library, this case actually falls under
 the &amp;#8220;reserved for use by library writers&amp;#8221; clause above).
 Application writers and other library writers
 using that implementation are then free to use or not use
 the implementation&amp;#8217;s provided
-&amp;#8220;&lt;var&gt;$nfx$&lt;/var&gt;&amp;#8221; and/or
-&amp;#8220;&lt;var&gt;$bracket-apply$&lt;/var&gt;&amp;#8221;
+&amp;#8220;&lt;code&gt;$nfx$&lt;/code&gt;&amp;#8221; and/or
+&amp;#8220;&lt;code&gt;$bracket-apply$&lt;/code&gt;&amp;#8221;
 as provided by those libraries.
 &lt;/p&gt;
 
@@ -613,13 +613,13 @@
 
 &lt;h2&gt;&lt;a name=&quot;rationale_changereader&quot;&gt;Why not macros? Why modify the reader?&lt;/a&gt;&lt;/h2&gt;
 &lt;p&gt;Many previous systems have implemented &amp;#8220;infix&amp;#8221;
-systems as a named macro or procedure (e.g., &lt;var&gt;INFIX&lt;/var&gt;).
+systems as a named macro or procedure (e.g., &lt;code&gt;INFIX&lt;/code&gt;).
 This looks ugly, and it does the wrong thing &amp;#8212; the resulting list
-always has &lt;var&gt;INFIX&lt;/var&gt; at the beginning,
+always has &lt;code&gt;INFIX&lt;/code&gt; at the beginning,
 not the actual infix operator, so this
 approach can interfere with quoting, macros, and other capabilities.
 In particular,
-consider the following &lt;var&gt;syntax-rules&lt;/var&gt; macro
+consider the following &lt;code&gt;syntax-rules&lt;/code&gt; macro
 for function composition:
 &lt;/p&gt;
 &lt;pre&gt;
@@ -637,10 +637,10 @@
 &lt;samp&gt;{f&amp;nbsp;o&amp;nbsp;g&amp;nbsp;o&amp;nbsp;h&amp;nbsp;o&amp;nbsp;...}&lt;/samp&gt;
 &amp;#8658; &lt;samp&gt;(o&amp;nbsp;f&amp;nbsp;g&amp;nbsp;h&amp;nbsp;...)&lt;/samp&gt;.
 Infix cannot be implemented as a macro alone,
-as the &lt;var&gt;syntax-rules&lt;/var&gt; form has
+as the &lt;code&gt;syntax-rules&lt;/code&gt; form has
 a particular treatment for the pattern.
 A macro for infix would very likely confuse
-the &lt;var&gt;syntax-rules&lt;/var&gt; form.
+the &lt;code&gt;syntax-rules&lt;/code&gt; form.
 &lt;/p&gt;
 &lt;p&gt;
 A reader notation that
@@ -714,12 +714,12 @@
 &lt;/p&gt;
 
 &lt;p&gt;
-It&amp;#8217;s true that {...} are often used in math for set notation. But
+It&amp;#8217;s true that &lt;code&gt;{&lt;/code&gt;...&lt;code&gt;}&lt;/code&gt; are often used in math for set notation. But
 infix notation is far more basic, and common, than sets.
 Also, traditional function call notation and infix are helpful when working
 with sets, so infix notation is the more important need.
 Once you allow neoteric-expressions,
-the notation set(...) is a reasonable alternative.
+the notation &lt;code&gt;set(&lt;/code&gt;...&lt;code&gt;)&lt;/code&gt; is a reasonable alternative.
 &lt;/p&gt;
 
 &lt;h2&gt;&lt;a name=&quot;rationale_notdifferentsyntax&quot;&gt;Why not use a completely different notation inside the expression?&lt;/a&gt;&lt;/h2&gt;
@@ -756,7 +756,7 @@
 but this turns out to not work well. It&amp;#8217;s hard to express
 good rules for detecting infix operators, and the rules become too
 complex for users (e.g., &amp;#8220;punctuation-only symbols&amp;#8221;
-doesn&amp;#8217;t detect &amp;#8220;&lt;var&gt;and&lt;/var&gt;&amp;#8221; or &amp;#8220;&lt;var&gt;or&lt;/var&gt;&amp;#8221;).
+doesn&amp;#8217;t detect &amp;#8220;&lt;code&gt;and&lt;/code&gt;&amp;#8221; or &amp;#8220;&lt;code&gt;or&lt;/code&gt;&amp;#8221;).
 And in
 any case, if they were automatically detected, an escape mechanism
 would be needed anyway -
@@ -773,15 +773,15 @@
 infix, use &lt;code&gt;{&lt;/code&gt;...&lt;code&gt;}&lt;/code&gt;.&lt;/p&gt;
 
 
-&lt;h2&gt;&lt;a name=&quot;rationale_equal&quot;&gt;Why use &lt;var&gt;equal?&lt;/var&gt; to compare operators in a &amp;#8220;simple&amp;#8221; curly-infix-list for equality?&lt;/a&gt;&lt;/h2&gt;
+&lt;h2&gt;&lt;a name=&quot;rationale_equal&quot;&gt;Why use &lt;code&gt;equal?&lt;/code&gt; to compare operators in a &amp;#8220;simple&amp;#8221; curly-infix-list for equality?&lt;/a&gt;&lt;/h2&gt;
 &lt;p&gt;
-Operators are compared using &lt;var&gt;equal?&lt;/var&gt; so that
+Operators are compared using &lt;code&gt;equal?&lt;/code&gt; so that
 constructs like &lt;samp&gt;,op&lt;/samp&gt; are legal operators,
 e.g., &lt;samp&gt;{x&amp;nbsp;,op&amp;nbsp;y&amp;nbsp;,op&amp;nbsp;z}&lt;/samp&gt;.
 Note that unfortunately if the operator construct contains a cycle, it might not terminate
-if &lt;var&gt;equal?&lt;/var&gt; does not terminate in the presence of cycles.
+if &lt;code&gt;equal?&lt;/code&gt; does not terminate in the presence of cycles.
 This was specified this way so that implementers
-could use the normal Scheme &lt;var&gt;equal?&lt;/var&gt; comparison instead of
+could use the normal Scheme &lt;code&gt;equal?&lt;/code&gt; comparison instead of
 having to implement a special comparison operator just for this
 particular case.
 &lt;/p&gt;
@@ -845,7 +845,7 @@
 We also ensure that the notation is clearly homoiconic.&lt;/p&gt;
 &lt;p&gt;Instead, where precedence is desired, application and library writers
 can implement precedence by defining and controlling the scope of an
-&amp;#8220;&lt;var&gt;$nfx$&lt;/var&gt;&amp;#8221; macro or procedure, or by later postprocessing
+&amp;#8220;&lt;code&gt;$nfx$&lt;/code&gt;&amp;#8221; macro or procedure, or by later postprocessing
 of that symbol.
 Scheme macros are already quite powerful and capable of handling this;
 in these cases, &lt;code&gt;{&lt;/code&gt;...&lt;code&gt;}&lt;/code&gt; provides a more
@@ -861,9 +861,9 @@
 This does not lead to hard-to-read expressions, however.
 Examples of simple curly-infix lists combining infix and unary operations
 include
-&lt;code&gt;{-(x)&amp;nbsp;*&amp;nbsp;-(y)}&lt;/code&gt;
+&lt;samp&gt;{-(x)&amp;nbsp;*&amp;nbsp;-(y)}&lt;/samp&gt;
 and
-&lt;code&gt;{-{x}&amp;nbsp;*&amp;nbsp;-{y}}&lt;/code&gt;
+&lt;samp&gt;{-{x}&amp;nbsp;*&amp;nbsp;-{y}}&lt;/samp&gt;
 (the notation is designed so that both work).
 &lt;/p&gt;
 
@@ -871,7 +871,7 @@
 who started this project,
 considered reporting an error if a simple infix
 expression isn&amp;#8217;t provided.
-However, prepending &amp;#8220;&lt;var&gt;$nfx$&lt;/var&gt;&amp;#8221;
+However, prepending &amp;#8220;&lt;code&gt;$nfx$&lt;/code&gt;&amp;#8221;
 is much more flexible.&lt;/p&gt;
 
 &lt;h2&gt;&lt;a name=&quot;rationale_precedence_addable&quot;&gt;Could precedence be added?&lt;/a&gt;&lt;/h2&gt;
@@ -893,7 +893,7 @@
 Here is an example of such an extension, called a &amp;#8220;math&amp;#8221; extension.
 In this extension, if a mixed curly-infix list is seen,
 it first attempts to apply the &amp;#8220;math&amp;#8221; ruleset, and only
-prepends &amp;#8220;$nfx$&amp;#8221; if it does not meet the requirements.  In this extension:
+prepends &amp;#8220;&lt;code&gt;$nfx$&lt;/code&gt;&amp;#8221; if it does not meet the requirements.  In this extension:
 &lt;/p&gt;
 &lt;ol&gt;
 &lt;li&gt;All even-numbered parameters must be symbols, there must be an odd number of parameters, and there must be at least five parameters (the minimum to have more than one operator).
@@ -909,17 +909,17 @@
 an operator of the precedence table; that new symbol is then compared to
 the table.
 This allows the use of many more operators, e.g.,
-&amp;#8220;char-ci&amp;lt;=?&amp;#8221; would be considered an operator with the
-same precedence as &amp;#8220;&amp;lt;=&amp;#8221;.
+&amp;#8220;&lt;samp&gt;char-ci&amp;lt;=?&lt;/samp&gt;&amp;#8221; would be considered an operator with the
+same precedence as &amp;#8220;&lt;samp&gt;&amp;lt;=&lt;/samp&gt;&amp;#8221;.
 If there&amp;#8217;s still no match for any operator,
 the expression does not meet the &amp;#8220;math&amp;#8221; ruleset, and
-the normal mixed rules are used (&lt;var&gt;$nfx$&lt;/var&gt; is inserted at the front).
+the normal mixed rules are used (&lt;code&gt;$nfx$&lt;/code&gt; is inserted at the front).
 &lt;/li&gt;
 &lt;li&gt;
-When the same operator is repeated, the operator simply gains another operand, so {a + b + c * d} is the &amp;#8220;+&amp;#8221; operator applied to three operands: a, b, and (* c d).
+When the same operator is repeated, the operator simply gains another operand, so &lt;samp&gt;{a&amp;nbsp;+&amp;nbsp;b&amp;nbsp;+&amp;nbsp;c&amp;nbsp;*&amp;nbsp;d}&lt;/samp&gt; is the &amp;#8220;&lt;code&gt;+&lt;/code&gt;&amp;#8221; operator applied to three operands: &lt;samp&gt;a&lt;/samp&gt;, &lt;samp&gt;b&lt;/samp&gt;, and &lt;samp&gt;(*&amp;nbsp;c&amp;nbsp;d)&lt;/samp&gt;.
 &lt;/li&gt;
 &lt;li&gt;
-Other different operators of the same precedence are interpreted in left-to-right order, so {a + b - c} maps to {{a + b} - c}.
+Other different operators of the same precedence are interpreted in left-to-right order, so &lt;samp&gt;{a&amp;nbsp;+&amp;nbsp;b&amp;nbsp;-&amp;nbsp;c}&lt;/samp&gt; maps to &lt;samp&gt;{{a&amp;nbsp;+&amp;nbsp;b}&amp;nbsp;-&amp;nbsp;c}&lt;/samp&gt;.
 &lt;/li&gt;
 &lt;/ol&gt;
 
@@ -927,7 +927,7 @@
 But there would be substantial arguments about the semantics of
 any precedence system.
 For example, should there be support for combining different ranged
-comparisons, to support notations such as {a &amp;lt; b &amp;lt;= c}?
+comparisons, to support notations such as &lt;samp&gt;{a&amp;nbsp;&amp;lt;&amp;nbsp;b&amp;nbsp;&amp;lt;=&amp;nbsp;c}&lt;/samp&gt;?
 Should some operators be right-associative, and if so, which ones?
 There would also be substantial disagreement on exactly what operators
 should be in the precedence table (including which combinations and if
@@ -940,23 +940,23 @@
 would be challenging to get agreement on such a list:
 &lt;/p&gt;
 &lt;ol&gt;
-&lt;li&gt;Subscript/down-arrow: sub {Unicode: &amp;#8595;, &amp;#8659;}&lt;/li&gt;
-&lt;li&gt;Exponentiation/superscript/up-arrow: exp..., **, ^, sup {Unicode: &amp;#8593;, &amp;#8657;}&lt;/li&gt;
-&lt;li&gt;Multiplication/division: *, /, div..., mod..., quo...   {Unicode: &amp;#247;, &amp;#215;}&lt;/li&gt;
-&lt;li&gt;Addition/subtraction: +, -&lt;/li&gt;
-&lt;li&gt;Bitwise and: bit...and, log...and, &amp;amp;&lt;/li&gt;
-&lt;li&gt;Bitwise or/xor: bit...or, log...or, |&lt;/li&gt;
+&lt;li&gt;Subscript/down-arrow: &lt;code&gt;sub&lt;/code&gt; {Unicode: &amp;#8595;, &amp;#8659;}&lt;/li&gt;
+&lt;li&gt;Exponentiation/superscript/up-arrow: &lt;code&gt;exp&lt;/code&gt;..., &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;sup&lt;/code&gt; {Unicode: &amp;#8593;, &amp;#8657;}&lt;/li&gt;
+&lt;li&gt;Multiplication/division: &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;div&lt;/code&gt;..., &lt;code&gt;mod&lt;/code&gt;..., &lt;code&gt;quo&lt;/code&gt;...   {Unicode: &amp;#247;, &amp;#215;}&lt;/li&gt;
+&lt;li&gt;Addition/subtraction: &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;&lt;/li&gt;
+&lt;li&gt;Bitwise and: &lt;code&gt;bit...and&lt;/code&gt;, &lt;code&gt;log...and&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/li&gt;
+&lt;li&gt;Bitwise or/xor: &lt;code&gt;bit...or&lt;/code&gt;, &lt;code&gt;log...or&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt;Comparison:
 &lt;ul&gt;
 &lt;li&gt;
-Ranged: &amp;lt; , &amp;lt;= , &amp;gt;=, &amp;gt;  {Unicode: &amp;#8805;, &amp;#8804;, &amp;#8715;, &amp;#8713;, &amp;#8836;, &amp;#8834;, &amp;#8838;, &amp;#8835;, &amp;#8839;}
+Ranged: &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;  {Unicode: &amp;#8805;, &amp;#8804;, &amp;#8715;, &amp;#8713;, &amp;#8836;, &amp;#8834;, &amp;#8838;, &amp;#8835;, &amp;#8839;}
 &lt;/li&gt;
-&lt;li&gt;Unranged:  =, ==, !=, &amp;lt;&amp;gt;, =/=, eq..., in, is {Unicode: &amp;#8800;, &amp;#8776;, &amp;#8773;}&lt;/li&gt;
+&lt;li&gt;Unranged:  &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;=/=&lt;/code&gt;, &lt;code&gt;eq&lt;/code&gt;..., &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;is&lt;/code&gt; {Unicode: &amp;#8800;, &amp;#8776;, &amp;#8773;}&lt;/li&gt;
 &lt;/ul&gt;
-&lt;li&gt;Logical conjunction: and {Unicode: &amp;#8745;, &amp;#8743;}&lt;/li&gt;
-&lt;li&gt;Logical/exclusive disjunction: or, xor, eor {Unicode: &amp;#8746;, &amp;#8744;, &amp;#8853;}&lt;/li&gt;
-&lt;li&gt;Implication/right arrows/doubled arrows: -&amp;gt;, =&amp;gt;,  &amp;lt;-&amp;gt;, &amp;lt;=&amp;gt;, --&amp;gt;, ==&amp;gt;, &amp;lt;--&amp;gt;, &amp;lt;==&amp;gt; {Unicode: &amp;#8596;, &amp;#8660;, &amp;#8594;, &amp;#8658;}&lt;/li&gt;
-&lt;li&gt;Definition/assignment/left arrow: &amp;lt;-, &amp;lt;--, &amp;lt;==, :=, ::=  {Unicode: &amp;#8801;, &amp;#8592;, &amp;#8656;}&lt;/li&gt;
+&lt;li&gt;Logical conjunction: &lt;code&gt;and&lt;/code&gt; {Unicode: &amp;#8745;, &amp;#8743;}&lt;/li&gt;
+&lt;li&gt;Logical/exclusive disjunction: &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;xor&lt;/code&gt;, &lt;code&gt;eor&lt;/code&gt; {Unicode: &amp;#8746;, &amp;#8744;, &amp;#8853;}&lt;/li&gt;
+&lt;li&gt;Implication/right arrows/doubled arrows: &lt;code&gt;-&amp;gt;&lt;/code&gt;, &lt;code&gt;=&amp;gt;&lt;/code&gt;,  &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;, &lt;code&gt;--&amp;gt;&lt;/code&gt;, &lt;code&gt;==&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;--&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;==&amp;gt;&lt;/code&gt; {Unicode: &amp;#8596;, &amp;#8660;, &amp;#8594;, &amp;#8658;}&lt;/li&gt;
+&lt;li&gt;Definition/assignment/left arrow: &lt;code&gt;&amp;lt;-&lt;/code&gt;, &lt;code&gt;&amp;lt;--&lt;/code&gt;, &lt;code&gt;&amp;lt;==&lt;/code&gt;, &lt;code&gt;:=&lt;/code&gt;, &lt;code&gt;::=&lt;/code&gt;  {Unicode: &amp;#8801;, &amp;#8592;, &amp;#8656;}&lt;/li&gt;
 &lt;/ol&gt;
 
 &lt;p&gt;
@@ -965,11 +965,11 @@
 A &amp;#8220;simple math&amp;#8221; ruleset could be devised instead,
 e.g., perhaps it has a shorter list of built-in operators.
 The extant code using curly-infix tends to combine these:
-*, /; +, -; &amp;lt; , &amp;lt;= , &amp;gt;=, &amp;gt;, =, &amp;lt;&amp;gt;, eq...;
-&lt;var&gt;and&lt;/var&gt;; and &lt;var&gt;or&lt;/var&gt;;
-adding exponentiation (e.g., ** and exp...) at a higher precedence level,
-and implication (e.g., -&amp;gt; and =&amp;gt;) would make sense for a short list.
-(The &amp;lt;&amp;gt; isn&amp;#8217;t in many Scheme specifications, but it is odd to omit
+&lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;; &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;; &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;eq&lt;/code&gt;...;
+&lt;code&gt;and&lt;/code&gt;; and &lt;code&gt;or&lt;/code&gt;;
+adding exponentiation (e.g., &lt;code&gt;**&lt;/code&gt; and &lt;code&gt;exp&lt;/code&gt;...) at a higher precedence level,
+and implication (e.g., &lt;code&gt;-&amp;gt;&lt;/code&gt; and &lt;code&gt;=&amp;gt;&lt;/code&gt;) would make sense for a short list.
+(The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; isn&amp;#8217;t in many Scheme specifications, but it is odd to omit
 it from a precedence list.)
 &lt;/p&gt;
 
@@ -978,7 +978,7 @@
 one (such as these) could be added later.
 If a precedence system were added, all existing code using simple
 curly-infix expressions, or 0..2 parameter expressions, would work unchanged.
-Even when it&amp;#8217;s not, many &amp;#8220;$nfx$&amp;#8221; processors would likely generate the
+Even when it&amp;#8217;s not, many &amp;#8220;&lt;code&gt;$nfx$&lt;/code&gt;&amp;#8221; processors would likely generate the
 same order in most actual cases.
 Since it would be difficult to gain such agreement, and the value of
 such a system is doubtful, it is better to provide a much simpler
@@ -986,21 +986,21 @@
 Again, any support for precedence is an extension beyond this SRFI.
 &lt;/p&gt;
 
-&lt;h2&gt;&lt;a name=&quot;rationale_nfx_undefined&quot;&gt;Why is $nfx$ not predefined?&lt;/a&gt;&lt;/h2&gt;
-&lt;p&gt;Implementations should not predefine a meaning for &lt;i&gt;$nfx$&lt;/i&gt;,
+&lt;h2&gt;&lt;a name=&quot;rationale_nfx_undefined&quot;&gt;Why is &lt;code&gt;$nfx$&lt;/code&gt; not predefined?&lt;/a&gt;&lt;/h2&gt;
+&lt;p&gt;Implementations should not predefine a meaning for &lt;code&gt;$nfx$&lt;/code&gt;,
 other than possibly to something that always produces an error
 (e.g., raises an exception).
 &lt;/p&gt;
 &lt;p&gt;
-If anyone wrote code that depended on some local implementation of $nfx$,
+If anyone wrote code that depended on some local implementation of &lt;code&gt;$nfx$&lt;/code&gt;,
 then by definition it would become implementation-dependent.
-Yet the point of the &amp;#8220;$nfx$&amp;#8221; macro is to allow application authors
+Yet the point of the &amp;#8220;&lt;code&gt;$nfx$&lt;/code&gt;&amp;#8221; macro is to allow application authors
 the ability to control what to do in that case,
 not to make them unwittingly dependent on an implementation.
 &lt;/p&gt;
 &lt;p&gt;
 Of course, an implementation could provide a pre-canned macro that could
-be used as a definition of $nfx$.  But in that case, importing the
+be used as a definition of &lt;code&gt;$nfx$&lt;/code&gt;.  But in that case, importing the
 library would be an explicit act,
 easily seen in the code, instead of being hidden.
 That way, it is easy to determine when an implementation-dependent
@@ -1027,7 +1027,7 @@
 is equivalent to
 &lt;samp&gt;(+&amp;nbsp;a&amp;nbsp;b)&lt;/samp&gt;.
 It ensures that the neoteric-expression
-&lt;samp&gt;f{x}&lt;/samp&gt; becomes the likely-intended &lt;samp&gt;(f x)&lt;/samp&gt;.
+&lt;samp&gt;f{x}&lt;/samp&gt; becomes the likely-intended &lt;samp&gt;(f&amp;nbsp;x)&lt;/samp&gt;.
 It makes it easy to use prefix notation; e.g.,
 &lt;samp&gt;{&amp;nbsp;f(x)&amp;nbsp;}&lt;/samp&gt; is another way to write
 &lt;samp&gt;(f&amp;nbsp;x)&lt;/samp&gt;.
@@ -1059,7 +1059,7 @@
 &lt;/pre&gt;
 
 
-&lt;h2&gt;&lt;a name=&quot;rationale_marker&quot;&gt;Why a marker starting with &lt;var&gt;#!&lt;/var&gt; and a letter?&lt;/a&gt;&lt;/h2&gt;
+&lt;h2&gt;&lt;a name=&quot;rationale_marker&quot;&gt;Why a marker starting with &lt;code&gt;#!&lt;/code&gt; and a letter?&lt;/a&gt;&lt;/h2&gt;
 
 &lt;p&gt;
 We would like implementations to always have curly-infix enabled.
@@ -1072,13 +1072,13 @@
 &lt;/p&gt;
 
 &lt;p&gt;
-The &lt;var&gt;#!&lt;/var&gt; marker prefix was suggested due to its similarity
+The &lt;code&gt;#!&lt;/code&gt; marker prefix was suggested due to its similarity
 to other markers.
 After all, R6RS and R7RS (draft 6) already use
-&lt;var&gt;#!fold-case&lt;/var&gt; and &lt;var&gt;#!no-fold-case&lt;/var&gt;
+&lt;code&gt;#!fold-case&lt;/code&gt; and &lt;code&gt;#!no-fold-case&lt;/code&gt;
 as special markers to control the reader.
 Using another marker beginning with
-&lt;var&gt;#!&lt;/var&gt; and a letter allows for a simple, similar-looking marker
+&lt;code&gt;#!&lt;/code&gt; and a letter allows for a simple, similar-looking marker
 for a similar situation.
 What&amp;#8217;s more, it implies a reasonable convention for reader extensions:
 markers that begin with &lt;code&gt;#!&lt;/code&gt;, followed by an ASCII letter, should
@@ -1096,9 +1096,9 @@
 &lt;/p&gt;
 
 &lt;p&gt;
-This marker need not interfere with other uses of &lt;var&gt;#!&lt;/var&gt;.
+This marker need not interfere with other uses of &lt;code&gt;#!&lt;/code&gt;.
 &lt;a href=&quot;<a  rel="nofollow" href="http://srfi.schemers.org/srfi-22/srfi-22.html&quot">http://srfi.schemers.org/srfi-22/srfi-22.html&quot</a>;&gt;SRFI-22&lt;/a&gt; supports
-&lt;var&gt;#!&lt;/var&gt;
+&lt;code&gt;#!&lt;/code&gt;
 followed by space as a comment to the end of the line; this is supported
 by several implementations, but this is easily distinguished from this
 marker by the space.
@@ -1106,26 +1106,26 @@
 &lt;code&gt;#!&lt;/code&gt;...&lt;code&gt;!#&lt;/code&gt;
 as a multi-line comment, enabling scripts with mixed languages and
 multi-line arguments.
-But in practice the &lt;var&gt;#!&lt;/var&gt; is almost always
+But in practice the &lt;code&gt;#!&lt;/code&gt; is almost always
 followed immediately by &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;.&lt;/code&gt;, and other scripts
 could be trivially fixed to make that so.
 R6RS had a non-normative recommendation to ignore a line that began
-with &lt;var&gt;#!/usr/bin/env&lt;/var&gt; (without a space), as well
-as a &lt;var&gt;#!&amp;nbsp;/usr/bin/env&lt;/var&gt; (with a space before the slash),
+with &amp;#8220;&lt;code&gt;#!/usr/bin/env&lt;/code&gt;&amp;#8221; (without a space), as well
+as &amp;#8220;&lt;code&gt;#!&amp;nbsp;/usr/bin/env&lt;/code&gt;&amp;#8221; (with a space before the slash),
 but this is non-normative;
-an implementation could easily implement &lt;var&gt;#!&lt;/var&gt; followed by space
-as an ignored line, and treat &lt;var&gt;#!&lt;/var&gt; followed by
+an implementation could easily implement &lt;code&gt;#!&lt;/code&gt; followed by space
+as an ignored line, and treat &lt;code&gt;#!&lt;/code&gt; followed by
 &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;.&lt;/code&gt; differently.
 Thus, implementations could trivially support (simultaneously) markers
-beginning with &lt;var&gt;#!&lt;/var&gt; followed by a letter
+beginning with &lt;code&gt;#!&lt;/code&gt; followed by a letter
 (such as the one to identify curly-infix),
-the SRFI-22 &lt;var&gt;#!&lt;/var&gt;+space marker as an ignored line,
-and the format &lt;var&gt;#!/&amp;nbsp;...!#&lt;/var&gt; and &lt;var&gt;#!.&amp;nbsp;...!#&lt;/var&gt; as a
+the SRFI-22 &lt;code&gt;#!&lt;/code&gt;+space marker as an ignored line,
+and the format &lt;code&gt;#!/&lt;/code&gt;&amp;nbsp;...&amp;nbsp;&lt;code&gt;!#&lt;/code&gt; and &lt;code&gt;#!.&lt;/code&gt;&amp;nbsp;...&amp;nbsp;&lt;code&gt;!#&lt;/code&gt; as a
 multi-line comment.
 Note that this SRFI does &lt;em&gt;not&lt;/em&gt; mandate support or any particular
-semantics for &lt;var&gt;#!fold-case&lt;/var&gt;, &lt;var&gt;#!no-fold-case&lt;/var&gt;,
-the SRFI-22 &lt;var&gt;#!&lt;/var&gt;+space convention, or
-&lt;var&gt;#!&lt;/var&gt; followed by a slash or period;
+semantics for &lt;code&gt;#!fold-case&lt;/code&gt;, &lt;code&gt;#!no-fold-case&lt;/code&gt;,
+the SRFI-22 &lt;code&gt;#!&lt;/code&gt;+space convention, or
+&lt;code&gt;#!&lt;/code&gt; followed by a slash or period;
 it is merely designed so that implementations &lt;em&gt;could&lt;/em&gt;
 implement them all simultaneously.
 &lt;/p&gt;
@@ -1138,9 +1138,9 @@
 &lt;/p&gt;
 
 &lt;p&gt;
-We recommend that &lt;var&gt;#!curly-infix&lt;/var&gt; not be the very first characters
+We recommend that &lt;code&gt;#!curly-infix&lt;/code&gt; not be the very first characters
 in a file (e.g., put a newline in front of it).
-If the file began with &lt;var&gt;#!curly-infix&lt;/var&gt;, is made executable,
+If the file began with &lt;code&gt;#!curly-infix&lt;/code&gt;, is made executable,
 and then execution is attempted,
 this might confuse some systems into trying to run the
 program &lt;var&gt;curly-infix&lt;/var&gt;.
@@ -1155,24 +1155,24 @@
 Mandating module support is unnecessary and might inhibit its
 adoption.&lt;/p&gt;
 
-&lt;h2&gt;&lt;a name=&quot;rationale_marker_105&quot;&gt;Why the marker &lt;var&gt;#!curly-infix&lt;/var&gt;?&lt;/a&gt;&lt;/h2&gt;
+&lt;h2&gt;&lt;a name=&quot;rationale_marker_105&quot;&gt;Why the marker &lt;code&gt;#!curly-infix&lt;/code&gt;?&lt;/a&gt;&lt;/h2&gt;
 
 &lt;p&gt;
 There were two competing alternatives:
-&lt;var&gt;#!srfi-105&lt;/var&gt; and &lt;var&gt;#!curly-infix&lt;/var&gt;.
+&lt;code&gt;#!srfi-105&lt;/code&gt; and &lt;code&gt;#!curly-infix&lt;/code&gt;.
 &lt;/p&gt;
 
 &lt;p&gt;
 The
 &lt;a href=&quot;<a  rel="nofollow" href="http://srfi.schemers.org/srfi-105/mail-archive/msg00027.html&quot">http://srfi.schemers.org/srfi-105/mail-archive/msg00027.html&quot</a>;&gt;
-&lt;var&gt;#!srfi-105&lt;/var&gt; was recommended during discussion of SRFI-105&lt;/a&gt;,
+&lt;code&gt;#!srfi-105&lt;/code&gt; marker was recommended during discussion of SRFI-105&lt;/a&gt;,
 in part because it makes it clear where more information can be gathered.
 Also, it suggests that &lt;code&gt;srfi-&lt;/code&gt; should be
 the namespace for SRFIs, a plausible convention.
 &lt;/p&gt;
 
 &lt;p&gt;
-However, &lt;var&gt;#!curly-infix&lt;/var&gt; marker
+However, the &lt;code&gt;#!curly-infix&lt;/code&gt; marker
 has the advantage of being more obvious about what is being enabled.
 Modern search engines make it easy to find where information is, using
 either naming convention.
@@ -1185,7 +1185,7 @@
 &lt;p&gt;&lt;a href=
 &quot;<a  rel="nofollow" href="http://docs.racket-lang.org/guide/Pairs__Lists__and_Racket_Syntax.html&quot">http://docs.racket-lang.org/guide/Pairs__Lists__and_Racket_Syntax.html&quot</a>;&gt;
 Racket allows a notation called the &amp;#8220;infix convention&amp;#8221;
-with the form &amp;#8220;&lt;code&gt;(a . operation . b)&lt;/code&gt;&amp;#8221;&lt;/a&gt;. An
+with the form &amp;#8220;&lt;code&gt;(a&amp;nbsp;.&amp;nbsp;operation&amp;nbsp;.&amp;nbsp;b)&lt;/code&gt;&amp;#8221;&lt;/a&gt;. An
 advantage of this alternative is that it does not use the braces,
 so it might be easier to implement in Schemes which already define
 &lt;code&gt;{&lt;/code&gt;...&lt;code&gt;}&lt;/code&gt; in a local extension. However, the Racket &amp;#8220;infix
@@ -1203,7 +1203,7 @@
 they already know.
 The notation &lt;samp&gt;{a&amp;nbsp;+&amp;nbsp;b}&lt;/samp&gt;
 is much more similar to the standard notation
-&amp;#8220;a&amp;nbsp;+&amp;nbsp;b&amp;#8221; than
+&amp;#8220;&lt;samp&gt;a&amp;nbsp;+&amp;nbsp;b&lt;/samp&gt;&amp;#8221; than
 &lt;samp&gt;(a&amp;nbsp;.&amp;nbsp;+&amp;nbsp;.&amp;nbsp;b)&lt;/samp&gt;.&lt;/li&gt;
 &lt;li&gt;It is easy to make mistakes. If you forget a &amp;#8220;&lt;code&gt;.&lt;/code&gt;&amp;#8221;
 somewhere, you end up with the wrong result, and possibly without an
@@ -1232,7 +1232,7 @@
 &lt;li&gt;Even Racket users don&amp;#8217;t use this convention often. Its
 documentation says that &amp;#8220;Racket programmers use the infix
 convention sparingly&amp;#8212;mostly for asymmetric binary operators
-such as &lt;var&gt;&amp;lt;&lt;/var&gt; and &lt;var&gt;is-a?&lt;/var&gt;&amp;#8221;.
+such as &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;is-a?&lt;/code&gt;&amp;#8221;.
 The documentation does not say why,
 but its extra length and awkwardness may be part of the reason.
 In any case, the fact that the Racket documentation recommends that it
@@ -1289,13 +1289,13 @@
 Jens Axel S&amp;#248;gaard explained that its design rationale was as follows:
 &lt;/p&gt;
 &lt;ol type=&quot;i&quot;&gt;
-&lt;li&gt;The operations + - * / ^ [are] written using their standard syntax&lt;/li&gt;
+&lt;li&gt;The operations &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; [are] written using their standard syntax&lt;/li&gt;
 &lt;li&gt;No other operations get special syntax&lt;/li&gt;
 &lt;li&gt;function application is name[]
 (same choice as Mathematica - but it could
 easily be name() instead)&lt;/li&gt;
-&lt;li&gt;Since - is used in Scheme names, one can use _ to write names using -&lt;/li&gt;
-&lt;li&gt;Other names can be written using | | syntax.&lt;/li&gt;
+&lt;li&gt;Since &lt;code&gt;-&lt;/code&gt; is used in Scheme names, one can use &lt;code&gt;_&lt;/code&gt; to write names using -&lt;/li&gt;
+&lt;li&gt;Other names can be written using &lt;code&gt;|&lt;/code&gt;&amp;nbsp;&lt;code&gt;|&lt;/code&gt; syntax.&lt;/li&gt;
 &lt;/ol&gt;
 
 &lt;p&gt;
@@ -1305,8 +1305,8 @@
 <a  rel="nofollow" href="http://reference.wolfram.com/mathematica/guide/Syntax.html">http://reference.wolfram.com/mathematica/guide/Syntax.html</a>&lt;/a&gt;.
 The rationale is to keep the infix operations to the essentials in
 order not to interfere too much with builtin names of Scheme.
-Since - is so common in the variable names, a special syntax _
-is needed. Other names can be used by the standard | | syntax
+Since &lt;code&gt;-&lt;/code&gt; is so common in the variable names, a special syntax &lt;code&gt;_&lt;/code&gt;
+is needed. Other names can be used by the standard &lt;code&gt;|&lt;/code&gt;&amp;nbsp;&lt;code&gt;|&lt;/code&gt; syntax
 for peculiar variable names.&amp;#8221;
 &lt;/p&gt;
 
@@ -1315,9 +1315,9 @@
 chosen to delimit the infix expressions. That&amp;#8217;s on purpose,
 since I had and haven&amp;#8217;t decided what I like best yet.&amp;#8221;
 In the sample implementation,
-the 3-character sequence &amp;#8220;@${&amp;#8220; begins an infix expression,
+the 3-character sequence &amp;#8220;&lt;code&gt;@${&lt;/code&gt;&amp;#8220; begins an infix expression,
 which switches to a completely different language that
-ends with a matching &amp;#8220;}&amp;#8221;.
+ends with a matching &amp;#8220;&lt;code&gt;}&lt;/code&gt;&amp;#8221;.
 &lt;/p&gt;
 
 &lt;p&gt;
@@ -1366,7 +1366,7 @@
 &lt;p&gt;
 Differences in this approach, which some may see as advantages, are that
 infix operators need not be separated by whitespace,
-it provides precedence of * and / over + and -,
+it provides precedence of &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; over &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt;,
 and it builds in a simple assignment statement if you want it.
 Like many infix notations (including curly-infix), for many expressions
 the infix.plt package is a far clearer notation than the
@@ -1396,7 +1396,7 @@
 &lt;/li&gt;
 &lt;li&gt;Because it has a precedence system, it is necessarily less homoiconic
 when precedence is used.
-Note that curly-infix supports precedence via &lt;var&gt;$nfx$&lt;/var&gt;, and
+Note that curly-infix supports precedence via &lt;code&gt;$nfx$&lt;/code&gt;, and
 a built-in precedence system &lt;em&gt;could&lt;/em&gt; be added later
 if this was desired by the community.
 &lt;/li&gt;
@@ -1410,40 +1410,40 @@
 Its documentation states that
 identifiers (which are also used for function names) must
 &amp;#8220;begin with a letter, and is optionally followed by series of letters,
-digits or underscores.  An underscore is converted to a -&amp;#8221;.
+digits or underscores.  An underscore is converted to a &lt;code&gt;-&lt;/code&gt;&amp;#8221;.
 Under these rules, it is not possible to call procedures with names like
 &amp;#8220;&lt;samp&gt;char=?&lt;/samp&gt;&amp;#8221; or use variables
-with &amp;#8220;*&amp;#8221; embedded in them.
-It does allow references to variable names with &amp;#8220;-&amp;#8221;
+with &amp;#8220;&lt;code&gt;*&lt;/code&gt;&amp;#8221; embedded in them.
+It does allow references to variable names with &amp;#8220;&lt;code&gt;-&lt;/code&gt;&amp;#8221;
 embedded in them, but in this approach
 names must be spelled differently (and thus inconsistently)
-by replacing every &amp;#8220;-&amp;#8221; with &amp;#8220;_&amp;#8221;.
-Thus, variables like &amp;#8220;list-ref&amp;#8221; must
-be spelled as &amp;#8220;list_ref&amp;#8221; inside the infix.plt notation
+by replacing every &amp;#8220;&lt;code&gt;-&lt;/code&gt;&amp;#8221; with &amp;#8220;&lt;code&gt;_&lt;/code&gt;&amp;#8221;.
+Thus, variables like &amp;#8220;&lt;samp&gt;list-ref&lt;/samp&gt;&amp;#8221; must
+be spelled as &amp;#8220;&lt;samp&gt;list_ref&lt;/samp&gt;&amp;#8221; inside the infix.plt notation
 as documented.
 The infix.plt documentation did not, at the time of this writing,
 document any way around this limitation.
 However, on 2012-10-21,
 Jens Axel S&amp;#248;gaard reported that other identifiers &lt;em&gt;can&lt;/em&gt;
-be referred to using the |...| syntax.
+be referred to using the &lt;code&gt;|&lt;/code&gt;...&lt;code&gt;|&lt;/code&gt; syntax.
 This works around the problem, but is slightly more cumbersome when
-it is necessary, and is inconsistent with other code where |...|
+it is necessary, and is inconsistent with other code where &lt;code&gt;|&lt;/code&gt;...&lt;code&gt;|&lt;/code&gt;
 is not required.
 These are fundamental side-effects of not &lt;em&gt;requiring&lt;/em&gt; infix operators
 to be delimited (e.g., by whitespace).
-Since some symbols must be escaped with |...| inside infix.plt
+Since some symbols must be escaped with &lt;code&gt;|&lt;/code&gt;...&lt;code&gt;|&lt;/code&gt; inside infix.plt
 but not outside, and some symbols require
-replacing every &amp;#8220;-&amp;#8221; with &amp;#8220;_&amp;#8221; where this is not done,
+replacing every &amp;#8220;&lt;code&gt;-&lt;/code&gt;&amp;#8221; with &amp;#8220;&lt;code&gt;_&lt;/code&gt;&amp;#8221; where this is not done,
 some symbols are represented inconsistently... and this
 inconsistency can lead to potentially hard-to-find errors.
 &lt;/li&gt;
 &lt;li&gt;
 The notation is completely different and inconsistent
 with the surrounding Lisp notation.
-The curly braces {...} are suddenly used for the list creation operation
+The curly braces &lt;code&gt;{&lt;/code&gt;...&lt;code&gt;}&lt;/code&gt; are suddenly used for the list creation operation
 instead of parentheses,
-square brackets x[...] are used for function application
-instead of parentheses, and the parentheses (...) are
+square brackets &lt;code&gt;x[&lt;/code&gt;...&lt;code&gt;]&lt;/code&gt; are used for function application
+instead of parentheses, and the parentheses &lt;code&gt;(&lt;/code&gt;...&lt;code&gt;)&lt;/code&gt; are
 instead used for grouping (and not for list creation or function application).
 The same punctuation mark
 can have a completely different meaning in different contexts,
@@ -1512,7 +1512,7 @@
 It includes
 &lt;a href=&quot;<a  rel="nofollow" href="http://gnuvola.org/software/guile/doc/Reading-Infix.html&quot">http://gnuvola.org/software/guile/doc/Reading-Infix.html&quot</a>;&gt;support
 for reading infix expressions&lt;/a&gt;.
-Once activated, infix expressions are surrounded by #[ and ].
+Once activated, infix expressions are surrounded by &lt;code&gt;#[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;.
 Infix operators are surrounded by whitespace.
 It supports precedence, which sounds like an advantage,
 but operators must be registered before use (and few are predefined),
@@ -1565,8 +1565,8 @@
 on July 2000 he said
 &amp;#8220;I think most people would like Scheme
 a lot better if they could say...
-display(... instead of
-(display&amp;nbsp;... &amp;#8221;
+&lt;samp&gt;display(&lt;/samp&gt;... instead of
+&lt;samp&gt;(display&amp;nbsp;&lt;/samp&gt;...&amp;nbsp;&amp;#8221;
 &lt;/li&gt;
 &lt;li&gt;
 Peter Norvig had a reader implementation
@@ -1597,10 +1597,10 @@
 combining function calls and infix expressions
 when there is only one parameter to the function call.
 This is a common case;
-for example, &amp;#8220;&lt;var&gt;not&lt;/var&gt;&amp;#8221;
+for example, &amp;#8220;&lt;code&gt;not&lt;/code&gt;&amp;#8221;
 (which is normally given only one parameter)
-often encloses infix &amp;#8220;&lt;var&gt;and&lt;/var&gt;&amp;#8221; and
-&amp;#8220;&lt;var&gt;or&lt;/var&gt;&amp;#8221;.
+often encloses infix &amp;#8220;&lt;code&gt;and&lt;/code&gt;&amp;#8221; and
+&amp;#8220;&lt;code&gt;or&lt;/code&gt;&amp;#8221;.
 Thus,
 &lt;samp&gt;f{n&amp;nbsp;-&amp;nbsp;1}&lt;/samp&gt;
 &amp;#8658;
@@ -1694,16 +1694,16 @@
 This was changed to eliminate the inconsistency.&lt;/p&gt;
 
 &lt;p&gt;
-The symbol &lt;var&gt;$bracket-apply$&lt;/var&gt; was once &lt;var&gt;bracketaccess&lt;/var&gt;,
+The symbol &lt;code&gt;$bracket-apply$&lt;/code&gt; was once &lt;code&gt;bracketaccess&lt;/code&gt;,
 but it turns out that the Kawa Scheme implementation already used
-&lt;var&gt;$bracket-apply$&lt;/var&gt;.
-Originally &lt;var&gt;$nfx$&lt;/var&gt; was &lt;var&gt;nfx&lt;/var&gt;, as this was used by some
+&lt;code&gt;$bracket-apply$&lt;/code&gt;.
+Originally &lt;code&gt;$nfx$&lt;/code&gt; was &lt;code&gt;nfx&lt;/code&gt;, as this was used by some
 predefined macros for infix notation; it was changed slightly so that it
 would be unlikely to interfere with any pre-existing
-&lt;var&gt;nfx&lt;/var&gt; procedure or macro, but would still be similar to its
+&lt;code&gt;nfx&lt;/code&gt; procedure or macro, but would still be similar to its
 previous name.
-The symbols &lt;var&gt;$bracket-apply$&lt;/var&gt;
-and &lt;var&gt;$nfx$&lt;/var&gt; are somewhat more awkward to type
+The symbols &lt;code&gt;$bracket-apply$&lt;/code&gt;
+and &lt;code&gt;$nfx$&lt;/code&gt; are somewhat more awkward to type
 directly, but this is actually a good thing; this means it is even more
 unlikely to be used unintentionally by user code.
 
@@ -1761,16 +1761,16 @@
 which is essentially the same rule as before.&lt;/p&gt;
 
 &lt;h2&gt;&lt;a name=&quot;rationale_otherdetails&quot;&gt;Other details&lt;/a&gt;&lt;/h2&gt;
-&lt;p&gt;There is no requirement that writers (e.g., &amp;#8220;&lt;var&gt;write&lt;/var&gt;&amp;#8221;
+&lt;p&gt;There is no requirement that writers (e.g., &amp;#8220;&lt;code&gt;write&lt;/code&gt;&amp;#8221;
 or a pretty-printer) write out curly-infix-expressions. They may
 choose to do so, e.g., for lists of length 3-6 whose car is the
-symbol &amp;#8220;&lt;var&gt;and&lt;/var&gt;&amp;#8221;,
-the symbol &amp;#8220;&lt;var&gt;or&lt;/var&gt;&amp;#8221;, or a
+symbol &amp;#8220;&lt;code&gt;and&lt;/code&gt;&amp;#8221;,
+the symbol &amp;#8220;&lt;code&gt;or&lt;/code&gt;&amp;#8221;, or a
 punctuation-only symbol. However, it would probably be wise to wait
 until many implementations can handle c-expressions.&lt;/p&gt;
 
 &lt;p&gt;
-The &lt;samp&gt;$nfx$&lt;/samp&gt; and &lt;samp&gt;$bracket-apply$&lt;/samp&gt; symbols are
+The &lt;code&gt;$nfx$&lt;/code&gt; and &lt;code&gt;$bracket-apply$&lt;/code&gt; symbols are
 unhygienic, in the sense that programs that need it would
 in many cases need to begin by defining them, even though these identifiers
 do not appear literally in the code.
@@ -1781,19 +1781,19 @@
 As noted in a
 &lt;a href=&quot;<a  rel="nofollow" href="http://lists.gnu.org/archive/html/guile-devel/2012-10/msg00134.html&quot">http://lists.gnu.org/archive/html/guile-devel/2012-10/msg00134.html&quot</a>;&gt;
 guile-devel post by Mark H. Weaver on 2012-10-26&lt;/a&gt;,
-&amp;#8220;apart from the fact that &lt;samp&gt;$nfx$&lt;/samp&gt;
+&amp;#8220;apart from the fact that &lt;code&gt;$nfx$&lt;/code&gt;
 etc. are meant to be defined by the user,
 it is exactly the same situation as for
-&amp;#8216;quote&amp;#8217;, &amp;#8216;quasiquote&amp;#8217;,
-&amp;#8216;unquote&amp;#8217;, &amp;#8216;unquote-splicing&amp;#8217;,
-&amp;#8216;quasisyntax&amp;#8217;, etc.
+&amp;#8216;&lt;code&gt;quote&lt;/code&gt;&amp;#8217;, &amp;#8216;&lt;code&gt;quasiquote&lt;/code&gt;&amp;#8217;,
+&amp;#8216;&lt;code&gt;unquote&lt;/code&gt;&amp;#8217;, &amp;#8216;&lt;code&gt;unquote-splicing&lt;/code&gt;&amp;#8217;,
+&amp;#8216;&lt;code&gt;quasisyntax&lt;/code&gt;&amp;#8217;, etc.
 The whole point of
 these shorthand notations is to avoid having to type the associated
 identifier, and yet this means that an identifier is being referenced
 without appearing literally in the code.
 These shorthand notations always involve a tradeoff.  It means that the
 syntax is not quite as simple as the original s-expressions (as printed
-by &amp;#8216;write&amp;#8217;), and the user has to know a few more rules for how to
+by &amp;#8216;&lt;code&gt;write&lt;/code&gt;&amp;#8217;), and the user has to know a few more rules for how to
 interpret the notation.  Experience shows that humans tend to prefer a
 bit more complexity in their syntax if there is something to be gained from it.
 I think it&amp;#8217;s worthwhile to add a few more rules in exchange
@@ -1819,7 +1819,7 @@
 Implementations should &lt;em&gt;always&lt;/em&gt; do
 this, but an implementation that complies with this SRFI must
 at least activate this behavior
-when they read the &lt;var&gt;#!curly-infix&lt;/var&gt; marker
+when they read the &lt;code&gt;#!curly-infix&lt;/code&gt; marker
 followed by whitespace.
 &lt;/p&gt;
 &lt;p&gt;This reference implementation is SRFI type 2: &amp;#8220;A
</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00169" href="msg00169.html">Re: [PATCH] Important fix and HTML markup improvements</a></strong>
<ul><li><em>From:</em> David A. Wheeler</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00167.html">Please update SRFI-105</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00169.html">Re: [PATCH] Important fix and HTML markup improvements</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00162.html">Re: A few more minor tweaks</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00169.html">Re: [PATCH] Important fix and HTML markup improvements</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00168"><strong>Date</strong></a></li>
<li><a href="threads.html#00168"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
