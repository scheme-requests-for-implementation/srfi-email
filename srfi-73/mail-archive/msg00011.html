<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: comparison operators and *typos -->
<!--X-From-R13: Bnhy Epuyvr <fpuyvrNpbzpnfg.arg> -->
<!--X-Date: Tue, 28 Jun 2005 08:38:44 +0200 (DFT) -->
<!--X-Message-Id: BEE66896.AA1E%schlie@comcast.net -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20050628034007.D80781B77B4@voluntocracy.org -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: comparison operators and *typos</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00010.html">Date Prev</a>][<a href="msg00012.html">Date Next</a>][<a href="msg00010.html">Thread Prev</a>][<a href="msg00012.html">Thread Next</a>][<a href="maillist.html#00011">Date Index</a>][<a href="threads.html#00011">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: comparison operators and *typos</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-73">SRFI 73</a> from before July 7th, 2015.  The new archives for SRFI 73 are <a href="http://srfi-email.schemers.org/srfi-73/">here</a>.  Eventually, the entire history will be moved there, including any new messages.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: Aubrey Jaffer &lt;<a href="mailto:agj@DOMAIN.HIDDEN">agj@xxxxxxxxxxxx</a>&gt;</li>
<li><em>Subject</em>: Re: comparison operators and *typos</li>
<li><em>From</em>: Paul Schlie &lt;<a href="mailto:schlie@DOMAIN.HIDDEN">schlie@xxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Tue, 28 Jun 2005 02:38:14 -0400</li>
<li><em>Cc</em>: &lt;<a href="mailto:srfi-73@DOMAIN.HIDDEN">srfi-73@xxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-73@DOMAIN.HIDDEN">srfi-73@xxxxxxxxxxxxxxxxx</a></li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:20050628034007.D80781B77B4@DOMAIN.HIDDEN">20050628034007.D80781B77B4@xxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>User-agent</em>: Microsoft-Entourage/11.1.0.040913</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>&gt; From: Aubrey Jaffer &lt;agj@xxxxxxxxxxxx&gt;
&gt;  | Date: Mon, 27 Jun 2005 18:09:04 -0400
&gt;  | From: Paul Schlie &lt;schlie@xxxxxxxxxxx&gt;
&gt;  | 
&gt;  | &gt; From: Aubrey Jaffer &lt;agj@xxxxxxxxxxxx&gt;
&gt;  | &gt;  | Date: Mon, 27 Jun 2005 02:29:12 -0400
&gt;  | &gt;  | From: Paul Schlie &lt;schlie@xxxxxxxxxxx&gt;
&gt;  | &gt;  | ...
&gt;  | &gt;  | Thereby one could define that an unsigned 0 compares = to signed 0's
&gt;  | &gt;  | to preserve existing code practices which typically compare a value
&gt;  | &gt;  | against a sign-less 0. i.e.:
&gt;  | &gt;  | 
&gt;  | &gt;  |  (= 0 0.0 -0 -0.0) =&gt; #t
&gt;  | &gt;  |  (= 0 0.0 +0 +0.0) =&gt; #t
&gt;  | &gt;  | 
&gt;  | &gt;  |  (= -0 -0.0 +0 +0.0) =&gt; #f
&gt;  | &gt; 
&gt;  | &gt; The `=' you propose is not transitive, which is a requirement of R5RS.
&gt;  | 
&gt;  | - then alternatively one could define:
&gt;  | 
&gt;  |   (= -0 -0.0 0 0.0 +0 +0.0) =&gt; #t
&gt;  | 
&gt;  |   while retaining the remaining relationships, as it seems
&gt;  |   that = and &lt; relationships need not be mutually exclusive?
&gt; 
&gt; R5RS says:
&gt; 
&gt;   -- procedure: = z1 z2 z3 ...
&gt;   -- procedure: &lt; x1 x2 x3 ...
&gt;   -- procedure: &gt; x1 x2 x3 ...
&gt;   -- procedure: &lt;= x1 x2 x3 ...
&gt;   -- procedure: &gt;= x1 x2 x3 ...
&gt;       These procedures return #t if their arguments are (respectively):
&gt;       equal, monotonically increasing, monotonically decreasing,
&gt;       monotonically nondecreasing, or monotonically nonincreasing.
&gt; 
&gt;       These predicates are required to be transitive.
&gt; 
&gt; Equal cannot be monotonically increasing.

- why not? I was under the impression that the transitive requirement
  applied to the elements of a particular predicate, but not necessarily
  apply across distinct predicates? As the ordering which may exist for =
  need not apply to &lt;=, nor are the ordered members of &lt;= necessarily
  valid for = ? (however the context of the thought was to enable the
  comparison of 0 against other zeros as being = as a possible means of
  preserving existing code practices while allowing the introduction of
  alternate forms of 0 with more specific meanings)

&gt;  ...
&gt;  | 
&gt;  | &gt; Mathematical division by 0 is undefined; if you return 1, then code
&gt;  | &gt; receiving that value can't detect that a boundary case occured.
&gt;  | 
&gt;  | - yes, as above; and corrected below for unsigned 0's and 0.0's:
&gt;  | 
&gt;  |   1/0 == inf :: 1/inf == 0 :: 0/0 == inf/inf == ~1
&gt;  | 
&gt;  |   where although inf equivalent in magnitude to +/-inf,
&gt;  |   it's sign is is undefined, thereby similar to nan, with
&gt;  |   the exception that if one were to introduce the convention
&gt;  |   that '~' may designate an ambiguous sign then the result of
&gt;  |   any division by inf or 0 may be considered to only yield
&gt;  |   an ambiguous sign although not necessarily magnitude, in
&gt;  |   in lieu of considering the value as undefined, i.e.
&gt;  | 
&gt;  |   inf =&gt; ~inf               ; either +inf or -inf
&gt;  |   (* 3 (/ 0 0)) =&gt; ~3       ; either   -3 or   +3, thereby:
&gt;  |   (abs (* 3 (/ 0 0))) =&gt; +3
&gt; 
&gt; So ~ generates an algebraic field extension attaching the roots of
&gt; x^2=1.  Note that ~ is not a real number because it doesn't fit in the
&gt; total ordering.

- yes, essentially ~ designates a value's sign-less magnitude and arguably
  may be thought of as a set of numbers with equivalent magnitudes and
  differing signs; which I suspect could be extended to complex values
  such that the root of x^2=-1 are 0~1i. (and could be defined to have an
  ordering relative to each other, as well as within the set of real numbers
  if considered to be a set of values (&lt; -4 ~2) for example would certainly
  be true, where (&lt; -1 ~2) would likely not be as (&lt; -1 -2 +2) would not be
  valid.)

&gt;  |   (as this is how an implementation would behave if it considered
&gt;  |    +-inf and +-0 it's greatest and smallest represent-able but
&gt;  |    non-accumulating values; which effectively enables calculations
&gt;  |    to loose precision more gracefully, than falling of the edge of
&gt;  |    the value system potentially resulting in a run-time fault.)
&gt; 
&gt; Section 6.2.2 Exactness says:
&gt; 
&gt;   If two implementations produce exact results for a computation that
&gt;   did not involve inexact intermediate results, the two ultimate
&gt;   results will be mathematically equivalent.
&gt; 
&gt; So loss of precision must not be platform dependent; thresholds of
&gt; &quot;greatest and smallest represent-able&quot; values can not affect
&gt; precision.  Losing precision in calculation is an attribute of inexact
&gt; numbers.

- yes, and apologize for not following my own conventions again, the
  above should have referred to &quot;+-inf.0 and +-0.0&quot; as inexact values.

  (where +-inf would be an exact reciprocal of +-0, although having
   an undefined magnitude; just as the reciprocal of an exact 0 could
   be thought of as being equivalent to ~0, and having an reciprocal
   value of ~1/0 = ~inf)

&gt;  | &gt; ...
&gt;  | &gt; Nearly all of the SLIB occurences of EXPT have at least one
&gt;  | &gt; literal constant argument.  In these cases, (expt 0 0) signaling
&gt;  | &gt; an error would catch coding errors.  MODULAR:EXPT tests for a
&gt;  | &gt; zero base (and returns 0) before calling EXPT.
&gt;  | 
&gt;  | - ??? The responsibility of an implementation's arithmetic
&gt;  | implementation is to be generically as correct and consistent as
&gt;  | reasonably possible.  If slib chooses to optionally signal a
&gt;  | runtime error for any arbitrary set of argument values, that's it's
&gt;  | prerogative; but should have nothing to do with what the arithmetic
&gt;  | value of (expt 0 0) or any other function is most consistently
&gt;  | defined as being.
&gt; 
&gt; My point is that (expt 0 0) is unlikely to occur when EXPT is being
&gt; used as a continuous function; its occurrences will be exponentiating
&gt; integers.  In the integer context, arguments about limits of
&gt; continuous functions are irrelevant.

- Typically it seem more broadly accepted that (expt 0 0) == 1 particularly
  for integers, as the subject of multivariate trajectories are irrelevant.

  Although I believe I do understand your point that most legitimate uses
  of (expt x y) will tend to have non-zero valued arguments, and see nothing
  wrong with the creation of libraries which may try to assist the debugging
  of code by optionally monitoring its arguments; I don't believe its a
  good idea to presume any arithmetic function should yield an error in lieu
  of an arithmetic result by default.

&gt;  |   (all arithmetic functions should always return values).
&gt; 
&gt; 6.2.3 Implementation restrictions:
&gt; 
&gt;   If one of these procedures is unable to deliver an exact result when
&gt;   given exact arguments, then it may either report a violation of an
&gt;   implementation restriction or it may silently coerce its result to
&gt;   an inexact number.
&gt; 
&gt; Always returning a value is a stronger requirement than R5RS or
&gt; SRFI-70, which gives the implementation a choice between returning 0/0
&gt; and signaling an error for (/ 0.0 0.0). Can you justify that mandate?

- only on the basis that errors/exceptions are by their nature disruptive
  to both the expressed (and presumably intended) code and/or otherwise
  control flow of the program, therefore all standard functions should be
  defined to yield values, which may be checked explicitly as may desired
  for application specific expectations within the applications code itself,
  or encapsulated in corresponding application specific wrappers which may
  then throw exceptions, and/or shape the results to the applications more
  specific needs and/or expectations. (but as noted above, I think its
  reasonable to define a mechanism by which an implementation to optionally
  enable functions to report and/or throw warnings/errors, but not in lieu
  of their returning values by default).
  
&gt; Do you consider QUOTIENT, MODULO, and REMAINDER arithmetic?

- yes, and believe all should return values by default (even for invalid
  operands, where by default it could be defined that a function may
  return a &lt;void&gt; type or something similar by default, or signal an error
  when explicitly enabled to do so; which I know is a bit different)

  i.e. (car 3) =&gt; &lt;void&gt;

&gt;  | &gt; Grepping through a large body of Scheme code found no use of EXPT
&gt;  | &gt; where the two arguments are related.
&gt;  | 
&gt;  | - which has nothing to do with anything, functions should be considered
&gt;  |   to be evaluated about static points:
&gt;  | 
&gt;  |   i.e. (f x y) == (f (+ x ~1/inf) (+ y ~1/inf))
&gt; 
&gt; The integer uses for EXPT should also be considered.

- yes, but there's no ambiguity, as (expt 0 0) == 1 clearly for integers
  it would seem. 

&gt;  |   there's nothing special about 0, as any function may impose
&gt;  |   relative trajectories for their arguments:
&gt;  | 
&gt;  |   (define (f x y) (/ x (* y y y (- y 1)))
&gt;  | 
&gt;  |   as such the only consistent thing that an implementation can
&gt;  |   warrant is that all primitive arithmetic expressions are
&gt;  |   evaluated equivalently about the static values passed to them,
&gt;  |   independently of whether or not the values passed to them have
&gt;  |   begun to loose precision due to the limited dynamic range of an
&gt;  |   implementation's number system. Thereby at least as a function's
&gt;  |   arguments begin to loose precision, the function correspondingly
&gt;  |   degrades in precision correspondingly and consistently, without
&gt;  |   after already yielding relatively inaccurate results decides it
&gt;  |   doesn't know the answer at all, or chooses to return a value
&gt;  |   which is inconsistent with it's previous results. (admittedly in
&gt;  |   my opinion)
&gt; 
&gt; SRFI-73 is about exact numbers.  EXPT will only return exact numbers
&gt; for exact arguments.  Loss of precision means inexact numbers.

- yes I apologize for going off on a tangent, I was considering inexact
  values. (however in the context of exact values, it seems that the only
  way to generate +-inf or +-0, would be directly from the literal use
  of such an abstract value in an expression itself, as it would seem
  impossible to generate an exact infinite value as a function of finite
  value expressions?)

&gt;  | &gt; (expt 0 0) ==&gt; 1 is one of the possibilities for SRFI-70.  But I
&gt;  | &gt; am leaning toward the &quot;0/0 or signal an error&quot; choice to catch
&gt;  | &gt; the rare coding error.
&gt;  | 
&gt;  | - Again, in just my opinion, I'd rather a function return the most
&gt;  |   likely useful static value as a function of it's arguments, rather
&gt;  |   than it trying to pretend it knows something about the arguments
&gt;  |   passed to it and potentially generating a runtime fault.
&gt;  | 
&gt;  |   However it does seem potentially useful to be optionally warned
&gt;  |   whenever the precision of a primitive calculation drops below
&gt;  |   some minimal precision; i.e. it's likely much more useful to know
&gt;  |   when a floating point value is demoralized (as it means that the
&gt;  |   value now no longer has a represent-able reciprocal, or when an
&gt;  |   argument to an addition is less than the represented precision of
&gt;  |   the other operand, as these are the type of circumstances which
&gt;  |   result in inaccuracies, which by the time one may underflow to 0,
&gt;  |   or overflow to inf, and hope it gets trapped by some misguided
&gt;  |   function implementation which should have simply just returned
&gt;  |   the correct value based upon the arguments it was given and have
&gt;  |   the application check for what it believes is correct, it's
&gt;  |   already much too late, as regardless of whether some
&gt;  |   implementation's arithmetic system discontinuity was ticked, the
&gt;  |   results of a calculation are at best already suspect.
&gt; 
&gt; Bear@xxxxxxxxx is also interested in specifying precision.  See
&gt; &lt;<a  rel="nofollow" href="http://srfi.schemers.org/srfi-70/mail-archive/msg00088.html">http://srfi.schemers.org/srfi-70/mail-archive/msg00088.html</a>&gt; about an
&gt; idea for latent precisions.

- thank you.

&gt;  | &gt;  | Where I understand that all inf's are not strictly equivalent,
&gt;  | &gt;  | but when expressed as inexact values it seems more ideal to
&gt;  | &gt;  | consider +-inf.0 to be equivalent to the bounds of the inexact
&gt;  | &gt;  | representation number system, thereby +-inf.0 are simply
&gt;  | &gt;  | treated as the greatest, and +-0.0 the smallest representable
&gt;  | &gt;  | inexact value;
&gt;  | &gt; 
&gt;  | &gt; &lt;<a  rel="nofollow" href="http://srfi.schemers.org/srfi-70/srfi-70.html#6.2.2x">http://srfi.schemers.org/srfi-70/srfi-70.html#6.2.2x</a>&gt; shows that
&gt;  | &gt; inexact real numbers correspond to intervals of the real number line.
&gt;  | &gt; Infinities corresponding to the remaining half-lines gives very clean
&gt;  | &gt; semantics for inexact real numbers.  Infinitesimals (+-0.0) are a
&gt;  | &gt; solution in search of a problem.
&gt;  | 
&gt;  | - only if it's not considered important that inexact infinities have
&gt;  |   corresponding reciprocals;
&gt; 
&gt; Inexact infinities have reciprocals: zero.  Their reciprocals are not
&gt; unique, but that is already the case with IEEE-754 floating-point
&gt; representations:

- yes, among other idiosyncrasies.

&gt;   179.76931348623151e306  ==&gt; 179.76931348623151e306
&gt;   179.76931348623157e306  ==&gt; 179.76931348623157e306
&gt;   (/ 179.76931348623151e306)  ==&gt; 5.562684646268003e-309
&gt;   (/ 179.76931348623157e306)  ==&gt; 5.562684646268003e-309
&gt; 
&gt;  |   which seems clearly desirable as otherwise any expression which
&gt;  |   may overflow the dynamic range of the number system can't
&gt;  |   preserve the sign of it's corresponding infinitesimal value,
&gt;  |   which if not considered important, there's no reason to have
&gt;  |   signed infinities, either, etc. ?
&gt; 
&gt; #i+1/0 is the half-line beyond the largest floating-point value.  The
&gt; projection of that interval through / is a small open interval
&gt; bordering 0.0.  That interval overlaps the interval of floating-point
&gt; numbers closer to 0.0 than to any other.  Thus the reciprocal of
&gt; #i+1/0 is 0.0.

- but the problem seems to be the reciprocal of #i-1/0?
  And it's reciprocal?, which should be where one began?

  (where it one introduces -0.0 then 0.0 is implied as being +0.0
  leaving one with ether a + or - 0, but nothing which is either?
  unless one introduces yet another 0, 0 (or ~0 hypothetically,
  which then implies ~inf)?


</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00012" href="msg00012.html">Re: comparison operators and *typos</a></strong>
<ul><li><em>From:</em> Aubrey Jaffer</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00010" href="msg00010.html">Re: comparison operators and *typos</a></strong>
<ul><li><em>From:</em> Aubrey Jaffer</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00010.html">Re: comparison operators and *typos</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00012.html">Re: comparison operators and *typos</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00010.html">Re: comparison operators and *typos</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00012.html">Re: comparison operators and *typos</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00011"><strong>Date</strong></a></li>
<li><a href="threads.html#00011"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
