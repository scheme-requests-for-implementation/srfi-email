<!-- MHonArc v2.6.15 -->
<!--X-Subject: complexity of mechanism -->
<!--X-From-R13: "Fnlybe D. Qnzcoryy" <pnzcoryyNzhzoyr.arg> -->
<!--X-Date: Tue, 11 Apr 2006 23:38:34 +0200 (MST) -->
<!--X-Message-Id: 20060411213831.BA81B9851D@pluto.mumble.net -->
<!--X-Content-Type: text/plain -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>complexity of mechanism</title>
<link rev="made" href="mailto:campbell@mumble.net">
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00004.html">Date Prev</a>][<a href="msg00006.html">Date Next</a>][<a href="msg00004.html">Thread Prev</a>][<a href="msg00006.html">Thread Next</a>][<a href="maillist.html#00005">Date Index</a>][<a href="threads.html#00005">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>complexity of mechanism</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-89">SRFI 89</a> from before July 7th, 2015.  The new archives for SRFI 89 are <a href="http://srfi-email.schemers.org/srfi-89/">here</a>.  Eventually, the entire history will be moved there, including any new messages.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: <a href="mailto:srfi-89%40srfi.schemers.org">srfi-89@srfi.schemers.org</a></li>
<li><em>Subject</em>: complexity of mechanism</li>
<li><em>From</em>: &quot;Taylor R. Campbell&quot; &lt;<a href="mailto:campbell%40mumble.net">campbell@mumble.net</a>&gt;</li>
<li><em>Date</em>: Tue, 11 Apr 2006 21:38:31 +0000</li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-89%40srfi.schemers.org">srfi-89@srfi.schemers.org</a></li>
<li><em>User-agent</em>: IMAIL/1.21; Edwin/3.116; MIT-Scheme/7.7.90.+</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>This is one of the most complex extensions to the fundamental core of
Scheme I've ever seen.  Although I won't claim that it has no
historical precedent, I have to wonder whether the bulk of it couldn't
be greatly simplified.  I had written up a draft a while ago for a
basic optional positional parameter SRFI, but its bulk was in
explaining its rationale in comparison to other mechanisms (SRFI 16's
CASE-LAMBDA and Olin Shivers' LET-OPTIONALS) and in elaborating on
implementation strategies.  For those curious, it's at

  &lt;<a  rel="nofollow" href="http://mumble.net/~campbell/proposals/optional.text">http://mumble.net/~campbell/proposals/optional.text</a>&gt;.

I am personally generally opposed to named parameters intermixed with
positional ones.  Most of the examples of code in the SRFI 89 document
are either very contrived or can be expressed without using named
parameters, in some cases much more simply, either by instead using an
alist or by changing the idiom of parameter passing; macros for
picking apart such alists of options are helpful.

For example, R3RS had an elaborate number formatting library based on
list-structured formatting specifiers, rather than named parameters
to NUMBER-&gt;STRING.  For XML output, I think simply having a list of
attributes makes *much* more sense than manually specifying every
possible attribute at the definition site:

  (define (make-html-styler tag)
    (lambda (attributes . content)
      (element tag content
               (map (lambda (a) (attribute (car a) (cadr a)))
                    attributes))));

although this doesn't provide static guarantees of the allowed
attributes, one can always insert checks later on (e.g., with another
parameter to MAKE-HTML-STYLER).

As for n-ary procedures with named parameters, I always find them very
confusing.  I don't think the port parameter to I/O procedures should
be optional in the first place, and rather than the PRINT procedure
described in this SRFI for generating complex output I prefer a
higher-level and more structured library of output combinators,

  &lt;<a  rel="nofollow" href="http://mumble.net/~campbell/scheme/output.scm">http://mumble.net/~campbell/scheme/output.scm</a>&gt;,

in which the various OUTPUT-... procedures return procedures that take
a single port parameter and write the output to it.  I've built a
structured XML output library based on this idiom, in fact, which is
very simple but equally general.

I'd like to see some compelling examples that demand named parameters
and for which alists of options would not suffice, perhaps for
performance reasons or otherwise.  In my experience I can't recall
ever having found any good ones, really; do you have any particularly
compelling examples where you found named parameters with this
mechanism much more appropriate than any other mechanism, or than
separate procedures to do different jobs?

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00006" href="msg00006.html">Re: complexity of mechanism</a></strong>
<ul><li><em>From:</em> Marc Feeley &lt;feeley@iro.umontreal.ca&gt;</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00004.html">Re: what are #!KEY &amp;c.?</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00006.html">Re: complexity of mechanism</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00004.html">Re: what are #!KEY &amp;c.?</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00006.html">Re: complexity of mechanism</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00005"><strong>Date</strong></a></li>
<li><a href="threads.html#00005"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
