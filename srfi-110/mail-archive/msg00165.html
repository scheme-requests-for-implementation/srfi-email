<!-- MHonArc v2.6.16 -->
<!--X-Subject: Re: sweet&#45;expressions are not homoiconic -->
<!--X-From-R13: Oyrkrl Dnqhy <nkpuNzvg.rqh> -->
<!--X-Date: Mon, 27 May 2013 05:32:02 +0200 (MST) -->
<!--X-Message-Id: CAPKQtS&#45;uMxFUtgVuTTDz3LcOxm2V0FRmgujmuUUmMh++YXY6ng@mail.gmail.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20894.14161.78101.703078@mooers.cs.grinnell.edu -->
<!--X-Reference: E1Ugkr2&#45;0002a2&#45;KD@rmm6prod02.runbox.com -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: sweet-expressions are not homoiconic</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00164.html">Date Prev</a>][<a href="msg00166.html">Date Next</a>][<a href="msg00163.html">Thread Prev</a>][<a href="msg00166.html">Thread Next</a>][<a href="maillist.html#00165">Date Index</a>][<a href="threads.html#00165">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: sweet-expressions are not homoiconic</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-110">SRFI 110</a> from before July 7th, 2015.  The new archives for SRFI 110 are <a href="http://srfi-email.schemers.org/srfi-110/">here</a>.  Eventually, the entire history will be moved there, including any new messages.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: <a href="mailto:dwheeler@DOMAIN.HIDDEN">dwheeler@xxxxxxxxxxxx</a></li>
<li><em>Subject</em>: Re: sweet-expressions are not homoiconic</li>
<li><em>From</em>: Alexey Radul &lt;<a href="mailto:axch@DOMAIN.HIDDEN">axch@xxxxxxx</a>&gt;</li>
<li><em>Date</em>: Sun, 26 May 2013 23:25:24 -0400</li>
<li><em>Cc</em>: stone &lt;<a href="mailto:stone@DOMAIN.HIDDEN">stone@xxxxxxxxxxxxxxx</a>&gt;, srfi-110 &lt;<a href="mailto:srfi-110@DOMAIN.HIDDEN">srfi-110@xxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-110@DOMAIN.HIDDEN">srfi-110@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Dkim-signature</em>: v=1; a=rsa-sha256; c=relaxed/relaxed;        d=gmail.com; s=20120113;        h=mime-version:sender:in-reply-to:references:date         :x-google-sender-auth:message-id:subject:from:to:cc:content-type;        bh=h187a1IxpdX9uk/08QyCiNdeoU+RpmQnh50FPxS6kD8=;        b=VKWEGD4TX+Xd5KIeP4QwYfnx9I1v4D4hx6ee4iFOaT0haRk3eEbFeSBAVYMiDYCVN0         Vr+G3La3cSJs3rh3bI2oWofE9gOBL3GE5DzWYFcd6hKb4fty6JJiezEee7PFw0t1mmSl         VFivQ5+LzVSIWwth+ieMUtApxYl+gdqMY2hDGbAldEu8emcGZI54sDjerkpyPfg3XT3Q         pv1D9dqzNJVmL5RoQtq/Viu4VcZOiHnYy537I+VftMWXnEt/+SKqLOtGMC/3z7SPZcXz         mgVDuGNx8HanL9Z4e9mprMDkEv2XTc4zPbdogKzggvCZuxej/4I/Dhe4WFJUaT8KdrM7         EhCw==</li>
<li><em>In-reply-to</em>: &lt;<a href="mailto:E1Ugkr2-0002a2-KD@DOMAIN.HIDDEN">E1Ugkr2-0002a2-KD@xxxxxxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>References</em>: &lt;<a href="mailto:20894.14161.78101.703078@DOMAIN.HIDDEN">20894.14161.78101.703078@xxxxxxxxxxxxxxxxxxxxxx</a>&gt;	&lt;<a href="mailto:E1Ugkr2-0002a2-KD@DOMAIN.HIDDEN">E1Ugkr2-0002a2-KD@xxxxxxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Sender</em>: <a href="mailto:axofch@DOMAIN.HIDDEN">axofch@xxxxxxxxx</a></li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>I don't know whether anyone else on this list uses Emacs' Paredit mode
<a  rel="nofollow" href="http://www.emacswiki.org/emacs/ParEdit">http://www.emacswiki.org/emacs/ParEdit</a> to edit their S-expressions,
but my own experience is that it makes S-expressions *vastly* easier
to edit than any other syntax (whether indentation-sensitive or
otherwise) that I have ever experienced (note that I have not
experienced sweet-expressions).

The key feature of s-expressions that enables the existence of Paredit
mode (besides their extraordinary simplicity) is that every
grammatical construct down to the token level begins and ends on a
distinct character from every other.  Therefore, there is always at
most one non-terminal in the parse tree of my code that begins at the
cursor (&quot;point&quot;, in Emacs-speak), and at most one that ends there.  So
commands like &quot;delete the piece of parse tree that starts where my
cursor is&quot; make sense.  Paredit mode defines and provides key bindings
for a large selection of such operations -- and editing at the parse
tree level is much faster and more fun than the word-stream or
line-stream level.

I haven't read the spec of sweet-expressions very carefully, but it
seems that they lack this crucial property: The expression
  factorial{n - 1}
begins on the same character as its subexpression factorial begins, and
ends on the same character as its subexpression {n - 1} ends.

I do not grok the scholarship around parsing well enough to know
whether this property is equivalent to being LL(1) (I expect not), or
whether it corresponds to any other standard definition.  In any case,
I submit that sweet-expressions would become a much more powerful and
effective notation if they were to obey the Paredit Property -- or,
more broadly, if someone were to implement Paredit mode for them.

I bring this up here because it would be a shame if a small
modification to sweet-expressions were to turn out to be the
difference between Paredit being implementable for them vs not, and if
the SRFI were to be finalized in the wrong state.

Best,
~Alexey

P.S. I don't have a clear idea of how to implement Paredit mode for a
notation that lacks what I have named the Paredit Property, but I
don't want to say that it can't be done.  Perhaps there could be some
phantom characters presented by the editor for the purpose of
disambiguating different components of the parse tree?  Or some sort
of sub-character navigation through the buffer?  It seems that
experimentation would be needed to figure out whether such a strategy
can work.

P.P.S. I was motivated to write this note in part because of the
recurrent complaint about 10 closing parens being hard to distinguish
from 12.  In the presence of Paredit mode this is simply a
non-problem.  Paredit maintains the invariant that one's s-expressions
are always well-formed (e.g., typing '(' inserts &quot;()&quot;; typing ')'
inserts nothing but moves the next &quot;)&quot; to the cursor and steps over
it; etc).  So I literally neither know nor care whether there are 10
parens at the end of something or 12 -- it's always the right number.

On Sun, May 26, 2013 at 8:00 PM, David A. Wheeler &lt;dwheeler@xxxxxxxxxxxx&gt; wrote:
&gt; John David Stone originally stated on 23 May 2013:
&gt;&gt; Whitespace characters
&gt;&gt; don't look like grouping symbols, as parentheses, brackets, braces, or
&gt;&gt; oriented quotation marks do, because they don't have appropriate shapes and
&gt;&gt; don't come in pairs.  Moreover, they don't visibly nest, so it is unnatural
&gt;&gt; to use them to represent recursively defined syntactic structures.
&gt;
&gt; I think it's obvious I don't agree, but it might be useful to recap how we got here,
&gt; and why I think indentation sensitivity is a GREAT tool for representing Lisp expressions.
&gt;
&gt; Lisps already have a perfectly serviceable visible pair of symbols
&gt; for grouping, namely, parentheses.  The problem is with their overuse.
&gt; Since EVERYTHING is grouped with parentheses, it can be hard for humans
&gt; to tell when you're ending one thing versus another.  E.G.,  when there are
&gt; 6 closing parentheses, it's hard to tell that it should be 7.
&gt; People can visually match 2, or maybe 3 pairs, but not 10 or 12.
&gt;
&gt; Lisp is called &quot;lots of irritating superflous parentheses&quot; for a *reason*.
&gt; Most software developers today will *immediately* reject any
&gt; language with such poor readability.  Even Lisp's creator,
&gt; John McCarthy, did not intend for s-expressions to be used directly (!).
&gt; While some people don't like Python's indentation-based syntax, Python
&gt; is WAY more popular than Scheme or Common Lisp.  In short,
&gt; Lisp's syntax greatly inhibits its use where it might be used otherwise.
&gt;
&gt; Some obvious &quot;solutions&quot; do NOT work well enough:
&gt; * We can add another character pair.  R6RS did this by adding [...].
&gt;   You could even add {...} if you wanted to.
&gt;   But in practice I don't think this works well at all; it adds confusion not help.
&gt;   I think part of the problem is that (), [], and {} aren't visually distinct enough.
&gt;   It's worth noting that R7RS-small drops [...] as a requirement, so clearly
&gt;   there's no groundswell of support for [...] as a synonym for (...).
&gt; * We could define a fixed syntax that is tailored to fixed language semantics.
&gt;   That is the &quot;usual way&quot; this problem is solved in other languages,
&gt;   and when the languages are used in their anticipated domain, this works well.
&gt;   But Lisps are often used for symbol manipulation, where symbols may actually
&gt;   be for a domain-specific language and where you can easily create
&gt;   new meanings (via macros).  So this &quot;usual solution&quot; doesn't well work for Lisps
&gt;   (without giving up some of the reasons for using a Lisp in the first place).
&gt;
&gt; The great thing about the indentation-sensitive approach is that, if carefully defined,
&gt; it is NOT tied to any particular semantics.  Yet it can still represent
&gt; complexly-nested structures *AND* it is clearly visually distinct from parentheses.
&gt; What's more, Lisp developers ALREADY use indentation layout to show nesting,
&gt; and many other languages (including the widely-used Python) already use
&gt; indentation, so it's not such a big change for many.  It's also easy to define
&gt; it so it retains backwards compatibility. Sure, it's a change, but not a massive one.
&gt;
&gt; Quick aside: The GNU folks have
&gt; long stated that guile was &quot;the official extension language for the
&gt; GNU operating system&quot;, but relatively few GNU programs use it as an
&gt; extension language. I believe one reason is because
&gt; guile is saddled with Scheme's default syntax; a more readable version
&gt; of guile would be far more compelling.  Guile already supports SRFI-105
&gt; (hooray!); I believe adding sweet-expressions would make guile and
&gt; other Scheme implementations far MORE compelling.
&gt;
&gt;
&gt; John David Stone:
&gt;&gt; At this point, so many markers, special conventions, and multilayer
&gt;&gt; exceptions ...
&gt;
&gt; SRFI-110 only has three marker constructs: \\, $, and &lt;*...*&gt;.
&gt; You can consider abbreviation+whitespace a fourth construct, if you like.
&gt; There are no special conventions and no exceptions.
&gt; You can teach the whole thing (including all of SRFI-105) in less than an hour.
&gt;
&gt; These markers were developed based on real-world experience with the notation.
&gt; I kicked off the readable group around 2006; we've been working for ~7 years
&gt; to find the smallest set of markers that produces a *useful* and *readable* notation.
&gt; But &quot;0 markers&quot; is not a reasonable goal for something practical.  Even wisp,
&gt; which trades *away* readability of code to get a simpler notation, has markers.
&gt; We're hardly the first to observe this; reStructuredText was developed as
&gt; a reaction to StructuredText, and one issue was *specifically* that users had
&gt; to indent very long blocks, and ended up with something like markers.
&gt;
&gt; There may be a better set of markers (symbols and semantics), and as you
&gt; can see in the mailing list, we've had many discussions and debates.
&gt; But this set seems to resolve the problems of indentation-sensitive syntax,
&gt; in a way that's pleasant to read and use.  If you have a better solution, please post.
&gt;
&gt;&gt; have been added to the proposed syntax that it is quite
&gt;&gt; implausible to claim that sweet-expressions are homoiconic.  In the general
&gt;&gt; case, reconstructing the underlying data structure from the
&gt;&gt; sweet-expression that represents it requires the mental application of a
&gt;&gt; non-obvious algorithm of considerable intricacy.
&gt;
&gt; I can do it.  Alan can do it. Other participants here can do it too.
&gt; Therefore, it's homoiconic.
&gt;
&gt; It's not intricate; the algorithm takes maybe an hour to learn.
&gt; That's LESS than most languages, and since you can
&gt; amortize that time over legions of hours reading and
&gt; writing code, it's worth doing.
&gt;
&gt; The BNF looks more intricate only because
&gt; I wanted to be very rigorous in its definition.  That has advantages:
&gt; We can be sure it has desirable properties (e.g., it is LL(1)),
&gt; and can be much more confident that different implementations will
&gt; do the same thing.  That latter point means that learning the algorithm ONCE
&gt; can pay dividends across different implementations, increasing the
&gt; likelihood that it's worth learning.
&gt;
&gt; --- David A. Wheeler
&gt;

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00166" href="msg00166.html">Re: sweet-expressions are not homoiconic</a></strong>
<ul><li><em>From:</em> David A. Wheeler</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00142" href="msg00142.html">sweet-expressions are not homoiconic</a></strong>
<ul><li><em>From:</em> John David Stone</li></ul></li>
<li><strong><a name="00163" href="msg00163.html">Re: sweet-expressions are not homoiconic</a></strong>
<ul><li><em>From:</em> David A. Wheeler</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00164.html">Re: sweet-expressions are not homoiconic</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00166.html">Re: sweet-expressions are not homoiconic</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00163.html">Re: sweet-expressions are not homoiconic</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00166.html">Re: sweet-expressions are not homoiconic</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00165"><strong>Date</strong></a></li>
<li><a href="threads.html#00165"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
