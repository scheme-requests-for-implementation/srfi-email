<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: Various comments -->
<!--X-From-R13: qloNpf.vaqvnan.rqh -->
<!--X-Date: Sat, 24 Jun 2006 16:53:05 +0200 (MST) -->
<!--X-Message-Id: 449d51c5.5F3uvtSXqpMvQnZ8%dyb@garbo.cs.indiana.edu -->
<!--X-Content-Type: text/plain -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: Various comments</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00006.html">Date Prev</a>][<a href="msg00008.html">Date Next</a>][<a href="msg00002.html">Thread Prev</a>][<a href="msg00008.html">Thread Next</a>][<a href="maillist.html#00007">Date Index</a>][<a href="threads.html#00007">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: Various comments</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-93">SRFI 93</a> from before July 7th, 2015.  The <a href="http://srfi-email.schemers.org/srfi-93">new archives</a> for SRFI 93 contain all messages, not just those from before July 7th, 2015.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: <a href="mailto:srfi-93@DOMAIN.HIDDEN">srfi-93@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Subject</em>: Re: Various comments</li>
<li><em>From</em>: <a href="mailto:dyb@DOMAIN.HIDDEN">dyb@xxxxxxxxxxxxxx</a></li>
<li><em>Date</em>: Sat, 24 Jun 2006 10:52:53 -0400</li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-93@DOMAIN.HIDDEN">srfi-93@xxxxxxxxxxxxxxxxx</a></li>
<li><em>User-agent</em>: nail 11.25 7/29/05</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>&gt; Section 3 mentions &quot;singleton identifiers&quot; as a possible form for
&gt; syntax abstractions, and refers to section 3.6 for more information. I
&gt; couldn't find this in 3.6.

This should probably have been a reference to Section 3.4, which mentions
what happens when a keyword appears in ``any other definition or
expression context,'' i.e., not in the first position of a list-structured
input form.

&gt; The interpretation of DEFINE-SYNTAX according to section 3.3 seems
&gt; to be difficult to integrate with the expansion of internal
&gt; DEFINEs into LETREC* forms. Would it be possible to add a
&gt; definition of the full expansion process in the SRFI here?

Section 3.1 describes body expansion in detail, but what it doesn't do is
explicitly say that the expander constructs a letrec* form from the
defined variables, expanded right-hand-side expressions, and expanded body
expressions.  I've made a note to add this.

&gt; According to section 3.4, transformers are procedures which accept a
&gt; single argument. Not only is this incompatible with existing systems
&gt; (such as explicit renaming), it is also problematic for later
&gt; extension. I think it would be more useful to use a new form here,
&gt; such as (SYNTAX-TRANSFORMER STX (SYNTAX-CASE STX ...)) or
&gt; (SYNTAX-LAMBDA (STX) (SYNTAX-CASE STX ...)).

This is definitely worth considering.  Although it would require a lot of
existing code to be updated, it should be a relatively easy change to
make, and it does allow for implementation and possible future RNRS
extensions, as you say, like adding an environment argument to give access
to the compile-time environment.

&gt; Variable transformers are introduced in the same section. The
&gt; whole purpose of this seems to be to allow a generalized SET!
&gt; similar to SRFI-17. This seems somewhat kludgey, and not very much
&gt; related to the purpose of syntax transformation. What is the
&gt; rationale to define a generalized SET! together with other syntax
&gt; transformations, and not as a specific extension to SET!?

There's no overlap here with SRFI 17.  SRFI 17 allows one to define what
happens to assignments of the form:

  (set! (id e ...) e)

whereas variable transformers allow one to define what happens with
&quot;ordinary&quot; assignments of the form

  (set! id e)

This can be used, for example, to allow method bodies in an OOP system to
access instance variables as if they were ordinary variables, by
transforming references into the appropriate instance access operations
and assignments into the appropriate instance mutation operations.

&gt; Finally, section 3.6 mentions #(pattern*) etc. as a possible
&gt; pattern. R5RS does not allow vector literals, they do have to be
&gt; quoted. Does this mean one can define #(foo) to be semantically
&gt; meaningful syntax in R6RS? What is the rationale for allowing
&gt; this?

A vector is not a valid form (definition or expression).  A syntactic
abstraction must be list- or improper-list-structured (with a keyword as
the first element) or a singleton identifier (a keyword).  A vector can
appear as part of the syntax of a syntactic abstraction, however, and the
syntax is useful if you ever want to delve into a constant that may
contain vectors.

Thanks for your feedback.

Kent Dybvig

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00008" href="msg00008.html">Re: Various comments</a></strong>
<ul><li><em>From:</em> Jorgen Schaefer</li></ul></li>
<li><strong><a name="00012" href="msg00012.html">Re: Various comments</a></strong>
<ul><li><em>From:</em> John Cowan</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00006.html">Re: testsuite needed</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00008.html">Re: Various comments</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00002.html">Various comments</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00008.html">Re: Various comments</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00007"><strong>Date</strong></a></li>
<li><a href="threads.html#00007"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
