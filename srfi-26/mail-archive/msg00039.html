<!-- MHonArc v2.6.15 -->
<!--X-Subject: Re: is that useful? -->
<!--X-From-R13: fronfgvna.rtareNcuvyvcf.pbz -->
<!--X-Date: Fri, 22 Feb 2002 17:15:59 +0100 (NFT) -->
<!--X-Message-Id: OFE43540E4.FDC02418&#45;ONC1256B68.004C9E32@diamond.philips.com -->
<!--X-Content-Type: multipart/alternative -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: is that useful?</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00038.html">Date Prev</a>][<a href="msg00040.html">Date Next</a>][<a href="msg00038.html">Thread Prev</a>][<a href="msg00045.html">Thread Next</a>][<a href="maillist.html#00039">Date Index</a>][<a href="threads.html#00039">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: is that useful?</h1>
<p style="max-width: 30em;">This page is part of the web mail archives of <a href="http://srfi.schemers.org/srfi-26">SRFI 26</a> from before July 7th, 2015.  The <a href="http://srfi-email.schemers.org/srfi-26">new archives</a> for SRFI 26 contain all messages, not just those from before July 7th, 2015.</p>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: <a href="mailto:walter@DOMAIN.HIDDEN">walter@xxxxxxxxxxxxx</a></li>
<li><em>Subject</em>: Re: is that useful?</li>
<li><em>From</em>: <a href="mailto:sebastian.egner@DOMAIN.HIDDEN">sebastian.egner@xxxxxxxxxxx</a></li>
<li><em>Date</em>: Fri, 22 Feb 2002 17:12:16 +0100</li>
<li><em>Cc</em>: <a href="mailto:srfi-26@DOMAIN.HIDDEN">srfi-26@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-26@DOMAIN.HIDDEN">srfi-26@xxxxxxxxxxxxxxxxx</a></li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->

<br><font size=2 face="Courier New">Walter,</font>
<br>
<br><font size=2 face="Courier New">&gt; Maybe somebody can explain me what is the use of this SRFI.</font>
<br>
<br><font size=2 face="Courier New">Finally somebody who raises the most important issue of</font>
<br><font size=2 face="Courier New">this SRFI. Thank you for that!</font>
<br>
<br><font size=2 face="Courier New">The mechanism proposed in the SRFI is an attempt to</font>
<br><font size=2 face="Courier New">make some (!) of the common cases cropping up in &quot;daily</font>
<br><font size=2 face="Courier New">programming with Scheme&quot; more likable. </font>
<br>
<br><font size=2 face="Courier New">The SRFI aims at specializing a subset of the parameters</font>
<br><font size=2 face="Courier New">of a Scheme procedure, only. As you have observed, it is </font>
<br><font size=2 face="Courier New">not possible to reorder, remove or duplicate arguments---</font>
<br><font size=2 face="Courier New">and this is indeed the intention. If you need to process a</font>
<br><font size=2 face="Courier New">procedure in a more profound way than offered by the SRFI</font>
<br><font size=2 face="Courier New">you are to use the full power of a lambda _expression_ or,</font>
<br><font size=2 face="Courier New">in case it is frequent, define and use a differnt mechanism.</font>
<br>
<br><font size=2 face="Courier New">The idea of the SRFI grew out of the observation that Scheme</font>
<br><font size=2 face="Courier New">is very modest, in a certain sense too modest, with respect</font>
<br><font size=2 face="Courier New">to special cases of its primary mechanism (beta conversion).</font>
<br>
<br><font size=2 face="Courier New">In this sense, I do not see the SRFI in conflict with</font>
<br><font size=2 face="Courier New">other mechanisms that deal with special cases. There is</font>
<br><font size=2 face="Courier New">no 'exclusive or' to me.</font>
<br>
<br><font size=2 face="Courier New">For example, your macro f (implementing a suggar-free version</font>
<br><font size=2 face="Courier New">of ARC's []-notation) is the mechanism of choice to define</font>
<br><font size=2 face="Courier New">complicated single-argument procedures when the name of the</font>
<br><font size=2 face="Courier New">argument is irrelevant:</font>
<br><font size=2 face="Courier New"><br>
&gt; &nbsp; &nbsp;(define quadratic (f + (* _ _ 2) (* _ 3) 4))<br>
</font>
<br><font size=2 face="Courier New">Your macro fn on the other hand provides the full power of </font>
<br><font size=2 face="Courier New">lambda but with numbered (instead of named) variables.</font>
<br><font size=2 face="Courier New">This could be useful, for example, if there are very many </font>
<br><font size=2 face="Courier New">arguments and the task is merely to permute them: </font>
<br>
<br><font size=2 face="Courier New">&nbsp; &nbsp; &nbsp; &nbsp; (fn list $2 $3 $4 $5 $6 $7 $8 $9 $1).</font>
<br>
<br><font size=2 face="Courier New">From a more abstract point of view, I see three main aspects:</font>
<br>
<br><font size=2 face="Courier New">* How does the mechanism refer to the residual parameters?</font>
<br><font size=2 face="Courier New">&nbsp; &nbsp; &nbsp; &nbsp; currying: by leaving them out</font>
<br><font size=2 face="Courier New">&nbsp; &nbsp; &nbsp; &nbsp; SRFI-26: &nbsp;by indicating an omission (a 'slot')</font>
<br><font size=2 face="Courier New">&nbsp; &nbsp; &nbsp; &nbsp; ARC's []: not at all (result is unary by definition)</font>
<br><font size=2 face="Courier New">&nbsp; &nbsp; &nbsp; fn: &nbsp; &nbsp; &nbsp; not at all (arity/signature unspecified)</font>
<br><font size=2 face="Courier New">&nbsp; &nbsp; &nbsp; lambda: &nbsp; by listing symbols for them</font>
<br>
<br><font size=2 face="Courier New">* How does the mechanism refer to the actual arguments?</font>
<br><font size=2 face="Courier New">&nbsp; &nbsp; &nbsp; &nbsp; currying: not at all (you only wrote constants)</font>
<br><font size=2 face="Courier New">&nbsp; &nbsp; &nbsp; &nbsp; SRFI-26: &nbsp;by the position of the slot in the call</font>
<br><font size=2 face="Courier New">&nbsp; &nbsp; &nbsp; &nbsp; ARC's []: by a fixed special symbol _</font>
<br><font size=2 face="Courier New">&nbsp; &nbsp; &nbsp; &nbsp; fn: &nbsp; &nbsp; &nbsp; by numbered symbols $1, $2, ..</font>
<br><font size=2 face="Courier New">&nbsp; &nbsp; &nbsp; lambda: &nbsp; by refering to the symbol</font>
<br>
<br><font size=2 face="Courier New">* What computation depending on parameters does it allow?</font>
<br><font size=2 face="Courier New">&nbsp; &nbsp; &nbsp; &nbsp; currying: none</font>
<br><font size=2 face="Courier New">&nbsp; &nbsp; &nbsp; &nbsp; SRFI-26: &nbsp;none</font>
<br><font size=2 face="Courier New">&nbsp; &nbsp; &nbsp; &nbsp; ARC's []: any</font>
<br><font size=2 face="Courier New">&nbsp; &nbsp; &nbsp; &nbsp; fn: &nbsp; &nbsp; &nbsp; any</font>
<br><font size=2 face="Courier New">&nbsp; &nbsp; &nbsp; lambda: &nbsp; any</font>
<br>
<br><font size=2 face="Courier New">So much about theory. Now for something completely different...</font>
<br>
<br><font size=2 face="Courier New">Why would anybody want to write code using SRFI-26?</font>
<br>
<br><font size=2 face="Courier New">Well, as I did not do statistics on all Scheme code in</font>
<br><font size=2 face="Courier New">the world, this matter will have to be settled by looking </font>
<br><font size=2 face="Courier New">at myself and a certain amount of speculation about a</font>
<br><font size=2 face="Courier New">few other people. In the end, I cannot prove anything.</font>
<br>
<br><font size=2 face="Courier New">The main use of the macro proposed in the SRFI is to</font>
<br><font size=2 face="Courier New">make explicit that the _expression_ denotes a specialized</font>
<br><font size=2 face="Courier New">form of a procedure in a situation that would probably</font>
<br><font size=2 face="Courier New">be dealt with by currying in other languages. (My first</font>
<br><font size=2 face="Courier New">notation for it did not even allow specializing an</font>
<br><font size=2 face="Courier New">arbitrary subset but only the first few arguments---but</font>
<br><font size=2 face="Courier New">I relaxed that when I observed that the 'point of no return</font>
<br><font size=2 face="Courier New">with respect to confusion' is only when permutation, omission</font>
<br><font size=2 face="Courier New">or duplication comes into play.)</font>
<br>
<br><font size=2 face="Courier New">A secondary aspect is a succinct and (the bad word again)</font>
<br><font size=2 face="Courier New">&quot;intuitive&quot; notation. This usually comes as a package-deal</font>
<br><font size=2 face="Courier New">with a painful discussion about the choice of identifiers.</font>
<br><font size=2 face="Courier New">Please refer to the SRFI-26 archive (srfi.schemers.org/srfi-26)</font>
<br><font size=2 face="Courier New">for that. This is certainly the most controversal issue yet </font>
<br><font size=2 face="Courier New">and I do not want to interfere with the discussion going on<br>
right now.</font>
<br>
<br><font size=2 face="Courier New">---</font>
<br>
<br><font size=2 face="Courier New">So to summarize, the SRFI is just *a* mechanism and</font>
<br><font size=2 face="Courier New">useful in cases where curried languages would allow</font>
<br><font size=2 face="Courier New">dropping arguments. As this itself is not very useful</font>
<br><font size=2 face="Courier New">in a strict language like Scheme, I have tried to</font>
<br><font size=2 face="Courier New">find a notation with relatively little overhead and</font>
<br><font size=2 face="Courier New">the SRFI is essentially the result of that.</font>
<br>
<br><font size=2 face="Courier New">You seem to have considerable experience with related</font>
<br><font size=2 face="Courier New">tools. What do you use in practice?</font>
<br>
<br><font size=2 face="Courier New">Sebastian.</font>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00045" href="msg00045.html">Re: is that useful?</a></strong>
<ul><li><em>From:</em> Walter C. Pelissero</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00038.html">is that useful?</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00040.html">l, the ultimate curry that is not curry</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00038.html">is that useful?</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00045.html">Re: is that useful?</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00039"><strong>Date</strong></a></li>
<li><a href="threads.html#00039"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
