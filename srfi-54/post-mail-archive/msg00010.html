<!-- MHonArc v2.6.15 -->
<!--X-Subject: A cat supporting infinities, nans, and &#45;0.0 -->
<!--X-From-R13: "fbb" <gvyqrNgvyqr.pb.xe> -->
<!--X-Date: Thu,  6 Dec 2007 06:30:33 +0100 (MET) -->
<!--X-Message-Id: 000401c837c7$b6c73fb0$eef86bde@INITERM -->
<!--X-Content-Type: multipart/mixed -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>A cat supporting infinities, nans, and -0.0</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00009.html">Date Prev</a>][<a href="msg00011.html">Date Next</a>][<a href="msg00009.html">Thread Prev</a>][<a href="msg00011.html">Thread Next</a>][<a href="maillist.html#00010">Date Index</a>][<a href="threads.html#00010">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>A cat supporting infinities, nans, and -0.0</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: &lt;<a href="mailto:srfi-54@DOMAIN.HIDDEN">srfi-54@xxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Subject</em>: A cat supporting infinities, nans, and -0.0</li>
<li><em>From</em>: &quot;soo&quot; &lt;<a href="mailto:tilde@DOMAIN.HIDDEN">tilde@xxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Thu, 6 Dec 2007 14:20:28 +0900</li>
<li><em>Delivered-to</em>: <a href="mailto:srfi-54@DOMAIN.HIDDEN">srfi-54@xxxxxxxxxxxxxxxxx</a></li>
<li><em>Importance</em>: Normal</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>This is a CAT for both implementations that support non-finites, -0.0,
and complex numbers and implementations that don't support them.

--
Joo ChurlSoo 
</pre><pre>
The optional arguments of the CAT procedure of SRFI 54 are divided into three
groups; arguments only for the number type of &lt;object&gt;, arguments for all
types except the number type of &lt;object&gt;, and arguments for all types of
&lt;object&gt;.  This complexity can make users confused.  Those of this revision
are divided into two groups; arguments only for the number type of &lt;object&gt;
and arguments for all types of &lt;object&gt;.  This simplicity also makes &lt;writer&gt;
to be able to substitute for &lt;converter&gt;.  The &lt;precision&gt; actually serves as
~G of Common Lisp's FORMAT and %G of C's PRINTF.  The &lt;point&gt; of this
revision, an additional optional argument, serves as ~F or ~E of Common Lisp's
FORMAT and %F or %E of C's PRINTF.  The specifications of &lt;take&gt;, &lt;pipe&gt;, and
&lt;separator&gt; are changed to support diverse functions.  The &lt;string&gt; is removed
for efficiency.  The STRING-APPEND or STRING-APPEND/DISPLAY can be used
instead.

The CAT procedure of this revision is extended in following aspects compared
with that of SRFI 54:
1. All optional arguments can be applied to the number type of &lt;object&gt;.
2. The default value of &lt;writer&gt; is DISPLAY procedure.
3. An optional argument, &lt;point&gt; ('fixnum or 'flonum), is added.
4. The &lt;take&gt; is changed from a list to a pair, and its elements are exact
   integers or strings.
5. The &lt;pipe&gt; is changed from a list to a pair.
6. The second element of &lt;separator&gt; is changed from a positive exact integer
   to a non-zero exact integer.
7. The &lt;converter&gt; is removed (incompatible change).
8. The &lt;string&gt; is removed (incompatible change).


Specification

(CAT &lt;object&gt;
     [&lt;width&gt;] [&lt;writer&gt;] [&lt;port&gt;] [&lt;char&gt;] [&lt;take&gt;] [&lt;pipe&gt;] [&lt;separator&gt;]
     [&lt;point%&gt;] [&lt;precision%&gt;] [&lt;radix%&gt;] [&lt;sign%&gt;] [&lt;exactness%&gt;])

The &lt;point%&gt; &lt;precision%&gt; &lt;radix%&gt; &lt;sign%&gt; &lt;exactness%&gt; are effective only for
the number type of &lt;object&gt;.
The order of all optional arguments does not matter.
The CAT processes the optional arguments in the following order; &lt;writer&gt;,
&lt;exactness&gt;, &lt;point&gt;, &lt;precision&gt;, &lt;radix&gt;, &lt;separator&gt;, &lt;sign&gt;, &lt;pipe&gt;,
&lt;take&gt;, &lt;width&gt;, &lt;char&gt;, &lt;port&gt;.

1.  The &lt;object&gt; is any Scheme object.

2.  The &lt;width&gt; is an exact integer whose absolute value specifies the width
    of the resulting string.  When the resulting string has fewer characters
    than the absolute value of &lt;width&gt;, it is placed rightmost with the rest
    being padded with &lt;char&gt;s, if &lt;width&gt; is positive, or it is placed
    leftmost with the rest being padded with &lt;char&gt;s, if &lt;width&gt; is negative.
    On the other hand, when the resulting string has more characters than the
    absolute value of &lt;width&gt;, the &lt;width&gt; is ignored.  The default value is
    0.

3.  The &lt;writer&gt; is a procedure of two arguments; &lt;object&gt; and a string port.
    It writes &lt;object&gt; to the string port.  The default value is DISPLAY
    procedure.  If you want any objects to be displayed in your own way, you
    have to define your own &lt;writer&gt;.  Otherwise, they are displayed simply in
    their evaluated forms.  When &lt;writer&gt; except DISPLAY and WRITE procedures
    is used, the optional arguments that are effective only for the number
    type of &lt;object&gt; become ineffective.
   
4.  The &lt;port&gt; is an output port or a boolean.  If an output port is
    specified, the resulting string is output into the port.  If &lt;port&gt; is #t,
    the output port is current output port.  If &lt;port&gt; is #f, the resulting
    string is returned.  The default value is #f.

5.  The &lt;char&gt; is a padding character.  The default value is #\space.

6.  The &lt;take&gt; is a list whose elements are one or two exact integers or
    strings, or a pair whose car and cdr values are exact integers or strings;
    m and n, and the absolute values of m and n are M and N, respectively.
    First, when the first element is an exact integer, the resulting string
    takes from the left m-characters, if it is positive, or all the characters
    but M-characters, if non-positive, and when the first element is a string,
    the element is prefixed.  Second,
    1. In case that &lt;take&gt; is a list of single element:
       The resulting string is returned.
    2. In case that &lt;take&gt; is a list of two elements:
       When the second element is an exact integer, the resulting string takes
       from the right n-characters of the string that is processed by the
       first element, if it is non-negative, or all the characters but
       N-characters, if negative.
       When the second element is a string, the element is postfixed to the
       string that is processed by the first element.
    3. In case that &lt;take&gt; is a pair:
       When the cdr element is an exact integer, the other resulting string
       takes from the right n-characters of the initial string that is not
       processed by the first element, if it is non-negative, or all the
       characters but N-characters, if negative.  Then, the two strings are
       concatenated.
       When the cdr element is a string, the other resulting string is made by
       postfixing the element to the initial string that is not processed by
       the first element.  Then, the two strings are concatenated.
   
7.  The &lt;pipe&gt; is a pair which is composed of one or more procedures.  Each
    procedure takes at least one string argument and returns a string.  When
    &lt;pipe&gt; is a list, one procedure connects with another as a pipe.  On the
    other hand, when &lt;pipe&gt; is a pair, each procedure takes the non-processed
    initial string as an argument, and the returned strings are concatenated.

8.  The &lt;separator&gt; is a list whose first element is a character serving as a
    separator and second element is a non-zero exact integer; n, and the
    absolute value of n is N.  The resulting string is separated in every
    N-characters of the resulting string from right end, if n is positive, or
    from left end, if n is negative.  Even if n is a negative integer, its
    absolute value is used for the number type of &lt;object&gt;.  When the integer
    is omitted, the &lt;separator&gt; is effective only for the number type of
    &lt;object&gt; and its default value is 3.

9.  The &lt;point&gt; is a symbol: fixnum or flonum.  Each returns a string of
    decimal fraction or exponential representation.

10. The &lt;precision&gt; is an inexact integer whose absolute value specifies the
    number of decimal digits after a decimal point.  If the &lt;precision&gt; is a
    non-negative integer, an exact sign is prefixed to the resulting string as
    needed.

11. The &lt;radix&gt; is a symbol: binary, octal, decimal, or hexadecimal.  Each
    radix sign except decimal is prefixed to the resulting string.  The
    default value is decimal.

12. If &lt;sign&gt; is a symbol that takes the form of 'sign, and &lt;object&gt; is a
    positive number without a positive sign, the positive sign is prefixed to
    the resulting string.

13. The &lt;exactness&gt; is a symbol: exact or inexact.  Each returns a string of
    exact or inexact representation.


Examples

(cat 129.995 -10 2.)		-&gt; &quot;130.00    &quot;
(cat 129.995 10 2.)		-&gt; &quot;    130.00&quot;
(cat 129 2.)		-&gt; &quot;#e129.00&quot;
(cat 129 -2.)		-&gt; &quot;129.00&quot;
(cat 129 10 #\* 'octal 'sign)		-&gt; &quot;****#o+201&quot;
(cat 129 10 #\0 'octal 'sign)		-&gt; &quot;#o+0000201&quot;
(cat 10.5 'octal)			     -&gt; &quot;#i#o25/2&quot;
(cat 10.5 'octal 'exact)		     -&gt; &quot;#o25/2&quot;
(cat 10.5 'octal (list string-upcase))	     -&gt; &quot;#I#O25/2&quot;
(cat 10.5 'octal (list string-upcase) '(-4)) -&gt; &quot;25/2&quot;
(cat 123000000 'flonum)		-&gt; &quot;1.23e+8&quot;
(cat 1.23456789e+25 'fixnum)	-&gt; &quot;12345678900000000000000000.0&quot;
(cat 129.995 10 2. 'sign '(&quot;$&quot;))		 -&gt; &quot;  $+130.00&quot;
(cat 129.995 10 2. 'sign '(&quot;$&quot; -3))		 -&gt; &quot;     $+130&quot;
(cat 129.995 10 2. '(&quot;The number is &quot; &quot;.&quot;))	 -&gt; &quot;The number is 130.00.&quot;
(cat &quot;abcdefg&quot; '(3 . 1))	-&gt; &quot;abcg&quot;
(cat &quot;abcdefg&quot; '(3 1))		-&gt; &quot;c&quot;
(cat 123456789 'sign '(#\,))		-&gt; &quot;+123,456,789&quot;
(cat &quot;abcdefg&quot; 'sign '(#\,))		-&gt; &quot;abcdefg&quot;
(cat &quot;abcdefg&quot; 'sign '(#\: 2))		-&gt; &quot;a:bc:de:fg&quot;
(cat &quot;abcdefg&quot; 'sign '(#\: -2))		-&gt; &quot;ab:cd:ef:g&quot;
(cat '(#\a &quot;str&quot; s))		      -&gt; &quot;(a str s)&quot;
(cat '(#\a &quot;str&quot; s) '(-1 -1))	      -&gt; &quot;a str s&quot;
(cat '(#\a &quot;str&quot; s) write)	      -&gt; &quot;(#\\a \&quot;str\&quot; s)&quot;
(cat 'String 10 (current-output-port))	 -&gt;     String
(cat 'String 10 #t)			 -&gt;	String

(define-record-type :example
  (make-example num str)
  example?
  (num get-num set-num!)
  (str get-str set-str!))

(define (record-writer object string-port)
  (if (example? object)
      (begin (display (get-num object) string-port)
	     (display &quot;-&quot; string-port)
	     (display (get-str object) string-port))
      (display object string-port)))

(define (record-display object string-port)
  (display (get-num object) string-port)
  (display &quot;-&quot; string-port)
  (display (get-str object) string-port))

(define ex (make-example 123 &quot;string&quot;))
(cat ex 20)			-&gt; &quot;  #&lt;struct::example&gt;&quot;
(cat ex 20 record-writer)	-&gt; &quot;          123-string&quot;
(cat &quot;str&quot; 20 record-writer)	-&gt; &quot;                 str&quot;

(let ((plus 12345678.901)
      (minus -123456.789)
      (ex (make-example 1234 &quot;ex&quot;))
      (file &quot;today.txt&quot;))
  (for-each (lambda (x y)
	      (cat x 10 #t)
	      (cat y 15 (if (example? y) record-display display) 2. '(#\,) #t)
	      (newline))
	    (list &quot;plus: &quot; &quot;minus: &quot; &quot;net: &quot; &quot;ex: &quot; &quot;file: &quot;)
	    (list plus minus (+ plus minus) ex file)))
-&gt;
    plus:   12,345,678.90
   minus:     -123,456.79
     net:   12,222,222.11
      ex:         1234-ex
    file:       today.txt


Implementation

The implementation below requires SRFI 6 (Basic string ports) and SRFI 23
(Error reporting mechanism).

(define (object-&gt;string object writer)
  (get-output-string
   (let ((str-port (open-output-string)))
     (writer object str-port)
     str-port)))

(define (take-both-end str take)
  (let ((left (car take)))
    (cond
     ((string? left)
      (if (null? (cdr take))
	  (string-append left str)
	  (if (list? take)
	      (let ((right (cadr take)))
		(if (string? right)
		    (string-append left str right)
		    (if (zero? right)
			&quot;&quot;
			(let* ((lt-str (string-append left str))
			       (lt-len (string-length lt-str)))
			  (if (negative? right)
			      (if (positive? (+ lt-len right))
				  (substring lt-str 0 (+ lt-len right))
				  &quot;&quot;)
			      (if (&lt; right lt-len)
				  (substring lt-str (- lt-len right) lt-len)
				  lt-str))))))
	      (let ((right (cdr take)))
		(if (string? right)
		    (string-append left str str right)
		    (if (zero? right)
			(string-append left str)
			(let ((len (string-length str)))
			  (if (negative? right)
			      (if (positive? (+ len right))
				  (string-append
				   left str (substring str 0 (+ len right)))
				  (string-append left str))
			      (if (&lt; right len)
				   (string-append
				    left str (substring str (- len right) len))
				   (string-append left str str))))))))))
     ((zero? left)
      (if (null? (cdr take))
	  str
	  (if (list? take)
	      (let ((right (cadr take)))
		(if (string? right)
		    (string-append str right)
		    (if (zero? right)
			&quot;&quot;
			(let ((lt-len (string-length str)))
			  (if (negative? right)
			      (if (positive? (+ lt-len right))
				  (substring str 0 (+ lt-len right))
				  &quot;&quot;)
			      (if (&lt; right lt-len)
				  (substring str (- lt-len right) lt-len)
				  str))))))
	      (let ((right (cdr take)))
		(if (string? right)
		    (string-append str str right)
		    (if (zero? right)
			str
			(let ((len (string-length str)))
			  (if (negative? right)
			      (if (positive? (+ len right))
				  (string-append
				   str (substring str 0 (+ len right)))
				  str)
			      (if (&lt; right len)
				   (string-append
				    str (substring str (- len right) len))
				   (string-append str str))))))))))
     (else
      (let* ((len (string-length str))
	     (lt-str (if (positive? left)
			 (if (&lt; left len)
			     (substring str 0 left)
			     str)
			 (if (positive? (+ len left))
			     (substring str (abs left) len)
			     &quot;&quot;))))
	(if (null? (cdr take))
	    lt-str
	    (if (list? take)
		(let ((right (cadr take)))
		  (if (string? right)
		      (string-append lt-str right)
		      (if (zero? right)
			  &quot;&quot;
			  (let ((lt-len (string-length lt-str)))
			    (if (negative? right)
				(if (positive? (+ lt-len right))
				    (substring lt-str 0 (+ lt-len right))
				    &quot;&quot;)
				(if (&lt; right lt-len)
				    (substring lt-str (- lt-len right) lt-len)
				    lt-str))))))
		(let ((right (cdr take)))
		  (if (string? right)
		      (string-append lt-str str right)
		      (if (zero? right)
			  lt-str
			  (if (negative? right)
			      (if (positive? (+ len right))
				  (string-append
				   lt-str (substring str 0 (+ len right)))
				   lt-str)
			       (if (&lt; right len)
				   (string-append
				    lt-str (substring str (- len right) len))
				   (string-append lt-str str)))))))))))))

;; (define (take-both-end str take)
;;   (let* ((left (car take))
;; 	 (len (string-length str))
;; 	 (lt-str (cond
;; 		  ((string? left) (string-append left str))
;; 		  ((zero? left) str)
;; 		  ((positive? left)
;; 		   (if (&lt; left len)
;; 		       (substring str 0 left)
;; 		       str))
;; 		  (else
;; 		   (if (positive? (+ len left))
;; 		       (substring str (abs left) len)
;; 		       &quot;&quot;)))))
;;     (if (null? (cdr take))
;; 	lt-str
;; 	(if (list? take)
;; 	    (let ((lt-len (string-length lt-str))
;; 		  (right (cadr take)))
;; 	      (cond
;; 	       ((string? right) (string-append lt-str right))
;; 	       ((zero? right) &quot;&quot;)
;; 	       ((negative? right)
;; 		(if (positive? (+ lt-len right))
;; 		    (substring lt-str 0 (+ lt-len right))
;; 		    &quot;&quot;))
;; 	       (else
;; 		(if (&lt; right lt-len)
;; 		    (substring lt-str (- lt-len right) lt-len)
;; 		    lt-str))))
;; 	    (let ((right (cdr take)))
;; 	      (cond
;; 	       ((string? right) (string-append lt-str str right))
;; 	       ((zero? right) lt-str)
;; 	       ((negative? right)
;; 		(if (positive? (+ len right))
;; 		    (string-append lt-str (substring str 0 (+ len right)))
;; 		    lt-str))
;; 	       (else
;; 		(if (&lt; right len)
;; 		    (string-append lt-str (substring str (- len right) len))
;; 		    (string-append lt-str str)))))))))

(define (str-char-index str char start end)
  (let lp ((n start))
    (if (= n end)
	#f
	(if (char=? char (string-ref str n))
	    n
	    (lp (+ n 1))))))

(define (str-numeric-index str start end)
  (let lp ((n start))
    (if (= n end)
	#f
	(if (char-numeric? (string-ref str n))
	    n
	    (lp (+ n 1))))))

(define (str-numeric? str start end)
  (let lp ((n start))
    (if (= n end)
	#t
	(if (char-numeric? (string-ref str n))
	    (lp (+ n 1))
	    #f))))

(define (fixnum-string-separate str sep num sig)
  (let* ((len (string-length str))
	 (dot-index (str-char-index str #\. 1 len)))
    (if dot-index
	(if sig
	    (if (and (str-numeric? str 1 dot-index)
		     (str-numeric? str (+ 1 dot-index) len))
		(string-append
		 (apply string-append
			(let loop ((ini 0)
				   (pos (+ 1 (let ((pos (remainder
							 (- dot-index 1) num)))
					       (if (zero? pos) num pos)))))
			  (if (&lt; pos dot-index)
			      (cons (substring str ini pos)
				    (cons sep (loop pos (+ pos num))))
			      (list (substring str ini dot-index)))))
		 &quot;.&quot;
		 (apply string-append
			(let loop ((ini (+ 1 dot-index))
				   (pos (+ 1 dot-index num)))
			  (if (&lt; pos len)
			      (cons (substring str ini pos)
				    (cons sep (loop pos (+ pos num))))
			      (list (substring str ini len))))))
		str)
	    (if (and (str-numeric? str 0 dot-index)
		     (str-numeric? str (+ 1 dot-index) len))
		(string-append
		 (apply string-append
			(let loop ((ini 0)
				   (pos (let ((pos (remainder dot-index num)))
					  (if (zero? pos) num pos))))
			  (if (&lt; pos dot-index)
			      (cons (substring str ini pos)
				    (cons sep (loop pos (+ pos num))))
			      (list (substring str ini dot-index)))))
		 &quot;.&quot;
		 (apply string-append
			(let loop ((ini (+ 1 dot-index))
				   (pos (+ 1 dot-index num)))
			  (if (&lt; pos len)
			      (cons (substring str ini pos)
				    (cons sep (loop pos (+ pos num))))
			      (list (substring str ini len))))))
		str))
	(if sig
	    (if (str-numeric? str 1 len)
		(apply string-append
		       (let loop ((ini 0)
				  (pos (+ 1 (let ((pos (remainder (- len 1)
								  num)))
					      (if (zero? pos) num pos)))))
			 (if (&lt; pos len)
			     (cons (substring str ini pos)
				   (cons sep (loop pos (+ pos num))))
			     (list (substring str ini len)))))
		str)
	    (if (str-numeric? str 0 len)
		(apply string-append
		       (let loop ((ini 0)
				  (pos (let ((pos (remainder len num)))
					 (if (zero? pos) num pos))))
			 (if (&lt; pos len)
			     (cons (substring str ini pos)
				   (cons sep (loop pos (+ pos num))))
			     (list (substring str ini len)))))
		str)))))

(define (separate str sep num)
  (let ((len (string-length str))
	(n (abs num)))
    (apply string-append
	   (let loop ((ini 0)
		      (pos (if (negative? num)
			       n
			       (let ((pos (remainder len n)))
				 (if (zero? pos) n pos)))))
	     (if (&lt; pos len)
		 (cons (substring str ini pos)
		       (cons sep (loop pos (+ pos n))))
		 (list (substring str ini len)))))))

(define (every? pred ls)		;not for list but for pair &amp; others
  (let lp ((ls ls))
    (if (pair? ls)
	(if (pred (car ls))
	    (lp (cdr ls))
	    #f)
	(if (null? ls)
	    #t
	    (if (pred ls)
		#t
		#f)))))

(define (every-within-number? pred ls n) ;not for list but for pair &amp; others
  (let lp ((ls ls) (num 0))
    (if (pair? ls)
	(if (and (&lt; num n) (pred (car ls)))
	    (lp (cdr ls) (+ num 1))
	    #f)
	(if (null? ls)
	    #t
	    (if (and (&lt; num n) (pred ls))
		#t
		#f)))))

(define (exact-integer? n)
  (and (integer? n) (exact? n)))

(define (exact-integer/string? ns)
  (or (and (integer? ns)
	   (exact? ns))
      (string? ns)))

(define (mold str pre)
  (let* ((len (string-length str))
	 (ind (str-char-index str #\. 1 (- len 1))))
    (if ind
	(let ((d-len (- len (+ ind 1))))
	  (cond
	   ((= d-len pre) str)
	   ((&lt; d-len pre) (string-append str (make-string (- pre d-len) #\0)))
	   ;;((char&lt;? #\4 (string-ref str (+ 1 ind pre)))
	   ;;(let ((com (expt 10 pre)))
	   ;;  (number-&gt;string (/ (round (* (string-&gt;number str) com)) com))))
	   ((or (char&lt;? #\5 (string-ref str (+ 1 ind pre)))
		(and (char=? #\5 (string-ref str (+ 1 ind pre)))
		     (or (&lt; (+ 1 pre) d-len)
			 (memv (string-ref str (+ ind (if (= 0 pre) -1 pre)))
			       '(#\1 #\3 #\5 #\7 #\9)))))
	    (apply
	     string
	     (let* ((minus (char=? #\- (string-ref str 0)))
		    (str (substring str (if minus 1 0) (+ 1 ind pre)))
		    (char-list
		     (reverse
		      ;;(let lp ((index (- (string-length str) 1))
		      (let lp ((index (- (+ ind pre) (if minus 1 0)))
			       (raise #t))
			(if (= -1 index)
			    (if raise '(#\1) '())
			    (let ((chr (string-ref str index)))
			      (if (char=? #\. chr)
				  (cons chr (lp (- index 1) raise))
				  (if raise
				      (if (char=? #\9 chr)
					  (cons #\0 (lp (- index 1) raise))
					  (cons (integer-&gt;char
						 (+ 1 (char-&gt;integer chr)))
						(lp (- index 1) #f)))
				      (cons chr (lp (- index 1) raise))))))))))
	       (if minus (cons #\- char-list) char-list))))
	   (else
	    (substring str 0 (+ 1 ind pre)))))
	(string-append str &quot;.&quot; (make-string pre #\0)))))

(define (mold-non-finites str pre)
  (let* ((len (string-length str))
	 (ind (str-char-index str #\. 1 (- len 1)))
	 (d-len (- len (+ ind 1))))
    (if (char-numeric? (string-ref str (- ind 1)))
	(cond
	 ((= d-len pre) str)
	 ((&lt; d-len pre) (string-append str (make-string (- pre d-len) #\0)))
	 ;;((char&lt;? #\4 (string-ref str (+ 1 ind pre)))
	 ;;(let ((com (expt 10 pre)))
	 ;;  (number-&gt;string (/ (round (* (string-&gt;number str) com)) com))))
	 ((or (char&lt;? #\5 (string-ref str (+ 1 ind pre)))
	      (and (char=? #\5 (string-ref str (+ 1 ind pre)))
		   (or (&lt; (+ 1 pre) d-len)
		       (memv (string-ref str (+ ind (if (= 0 pre) -1 pre)))
			     '(#\1 #\3 #\5 #\7 #\9)))))
	  (apply
	   string
	   (let* ((minus (char=? #\- (string-ref str 0)))
		  (str (substring str (if minus 1 0) (+ 1 ind pre)))
		  (char-list
		   (reverse
		    ;;(let lp ((index (- (string-length str) 1))
		    (let lp ((index (- (+ ind pre) (if minus 1 0)))
			     (raise #t))
		      (if (= -1 index)
			  (if raise '(#\1) '())
			  (let ((chr (string-ref str index)))
			    (if (char=? #\. chr)
				(cons chr (lp (- index 1) raise))
				(if raise
				    (if (char=? #\9 chr)
					(cons #\0 (lp (- index 1) raise))
					(cons (integer-&gt;char
					       (+ 1 (char-&gt;integer chr)))
					      (lp (- index 1) #f)))
				    (cons chr (lp (- index 1) raise))))))))))
	     (if minus (cons #\- char-list) char-list))))
	 (else
	  (substring str 0 (+ 1 ind pre))))
	(error &quot;cat: infinities or nans cannot have precisions&quot;))))

(define (e-mold str pre)
  (let* ((len (string-length str))
	 (e-index (str-char-index str #\e 1 (- len 1))))
    (if e-index
	(string-append (mold (substring str 0 e-index) pre)
		       (substring str e-index len))
	(mold-non-finites str pre))))

(define (flonum-mold str pre)
  (let* ((len (string-length str))
	 (e-index (str-char-index str #\e 1 (- len 1))))
    (string-append (mold (substring str 0 e-index) pre)
		   (substring str e-index len))))

(define (remove-zero str len negative)
  (if negative
      (let lp ((n 1))
	(let ((c (string-ref str n)))
	  (cond
	   ((char=? #\0 c) (lp (+ 1 n)))
	   ((char=? #\. c)
	    (if (= n 2)
		str
		(string-append &quot;-&quot; (substring str (- n 1) len))))
	   (else
	    (if (= n 1)
		str
		(string-append &quot;-&quot; (substring str n len)))))))
      (let lp ((n 0))
	(let ((c (string-ref str n)))
	  (cond
	   ((char=? #\0 c) (lp (+ 1 n)))
	   ((char=? #\. c)
	    (if (= n 1)
		str
		(substring str (- n 1) len)))
	   (else
	    (if (zero? n)
		str
		(substring str n len))))))))

(define (real-&gt;fixnum-string n)
  (let* ((str (number-&gt;string (exact-&gt;inexact n)))
	 (len (string-length str))
	 (e-index (str-char-index str #\e 1 (- len 1))))
    (if e-index
	(let ((e-number (string-&gt;number (substring str (+ 1 e-index) len)))
	      (d-index (str-char-index str #\. 1 e-index)))
	  (if (negative? e-number)
	      (if d-index
		  (if (negative? n)
		      (let ((p-number (- (abs e-number) (- d-index 1))))
			(if (negative? p-number)
			    (let ((pnumber (+ 1 (abs p-number))))
			      (string-append (substring str 0 pnumber)
					     &quot;.&quot;
					     (substring str pnumber d-index)
					     (substring str (+ 1 d-index)
							e-index)))
			    (string-append &quot;-0.&quot;
					   (make-string p-number #\0)
					   (substring str 1 d-index)
					   (substring str (+ 1 d-index)
						      e-index))))
		      (let ((p-number (- (abs e-number) d-index)))
			(if (negative? p-number)
			    (let ((pnumber (abs p-number)))
			      (string-append (substring str 0 pnumber)
					     &quot;.&quot;
					     (substring str pnumber d-index)
					     (substring str (+ 1 d-index)
							e-index)))
			    (string-append &quot;0.&quot;
					   (make-string p-number #\0)
					   (substring str 0 d-index)
					   (substring str (+ 1 d-index)
						      e-index)))))
		  (if (negative? n)
		      (let ((p-number (- (abs e-number) (- e-index 1))))
			(if (negative? p-number)
			    (let ((pnumber (+ 1 (abs p-number))))
			      (string-append (substring str 0 pnumber)
					     &quot;.&quot;
					     (substring str pnumber e-index)))
			    (string-append &quot;-0.&quot;
					   (make-string p-number #\0)
					   (substring str 1 e-index))))
		      (let ((p-number (- (abs e-number) e-index)))
			(if (negative? p-number)
			    (let ((pnumber (abs p-number)))
			      (string-append (substring str 0 pnumber)
					     &quot;.&quot;
					     (substring str pnumber e-index)))
			    (string-append &quot;0.&quot;
					   (make-string p-number #\0)
					   (substring str 0 e-index))))))
	      (if d-index
		  (let ((p-number (- e-number (- e-index (+ d-index 1)))))
		    (if (negative? p-number)
			;; A procedure REMOVE-ZERO is unnecessary
			;; due to number-&gt;string.
			;; 0.00123 -&gt; 00.0123 or 000123
			;; -0.00123 -&gt; -00.0123 or -000123
			;;(remove-zero (string-append
			;;	      (substring str 0 d-index)
			;;	      (substring str (+ 1 d-index)
			;;			 (+ 1 d-index e-number))
			;;	      &quot;.&quot;
			;;	      (substring str (+ 1 d-index e-number)
			;;			 e-index))
			;;	     e-index
			;;	     (&lt; n 0))
			(string-append (substring str 0 d-index)
				       (substring str (+ 1 d-index)
						  (+ 1 d-index e-number))
				       &quot;.&quot;
				       (substring str (+ 1 d-index e-number)
						  e-index))
			;; A procedure REMOVE-ZERO is unnecessary
			;; due to number-&gt;string.
			;; 0.00123 -&gt; 00.0123 or 000123
			;; -0.00123 -&gt; -00.0123 or -000123
			;;(remove-zero (string-append
			;;	      (substring str 0 d-index)
			;;	      (substring str (+ 1 d-index) e-index)
			;;	      (make-string p-number #\0)
			;;	      &quot;.0&quot;)
			;;	     (+ e-index p-number 1)
			;;	     (&lt; n 0))))
			(string-append (substring str 0 d-index)
				       (substring str (+ 1 d-index) e-index)
				       (make-string p-number #\0) &quot;.0&quot;)))
		  (string-append (substring str 0 e-index)
				 (make-string e-number #\0)
				 &quot;.0&quot;))))
	(let ((d-index (str-char-index str #\. 1 (- len 1))))
	  (if (char-numeric? (string-ref str (- d-index 1)))
	      str
	      (error &quot;cat: infinities or nans cannot be changed into fixed-point numbers&quot;))))))

(define (non-0-index str start)
  (let lp ((n start))
    (if (char=? #\0 (string-ref str n))
	(lp (+ 1 n))
	 n)))

(define (non-0-index-right str end)
  (let lp ((n (- end 1)))
    (if (char=? #\0 (string-ref str n))
	(lp (- n 1))
	n)))

(define (non-0-dot-index-right str end)
  (let lp ((n (- end 1)))
    (let ((c (string-ref str n)))
      (if (or (char=? #\0 c) (char=? #\. c))
	  (lp (- n 1))
	  n))))

(define (real-&gt;flonum-string n)
  (let* ((str (number-&gt;string (exact-&gt;inexact n)))
	 (len (string-length str))
	 (e-index (str-char-index str #\e 1 (- len 1))))
    (if e-index
	str
	(let ((d-index (str-char-index str #\. 1 (- len 1))))
	  (if (&lt; -1 n 1)
	      (if (zero? n)
		  (string-append str &quot;e+0&quot;) ;for -0.0 or +0.0
		  (let ((n-index (non-0-index str (+ 1 d-index))))
		    (string-append (if (negative? n) &quot;-&quot; &quot;&quot;)
				   (substring str n-index (+ 1 n-index))
				   &quot;.&quot;
				   (if (= n-index (- len 1))
				       &quot;0&quot;
				       (substring str (+ 1 n-index) len))
				   &quot;e-&quot;
				   (number-&gt;string (- n-index d-index)))))
	      ;;(let ((n-index (non-0-dot-index-right str len)))
	      ;;  (if (&lt; n-index d-index)
	      (let ((n-index (non-0-index-right str len)))
		(if (= n-index d-index)
		    (let ((n-index (non-0-index-right str d-index)))
		      (if (char-numeric? (string-ref str n-index))
			  (if (negative? n)
			      (string-append (substring str 0 2)
					     &quot;.&quot;
					     (if (= n-index 1)
						 &quot;0&quot;
						 (substring str 2
							    (+ 1 n-index)))
					     &quot;e+&quot;
					     (number-&gt;string (- d-index 2)))
			      (string-append (substring str 0 1)
					     &quot;.&quot;
					     (if (= n-index 0)
						 &quot;0&quot;
						 (substring str 1
							    (+ 1 n-index)))
					     &quot;e+&quot;
					     (number-&gt;string (- d-index 1))))
			  (error &quot;cat: infinities or nans cannot be changed into floating-point numbers&quot;)))
		    (if (negative? n)
			(string-append (substring str 0 2)
				       &quot;.&quot;
				       (substring str 2 d-index)
				       (substring str (+ 1 d-index)
						  (+ 1 n-index))
				       &quot;e+&quot;
				       (number-&gt;string (- d-index 2)))
			(string-append (substring str 0 1)
				       &quot;.&quot;
				       (substring str 1 d-index)
				       (substring str (+ 1 d-index)
						  (+ 1 n-index))
				       &quot;e+&quot;
				       (number-&gt;string (- d-index 1)))))))))))

(define-syntax wow-cat-end
  (syntax-rules ()
    ((wow-cat-end z n)
     (car z))
    ((wow-cat-end z n t)
     (let ((n (car z)))
       (if t n (error &quot;cat: too many argument&quot; z))))
    ((wow-cat-end z n t ts)
     (let ((n (car z)))
       (if t ts (error &quot;cat: too many argument&quot; z))))
    ((wow-cat-end z n t ts fs)
     (let ((n (car z)))
       (if t ts fs)))))

(define-syntax wow-cat!
  (syntax-rules ()
    ((wow-cat! z n d)
     (let ((n (car z)))
       (set! z (cdr z))
       n))
    ((wow-cat! z n d t)
     (let ((n (car z)))
       (if t
	   (begin (set! z (cdr z)) n)
	   (let lp ((head (list n)) (tail (cdr z)))
	     (if (null? tail)
		 d
		 (let ((n (car tail)))
		   (if t
		       (begin (set! z (append (reverse head) (cdr tail))) n)
		       (lp (cons n head) (cdr tail)))))))))
    ((wow-cat! z n d t ts)
     (let ((n (car z)))
       (if t
	   (begin (set! z (cdr z)) ts)
	   (let lp ((head (list n)) (tail (cdr z)))
	     (if (null? tail)
		 d
		 (let ((n (car tail)))
		   (if t
		       (begin (set! z (append (reverse head) (cdr tail))) ts)
		       (lp (cons n head) (cdr tail)))))))))
    ((wow-cat! z n d t ts fs)
     (let ((n (car z)))
       (if t
	   (begin (set! z (cdr z)) ts)
	   (begin (set! z (cdr z)) fs))))))

(define-syntax %alet-cat*
  (syntax-rules ()
    ((%alet-cat* z ((n d t ...)) bd ...)
     (let ((n (if (null? z)
		  d
		  (if (null? (cdr z))
		      (wow-cat-end z n t ...)
		      (error &quot;cat: too many arguments&quot; (cdr z))))))
       bd ...))
    ((%alet-cat* z ((n d t ...) . e) bd ...)
     (let ((n (if (null? z)
		  d
		  (wow-cat! z n d t ...))))
       (%alet-cat* z e bd ...)))
    ((%alet-cat* z e bd ...)
     (let ((e z)) bd ...))))

(define-syntax alet-cat*
  (syntax-rules ()
    ((alet-cat* z (a . e) bd ...)
     (let ((y z))
       (%alet-cat* y (a . e) bd ...)))))

(define (cat object . rest)
  (if (null? rest)
      (cond
       ((number? object) (number-&gt;string object))
       ((symbol? object) (symbol-&gt;string object))
       ((boolean? object) (if object &quot;#t&quot; &quot;#f&quot;))
       ((char? object) (string object))
       ((string? object) object)
       (else (object-&gt;string object display)))
      (alet-cat* rest
	((width 0 (and (integer? width) (exact? width)))
	 (writer display (procedure? writer))
	 (port #f (or (boolean? port) (output-port? port))
	       (if (eq? port #t) (current-output-port) port))
	 (char #\space (char? char))
	 (precision #f (and (integer? precision) (inexact? precision)))
	 (radix 'decimal (memq radix '(decimal octal binary hexadecimal)))
	 (point #f (memq point '(fixnum flonum)))
	 (sign #f (eq? 'sign sign))
	 (exactness #f (memq exactness '(exact inexact)))
	 ;;(take #f (and (pair? take)
	 ;;	       (every-within-number? exact-integer/string? 2)))
	 (take #f (and (pair? take)
		       (exact-integer/string? (car take))
		       (or (null? (cdr take))
			   (and (list? take)
				(null? (cddr take))
				(exact-integer/string? (cadr take)))
			   (exact-integer/string? (cdr take)))))
	 (pipe #f (and (pair? pipe) (every? procedure? pipe)))
	 (separator #f (and (pair? separator)
			    (char? (car separator))
			    (or (null? (cdr separator))
				(and (list? separator)
				     (null? (cddr separator))
				     (exact-integer? (cadr separator)))))))
	(let ((str
	       (if (number? object)
		   (if (or (eq? writer display)
			   (eq? writer write))
		       (let* ((inexact-sign
			       (and (not (eq? radix 'decimal))
				    (or (and (or precision point)
					     (error &quot;cat: non-decimal cannot have a decimal point&quot;))
					(and (inexact? object)
					     (not (eq? exactness 'exact)))
					(eq? exactness 'inexact))
				    &quot;#i&quot;))
			      (str
			       (cond
				(point
				 (if (eq? point 'fixnum)
				     (if precision
					 (let ((p (inexact-&gt;exact
						   (abs precision))))
					   (if (real? object)
					       (mold
						(real-&gt;fixnum-string object) p)
					       (let ((imag-str
						      (real-&gt;fixnum-string
						       (imag-part object))))
						 (string-append
						  (mold
						   (real-&gt;fixnum-string
						    (real-part object)) p)
						  ;; for N+0.0i
						  (if (char-numeric?
						       (string-ref imag-str 0))
						      &quot;+&quot; &quot;&quot;)
						  (mold imag-str p)
						  &quot;i&quot;))))
					 (if (real? object)
					     (real-&gt;fixnum-string object)
					     (let ((imag-str
						    (real-&gt;fixnum-string
						     (imag-part object))))
					       (string-append
						(real-&gt;fixnum-string
						 (real-part object))
						;; for N+0.0i
						(if (char-numeric?
						     (string-ref imag-str 0))
						    &quot;+&quot; &quot;&quot;)
						imag-str
						&quot;i&quot;))))
				     (if precision ;'flonum
					 (let ((p (inexact-&gt;exact
						   (abs precision))))
					   (if (real? object)
					       (flonum-mold
						(real-&gt;flonum-string object) p)
					       (let ((imag-str
						      (real-&gt;flonum-string
						       (imag-part object))))
						 (string-append
						  (flonum-mold
						   (real-&gt;flonum-string
						    (real-part object)) p)
						  ;; for N+0.0i
						  (if (char-numeric?
						       (string-ref imag-str 0))
						      &quot;+&quot; &quot;&quot;)
						  (flonum-mold imag-str p)
						  &quot;i&quot;))))
					 (if (real? object)
					     (real-&gt;flonum-string object)
					     (let ((imag-str
						    (real-&gt;flonum-string
						     (imag-part object))))
					       (string-append
						(real-&gt;flonum-string
						 (real-part object))
						;; for N+0.0i
						(if (char-numeric?
						     (string-ref imag-str 0))
						    &quot;+&quot; &quot;&quot;)
						imag-str
						&quot;i&quot;))))))
				(precision
				 (let ((p (inexact-&gt;exact (abs precision))))
				   (if (real? object)
				       (e-mold (number-&gt;string
						(exact-&gt;inexact object)) p)
				       (let ((imag-str
					      (number-&gt;string
					       (exact-&gt;inexact
						(imag-part object)))))
					 (string-append
					  (e-mold (number-&gt;string
						   (exact-&gt;inexact
						    (real-part object))) p)
					  ;; for N+0.0i
					  (if (char-numeric?
					       (string-ref imag-str 0))
					      &quot;+&quot; &quot;&quot;)
					  (e-mold imag-str p)
					  &quot;i&quot;)))))
				(else
				 (number-&gt;string
				  (cond
				   (inexact-sign (inexact-&gt;exact object))
				   (exactness (if (eq? exactness 'exact)
						  (inexact-&gt;exact object)
						  (exact-&gt;inexact object)))
				   (else object))
				  (cdr (assq radix '((decimal . 10)
						     (octal . 8)
						     (hexadecimal . 16)
						     (binary . 2))))))))
			      (str
			       (if separator
				   (fixnum-string-separate
				    str
				    (string (car separator))
				    (if (null? (cdr separator))
					3 (abs (cadr separator)))
				    (negative? (real-part object)))
				   str))
			      (str
			       (string-append
				(or inexact-sign &quot;&quot;)
				(if (or (and precision
					     (not point)
					     (or (eq? exactness 'exact)
						 (and (exact? object)
						      ;;(not (eq? exactness
						      ;;	  'inexact))
						      (not exactness)
						      (or (positive? precision)
							  (eqv? precision
								0.0)))))
					(and point
					     (eq? exactness 'exact)))
				    &quot;#e&quot; &quot;&quot;)
				(cdr (assq radix
					   '((decimal . &quot;&quot;)
					     (octal . &quot;#o&quot;)
					     (hexadecimal . &quot;#x&quot;)
					     (binary . &quot;#b&quot;))))
				(if (and sign
					 ;;(positive? (real-part object)))
					 ;; for 0.0
					 (char-numeric? (string-ref str 0)))
				    &quot;+&quot; &quot;&quot;)
				str))
			      (str (if pipe
				       (if (list? pipe)
					   (let loop ((str ((car pipe) str))
						      (fns (cdr pipe)))
					     (if (null? fns)
						 str
						 (loop ((car fns) str)
						       (cdr fns))))
					   (apply
					    string-append
					    (let loop ((fns pipe))
					      (if (procedure? fns)
						  (list (fns str))
						  (cons ((car fns) str)
							(loop (cdr fns)))))))
				       str))
			      (str (if take (take-both-end str take) str))
			      (pad (- (abs width) (string-length str))))
			 (cond
			  ((&lt;= pad 0) str)
			  ((positive? width)
			   (if (char-numeric? char)
			       (let* ((len (string-length str))
				      (index (str-numeric-index str 0 len)))
				 (if index
				     ;;(if (zero? index)
				     (if (or (zero? index)
					     ;; for infinities and nans
					     (char=?
					      (string-ref str (- index 1))
					      #\.))
					 (string-append
					  (make-string pad char) str)
					 (string-append
					  (substring str 0 index)
					  (make-string pad char)
					  (substring str index len)))
				     (string-append
				      (make-string pad char) str)))
			       (string-append (make-string pad char) str)))
			  (else (string-append str (make-string pad char)))))
		       (let* ((str (object-&gt;string object writer))
			      (str (if separator
				       (fixnum-string-separate
					str
					(string (car separator))
					(if (null? (cdr separator))
					    3 (abs (cadr separator)))
					(negative? (real-part object)))
				       str))
			      (str (if pipe
				       (if (list? pipe)
					   (let loop ((str ((car pipe) str))
						      (fns (cdr pipe)))
					     (if (null? fns)
						 str
						 (loop ((car fns) str)
						       (cdr fns))))
					   (apply
					    string-append
					    (let loop ((fns pipe))
					      (if (procedure? fns)
						  (list (fns str))
						  (cons ((car fns) str)
							(loop (cdr fns)))))))
				       str))
			      (str (if take (take-both-end str take) str))
			      (pad (- (abs width) (string-length str))))
			 (cond
			  ((&lt;= pad 0) str)
			  ((positive? width)
			   (if (char-numeric? char)
			       (let* ((len (string-length str))
				      (index (str-numeric-index str 0 len)))
				 (if index
				     ;;(if (zero? index)
				     (if (or (zero? index)
					     ;; for infinities and nans
					     (char=?
					      (string-ref str (- index 1))
					      #\.))
					 (string-append
					  (make-string pad char)
					  str)
					 (string-append
					  (substring str 0 index)
					  (make-string pad char)
					  (substring str index len)))
				     (string-append (make-string pad char)
						    str)))
			       (string-append (make-string pad char) str)))
			  (else
			   (string-append str (make-string pad char))))))
		   (let* ((str
			   (if (eq? writer display)
			       (cond
				((symbol? object) (symbol-&gt;string object))
				((boolean? object) (if object &quot;#t&quot; &quot;#f&quot;))
				((char? object) (string object))
				((string? object) object)
				(else (object-&gt;string object writer)))
			       (if (eq? writer write)
				   (cond
				    ((symbol? object)
				     (symbol-&gt;string object))
				    ((boolean? object)
				     (if object &quot;#t&quot; &quot;#f&quot;))
				    (else (object-&gt;string object writer)))
				   (object-&gt;string object writer))))
			  (str (if (and separator
					(not (null? (cdr separator))))
				   (separate str (string (car separator))
					     (cadr separator))
				   str))
			  (str (if pipe
				   (if (list? pipe)
				       (let loop ((str ((car pipe) str))
						  (fns (cdr pipe)))
					 (if (null? fns)
					     str
					     (loop ((car fns) str) (cdr fns))))
				       (apply string-append
					      (let loop ((fns pipe))
						(if (procedure? fns)
						    (list (fns str))
						    (cons ((car fns) str)
							  (loop (cdr fns)))))))
				   str))
			  (str (if take (take-both-end str take) str))
			  (pad (- (abs width) (string-length str))))
		     (cond
		      ((&lt;= pad 0) str)
		      ((positive? width)
		       (string-append (make-string pad char) str))
		      (else
		       (string-append str (make-string pad char))))))))
	  (if port
	      (display str port)
	      str)))))

;;; eof
</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00009.html">Re: Another CAT procedure</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00011.html">An improved version of SRFI 54</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00009.html">Re: Another CAT procedure</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00011.html">An improved version of SRFI 54</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00010"><strong>Date</strong></a></li>
<li><a href="threads.html#00010"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
